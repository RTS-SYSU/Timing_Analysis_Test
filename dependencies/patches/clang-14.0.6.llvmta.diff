diff --color -uprN clang-14.0.6.src/include/clang/AST/Stmt.h clang-14.0.6.src.patched/include/clang/AST/Stmt.h
--- clang-14.0.6.src/include/clang/AST/Stmt.h	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/include/clang/AST/Stmt.h	2024-11-12 13:24:23.346651843 +0800
@@ -71,10 +71,10 @@ public:
   enum StmtClass {
     NoStmtClass = 0,
 #define STMT(CLASS, PARENT) CLASS##Class,
-#define STMT_RANGE(BASE, FIRST, LAST) \
-        first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class,
-#define LAST_STMT_RANGE(BASE, FIRST, LAST) \
-        first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class
+#define STMT_RANGE(BASE, FIRST, LAST)                                          \
+  first##BASE##Constant = FIRST##Class, last##BASE##Constant = LAST##Class,
+#define LAST_STMT_RANGE(BASE, FIRST, LAST)                                     \
+  first##BASE##Constant = FIRST##Class, last##BASE##Constant = LAST##Class
 #define ABSTRACT_STMT(STMT)
 #include "clang/AST/StmtNodes.inc"
   };
@@ -285,28 +285,28 @@ protected:
   //===--- Expression bitfields classes ---===//
 
   class ExprBitfields {
-    friend class ASTStmtReader; // deserialization
-    friend class AtomicExpr; // ctor
-    friend class BlockDeclRefExpr; // ctor
-    friend class CallExpr; // ctor
-    friend class CXXConstructExpr; // ctor
+    friend class ASTStmtReader;               // deserialization
+    friend class AtomicExpr;                  // ctor
+    friend class BlockDeclRefExpr;            // ctor
+    friend class CallExpr;                    // ctor
+    friend class CXXConstructExpr;            // ctor
     friend class CXXDependentScopeMemberExpr; // ctor
-    friend class CXXNewExpr; // ctor
-    friend class CXXUnresolvedConstructExpr; // ctor
-    friend class DeclRefExpr; // computeDependence
-    friend class DependentScopeDeclRefExpr; // ctor
-    friend class DesignatedInitExpr; // ctor
+    friend class CXXNewExpr;                  // ctor
+    friend class CXXUnresolvedConstructExpr;  // ctor
+    friend class DeclRefExpr;                 // computeDependence
+    friend class DependentScopeDeclRefExpr;   // ctor
+    friend class DesignatedInitExpr;          // ctor
     friend class Expr;
-    friend class InitListExpr; // ctor
-    friend class ObjCArrayLiteral; // ctor
+    friend class InitListExpr;          // ctor
+    friend class ObjCArrayLiteral;      // ctor
     friend class ObjCDictionaryLiteral; // ctor
-    friend class ObjCMessageExpr; // ctor
-    friend class OffsetOfExpr; // ctor
-    friend class OpaqueValueExpr; // ctor
-    friend class OverloadExpr; // ctor
-    friend class ParenListExpr; // ctor
-    friend class PseudoObjectExpr; // ctor
-    friend class ShuffleVectorExpr; // ctor
+    friend class ObjCMessageExpr;       // ctor
+    friend class OffsetOfExpr;          // ctor
+    friend class OpaqueValueExpr;       // ctor
+    friend class OverloadExpr;          // ctor
+    friend class ParenListExpr;         // ctor
+    friend class PseudoObjectExpr;      // ctor
+    friend class ShuffleVectorExpr;     // ctor
 
     unsigned : NumStmtBits;
 
@@ -381,7 +381,6 @@ protected:
     SourceLocation Loc;
   };
 
-
   class FloatingLiteralBitfields {
     friend class FloatingLiteral;
 
@@ -1081,10 +1080,9 @@ protected:
 public:
   // Only allow allocation of Stmts using the allocator in ASTContext
   // or by doing a placement new.
-  void* operator new(size_t bytes, const ASTContext& C,
-                     unsigned alignment = 8);
+  void *operator new(size_t bytes, const ASTContext &C, unsigned alignment = 8);
 
-  void* operator new(size_t bytes, const ASTContext* C,
+  void *operator new(size_t bytes, const ASTContext *C,
                      unsigned alignment = 8) {
     return operator new(bytes, *C, alignment);
   }
@@ -1115,7 +1113,7 @@ protected:
   ///
   /// This is needed because AST nodes use Stmt* arrays to store
   /// references to children (to be compatible with StmtIterator).
-  template<typename T, typename TPtr = T *, typename StmtPtr = Stmt *>
+  template <typename T, typename TPtr = T *, typename StmtPtr = Stmt *>
   struct CastIterator
       : llvm::iterator_adaptor_base<CastIterator<T, TPtr, StmtPtr>, StmtPtr *,
                                     std::random_access_iterator_tag, TPtr> {
@@ -1157,7 +1155,8 @@ public:
     static_assert(sizeof(*this) % alignof(void *) == 0,
                   "Insufficient alignment!");
     StmtBits.sClass = SC;
-    if (StatisticsEnabled) Stmt::addStmtClass(SC);
+    if (StatisticsEnabled)
+      Stmt::addStmtClass(SC);
   }
 
   StmtClass getStmtClass() const {
@@ -1239,8 +1238,8 @@ public:
 
   const Stmt *stripLabelLikeStatements() const;
   Stmt *stripLabelLikeStatements() {
-    return const_cast<Stmt*>(
-      const_cast<const Stmt*>(this)->stripLabelLikeStatements());
+    return const_cast<Stmt *>(
+        const_cast<const Stmt *>(this)->stripLabelLikeStatements());
   }
 
   /// Child Iterators: All subclasses must implement 'children'
@@ -1287,7 +1286,7 @@ public:
   ///
   /// \param Hash an ODRHash object which will be called where pointers would
   /// have been used in the Profile function.
-  void ProcessODRHash(llvm::FoldingSetNodeID &ID, ODRHash& Hash) const;
+  void ProcessODRHash(llvm::FoldingSetNodeID &ID, ODRHash &Hash) const;
 };
 
 /// DeclStmt - Adaptor class for mixing declarations with statements and
@@ -1790,7 +1789,7 @@ public:
   const Expr *getExprStmt() const;
   Expr *getExprStmt() {
     const ValueStmt *ConstThis = this;
-    return const_cast<Expr*>(ConstThis->getExprStmt());
+    return const_cast<Expr *>(ConstThis->getExprStmt());
   }
 
   static bool classof(const Stmt *T) {
@@ -1829,7 +1828,9 @@ public:
   void setSubStmt(Stmt *SS) { SubStmt = SS; }
 
   SourceLocation getBeginLoc() const { return getIdentLoc(); }
-  SourceLocation getEndLoc() const LLVM_READONLY { return SubStmt->getEndLoc();}
+  SourceLocation getEndLoc() const LLVM_READONLY {
+    return SubStmt->getEndLoc();
+  }
 
   child_range children() { return child_range(&SubStmt, &SubStmt + 1); }
 
@@ -1892,7 +1893,9 @@ public:
   const Stmt *getSubStmt() const { return SubStmt; }
 
   SourceLocation getBeginLoc() const { return getAttrLoc(); }
-  SourceLocation getEndLoc() const LLVM_READONLY { return SubStmt->getEndLoc();}
+  SourceLocation getEndLoc() const LLVM_READONLY {
+    return SubStmt->getEndLoc();
+  }
 
   child_range children() { return child_range(&SubStmt, &SubStmt + 1); }
 
@@ -2110,7 +2113,7 @@ public:
 
   /// If this is an 'if constexpr', determine which substatement will be taken.
   /// Otherwise, or if the condition is value-dependent, returns None.
-  Optional<const Stmt*> getNondiscardedCase(const ASTContext &Ctx) const;
+  Optional<const Stmt *> getNondiscardedCase(const ASTContext &Ctx) const;
   Optional<Stmt *> getNondiscardedCase(const ASTContext &Ctx);
 
   bool isObjCAvailabilityCheck() const;
@@ -2477,6 +2480,17 @@ public:
                              getTrailingObjects<Stmt *>() +
                                  numTrailingObjects(OverloadToken<Stmt *>()));
   }
+
+  // Modified By Zeng-WCh
+private:
+  mutable uint64_t *Bound;
+
+public:
+  void setBound(uint64_t *B) const { Bound = B; }
+  uint64_t *getBound() const { return Bound; }
+  uint64_t getLowerBound() const { return Bound[0]; }
+  uint64_t getUpperBound() const { return Bound[1]; }
+  // End Modification
 };
 
 /// DoStmt - This represents a 'do/while' stmt.
@@ -2489,14 +2503,15 @@ class DoStmt : public Stmt {
 public:
   DoStmt(Stmt *Body, Expr *Cond, SourceLocation DL, SourceLocation WL,
          SourceLocation RP)
-      : Stmt(DoStmtClass), WhileLoc(WL), RParenLoc(RP) {
+      : Stmt(DoStmtClass), WhileLoc(WL), RParenLoc(RP), Bound(nullptr) {
     setCond(Cond);
     setBody(Body);
     setDoLoc(DL);
   }
 
   /// Build an empty do-while statement.
-  explicit DoStmt(EmptyShell Empty) : Stmt(DoStmtClass, Empty) {}
+  explicit DoStmt(EmptyShell Empty)
+      : Stmt(DoStmtClass, Empty), Bound(nullptr) {}
 
   Expr *getCond() { return reinterpret_cast<Expr *>(SubExprs[COND]); }
   const Expr *getCond() const {
@@ -2531,6 +2546,17 @@ public:
   const_child_range children() const {
     return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);
   }
+
+  // Modified By Zeng-WCh
+private:
+  mutable uint64_t *Bound;
+
+public:
+  void setBound(uint64_t *B) const { Bound = B; }
+  uint64_t *getBound() const { return Bound; }
+  uint64_t getLowerBound() const { return Bound[0]; }
+  uint64_t getUpperBound() const { return Bound[1]; }
+  // End Modification
 };
 
 /// ForStmt - This represents a 'for (init;cond;inc)' stmt.  Note that any of
@@ -2538,7 +2564,7 @@ public:
 /// specified in the source.
 class ForStmt : public Stmt {
   enum { INIT, CONDVAR, COND, INC, BODY, END_EXPR };
-  Stmt* SubExprs[END_EXPR]; // SubExprs[INIT] is an expression or declstmt.
+  Stmt *SubExprs[END_EXPR]; // SubExprs[INIT] is an expression or declstmt.
   SourceLocation LParenLoc, RParenLoc;
 
 public:
@@ -2547,7 +2573,8 @@ public:
           SourceLocation RP);
 
   /// Build an empty for statement.
-  explicit ForStmt(EmptyShell Empty) : Stmt(ForStmtClass, Empty) {}
+  explicit ForStmt(EmptyShell Empty)
+      : Stmt(ForStmtClass, Empty), Bound(nullptr) {}
 
   Stmt *getInit() { return SubExprs[INIT]; }
 
@@ -2565,21 +2592,23 @@ public:
   /// If this ForStmt has a condition variable, return the faux DeclStmt
   /// associated with the creation of that condition variable.
   const DeclStmt *getConditionVariableDeclStmt() const {
-    return reinterpret_cast<DeclStmt*>(SubExprs[CONDVAR]);
+    return reinterpret_cast<DeclStmt *>(SubExprs[CONDVAR]);
   }
 
-  Expr *getCond() { return reinterpret_cast<Expr*>(SubExprs[COND]); }
-  Expr *getInc()  { return reinterpret_cast<Expr*>(SubExprs[INC]); }
+  Expr *getCond() { return reinterpret_cast<Expr *>(SubExprs[COND]); }
+  Expr *getInc() { return reinterpret_cast<Expr *>(SubExprs[INC]); }
   Stmt *getBody() { return SubExprs[BODY]; }
 
   const Stmt *getInit() const { return SubExprs[INIT]; }
-  const Expr *getCond() const { return reinterpret_cast<Expr*>(SubExprs[COND]);}
-  const Expr *getInc()  const { return reinterpret_cast<Expr*>(SubExprs[INC]); }
+  const Expr *getCond() const {
+    return reinterpret_cast<Expr *>(SubExprs[COND]);
+  }
+  const Expr *getInc() const { return reinterpret_cast<Expr *>(SubExprs[INC]); }
   const Stmt *getBody() const { return SubExprs[BODY]; }
 
   void setInit(Stmt *S) { SubExprs[INIT] = S; }
-  void setCond(Expr *E) { SubExprs[COND] = reinterpret_cast<Stmt*>(E); }
-  void setInc(Expr *E) { SubExprs[INC] = reinterpret_cast<Stmt*>(E); }
+  void setCond(Expr *E) { SubExprs[COND] = reinterpret_cast<Stmt *>(E); }
+  void setInc(Expr *E) { SubExprs[INC] = reinterpret_cast<Stmt *>(E); }
   void setBody(Stmt *S) { SubExprs[BODY] = S; }
 
   SourceLocation getForLoc() const { return ForStmtBits.ForLoc; }
@@ -2598,12 +2627,23 @@ public:
 
   // Iterators
   child_range children() {
-    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);
+    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);
   }
 
   const_child_range children() const {
     return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);
   }
+
+  // Modified By Zeng-WCh
+private:
+  mutable uint64_t *Bound;
+
+public:
+  void setBound(uint64_t *B) const { Bound = B; }
+  uint64_t *getBound() const { return Bound; }
+  uint64_t getLowerBound() const { return Bound[0]; }
+  uint64_t getUpperBound() const { return Bound[1]; }
+  // End Modification
 };
 
 /// GotoStmt - This represents a direct goto.
@@ -2727,9 +2767,7 @@ public:
 /// BreakStmt - This represents a break.
 class BreakStmt : public Stmt {
 public:
-  BreakStmt(SourceLocation BL) : Stmt(BreakStmtClass) {
-    setBreakLoc(BL);
-  }
+  BreakStmt(SourceLocation BL) : Stmt(BreakStmtClass) { setBreakLoc(BL); }
 
   /// Build an empty break statement.
   explicit BreakStmt(EmptyShell Empty) : Stmt(BreakStmtClass, Empty) {}
@@ -2867,9 +2905,9 @@ protected:
 
   AsmStmt(StmtClass SC, SourceLocation asmloc, bool issimple, bool isvolatile,
           unsigned numoutputs, unsigned numinputs, unsigned numclobbers)
-      : Stmt (SC), AsmLoc(asmloc), IsSimple(issimple), IsVolatile(isvolatile),
-        NumOutputs(numoutputs), NumInputs(numinputs),
-        NumClobbers(numclobbers) {}
+      : Stmt(SC), AsmLoc(asmloc), IsSimple(issimple), IsVolatile(isvolatile),
+        NumOutputs(numoutputs), NumInputs(numinputs), NumClobbers(numclobbers) {
+  }
 
 public:
   /// Build an empty inline-assembly statement.
@@ -2931,7 +2969,7 @@ public:
 
   static bool classof(const Stmt *T) {
     return T->getStmtClass() == GCCAsmStmtClass ||
-      T->getStmtClass() == MSAsmStmtClass;
+           T->getStmtClass() == MSAsmStmtClass;
   }
 
   // Input expr iterators.
@@ -2941,19 +2979,13 @@ public:
   using inputs_range = llvm::iterator_range<inputs_iterator>;
   using inputs_const_range = llvm::iterator_range<const_inputs_iterator>;
 
-  inputs_iterator begin_inputs() {
-    return &Exprs[0] + NumOutputs;
-  }
+  inputs_iterator begin_inputs() { return &Exprs[0] + NumOutputs; }
 
-  inputs_iterator end_inputs() {
-    return &Exprs[0] + NumOutputs + NumInputs;
-  }
+  inputs_iterator end_inputs() { return &Exprs[0] + NumOutputs + NumInputs; }
 
   inputs_range inputs() { return inputs_range(begin_inputs(), end_inputs()); }
 
-  const_inputs_iterator begin_inputs() const {
-    return &Exprs[0] + NumOutputs;
-  }
+  const_inputs_iterator begin_inputs() const { return &Exprs[0] + NumOutputs; }
 
   const_inputs_iterator end_inputs() const {
     return &Exprs[0] + NumOutputs + NumInputs;
@@ -2970,25 +3002,17 @@ public:
   using outputs_range = llvm::iterator_range<outputs_iterator>;
   using outputs_const_range = llvm::iterator_range<const_outputs_iterator>;
 
-  outputs_iterator begin_outputs() {
-    return &Exprs[0];
-  }
+  outputs_iterator begin_outputs() { return &Exprs[0]; }
 
-  outputs_iterator end_outputs() {
-    return &Exprs[0] + NumOutputs;
-  }
+  outputs_iterator end_outputs() { return &Exprs[0] + NumOutputs; }
 
   outputs_range outputs() {
     return outputs_range(begin_outputs(), end_outputs());
   }
 
-  const_outputs_iterator begin_outputs() const {
-    return &Exprs[0];
-  }
+  const_outputs_iterator begin_outputs() const { return &Exprs[0]; }
 
-  const_outputs_iterator end_outputs() const {
-    return &Exprs[0] + NumOutputs;
-  }
+  const_outputs_iterator end_outputs() const { return &Exprs[0] + NumOutputs; }
 
   outputs_const_range outputs() const {
     return outputs_const_range(begin_outputs(), end_outputs());
@@ -3042,8 +3066,8 @@ public:
   class AsmStringPiece {
   public:
     enum Kind {
-      String,  // String in .ll asm string form, "$" -> "$$" and "%%" -> "%".
-      Operand  // Operand reference, with optional modifier %c4.
+      String, // String in .ll asm string form, "$" -> "$$" and "%%" -> "%".
+      Operand // Operand reference, with optional modifier %c4.
     };
 
   private:
@@ -3115,7 +3139,7 @@ public:
   Expr *getOutputExpr(unsigned i);
 
   const Expr *getOutputExpr(unsigned i) const {
-    return const_cast<GCCAsmStmt*>(this)->getOutputExpr(i);
+    return const_cast<GCCAsmStmt *>(this)->getOutputExpr(i);
   }
 
   //===--- Input operands ---===//
@@ -3144,18 +3168,14 @@ public:
   void setInputExpr(unsigned i, Expr *E);
 
   const Expr *getInputExpr(unsigned i) const {
-    return const_cast<GCCAsmStmt*>(this)->getInputExpr(i);
+    return const_cast<GCCAsmStmt *>(this)->getInputExpr(i);
   }
 
   //===--- Labels ---===//
 
-  bool isAsmGoto() const {
-    return NumLabels > 0;
-  }
+  bool isAsmGoto() const { return NumLabels > 0; }
 
-  unsigned getNumLabels() const {
-    return NumLabels;
-  }
+  unsigned getNumLabels() const { return NumLabels; }
 
   IdentifierInfo *getLabelIdentifier(unsigned i) const {
     return Names[i + NumOutputs + NumInputs];
@@ -3168,17 +3188,13 @@ public:
   using labels_range = llvm::iterator_range<labels_iterator>;
   using labels_const_range = llvm::iterator_range<const_labels_iterator>;
 
-  labels_iterator begin_labels() {
-    return &Exprs[0] + NumOutputs + NumInputs;
-  }
+  labels_iterator begin_labels() { return &Exprs[0] + NumOutputs + NumInputs; }
 
   labels_iterator end_labels() {
     return &Exprs[0] + NumOutputs + NumInputs + NumLabels;
   }
 
-  labels_range labels() {
-    return labels_range(begin_labels(), end_labels());
-  }
+  labels_range labels() { return labels_range(begin_labels(), end_labels()); }
 
   const_labels_iterator begin_labels() const {
     return &Exprs[0] + NumOutputs + NumInputs;
@@ -3193,15 +3209,10 @@ public:
   }
 
 private:
-  void setOutputsAndInputsAndClobbers(const ASTContext &C,
-                                      IdentifierInfo **Names,
-                                      StringLiteral **Constraints,
-                                      Stmt **Exprs,
-                                      unsigned NumOutputs,
-                                      unsigned NumInputs,
-                                      unsigned NumLabels,
-                                      StringLiteral **Clobbers,
-                                      unsigned NumClobbers);
+  void setOutputsAndInputsAndClobbers(
+      const ASTContext &C, IdentifierInfo **Names, StringLiteral **Constraints,
+      Stmt **Exprs, unsigned NumOutputs, unsigned NumInputs, unsigned NumLabels,
+      StringLiteral **Clobbers, unsigned NumClobbers);
 
 public:
   //===--- Other ---===//
@@ -3243,9 +3254,9 @@ public:
   MSAsmStmt(const ASTContext &C, SourceLocation asmloc,
             SourceLocation lbraceloc, bool issimple, bool isvolatile,
             ArrayRef<Token> asmtoks, unsigned numoutputs, unsigned numinputs,
-            ArrayRef<StringRef> constraints,
-            ArrayRef<Expr*> exprs, StringRef asmstr,
-            ArrayRef<StringRef> clobbers, SourceLocation endloc);
+            ArrayRef<StringRef> constraints, ArrayRef<Expr *> exprs,
+            StringRef asmstr, ArrayRef<StringRef> clobbers,
+            SourceLocation endloc);
 
   /// Build an empty MS-style inline-assembly statement.
   explicit MSAsmStmt(EmptyShell Empty) : AsmStmt(MSAsmStmtClass, Empty) {}
@@ -3276,7 +3287,7 @@ public:
   Expr *getOutputExpr(unsigned i);
 
   const Expr *getOutputExpr(unsigned i) const {
-    return const_cast<MSAsmStmt*>(this)->getOutputExpr(i);
+    return const_cast<MSAsmStmt *>(this)->getOutputExpr(i);
   }
 
   //===--- Input operands ---===//
@@ -3290,7 +3301,7 @@ public:
   void setInputExpr(unsigned i, Expr *E);
 
   const Expr *getInputExpr(unsigned i) const {
-    return const_cast<MSAsmStmt*>(this)->getInputExpr(i);
+    return const_cast<MSAsmStmt *>(this)->getInputExpr(i);
   }
 
   //===--- Other ---===//
@@ -3303,8 +3314,8 @@ public:
     return llvm::makeArrayRef(Clobbers, NumClobbers);
   }
 
-  ArrayRef<Expr*> getAllExprs() const {
-    return llvm::makeArrayRef(reinterpret_cast<Expr**>(Exprs),
+  ArrayRef<Expr *> getAllExprs() const {
+    return llvm::makeArrayRef(reinterpret_cast<Expr **>(Exprs),
                               NumInputs + NumOutputs);
   }
 
@@ -3313,7 +3324,7 @@ public:
 private:
   void initialize(const ASTContext &C, StringRef AsmString,
                   ArrayRef<Token> AsmToks, ArrayRef<StringRef> Constraints,
-                  ArrayRef<Expr*> Exprs, ArrayRef<StringRef> Clobbers);
+                  ArrayRef<Expr *> Exprs, ArrayRef<StringRef> Clobbers);
 
 public:
   SourceLocation getBeginLoc() const LLVM_READONLY { return AsmLoc; }
@@ -3335,7 +3346,7 @@ class SEHExceptStmt : public Stmt {
   friend class ASTReader;
   friend class ASTStmtReader;
 
-  SourceLocation  Loc;
+  SourceLocation Loc;
   Stmt *Children[2];
 
   enum { FILTER_EXPR, BLOCK };
@@ -3344,10 +3355,8 @@ class SEHExceptStmt : public Stmt {
   explicit SEHExceptStmt(EmptyShell E) : Stmt(SEHExceptStmtClass, E) {}
 
 public:
-  static SEHExceptStmt* Create(const ASTContext &C,
-                               SourceLocation ExceptLoc,
-                               Expr *FilterExpr,
-                               Stmt *Block);
+  static SEHExceptStmt *Create(const ASTContext &C, SourceLocation ExceptLoc,
+                               Expr *FilterExpr, Stmt *Block);
 
   SourceLocation getBeginLoc() const LLVM_READONLY { return getExceptLoc(); }
 
@@ -3355,16 +3364,12 @@ public:
   SourceLocation getEndLoc() const { return getBlock()->getEndLoc(); }
 
   Expr *getFilterExpr() const {
-    return reinterpret_cast<Expr*>(Children[FILTER_EXPR]);
+    return reinterpret_cast<Expr *>(Children[FILTER_EXPR]);
   }
 
-  CompoundStmt *getBlock() const {
-    return cast<CompoundStmt>(Children[BLOCK]);
-  }
+  CompoundStmt *getBlock() const { return cast<CompoundStmt>(Children[BLOCK]); }
 
-  child_range children() {
-    return child_range(Children, Children+2);
-  }
+  child_range children() { return child_range(Children, Children + 2); }
 
   const_child_range children() const {
     return const_child_range(Children, Children + 2);
@@ -3379,15 +3384,14 @@ class SEHFinallyStmt : public Stmt {
   friend class ASTReader;
   friend class ASTStmtReader;
 
-  SourceLocation  Loc;
+  SourceLocation Loc;
   Stmt *Block;
 
   SEHFinallyStmt(SourceLocation Loc, Stmt *Block);
   explicit SEHFinallyStmt(EmptyShell E) : Stmt(SEHFinallyStmtClass, E) {}
 
 public:
-  static SEHFinallyStmt* Create(const ASTContext &C,
-                                SourceLocation FinallyLoc,
+  static SEHFinallyStmt *Create(const ASTContext &C, SourceLocation FinallyLoc,
                                 Stmt *Block);
 
   SourceLocation getBeginLoc() const LLVM_READONLY { return getFinallyLoc(); }
@@ -3397,9 +3401,7 @@ public:
 
   CompoundStmt *getBlock() const { return cast<CompoundStmt>(Block); }
 
-  child_range children() {
-    return child_range(&Block,&Block+1);
-  }
+  child_range children() { return child_range(&Block, &Block + 1); }
 
   const_child_range children() const {
     return const_child_range(&Block, &Block + 1);
@@ -3415,20 +3417,18 @@ class SEHTryStmt : public Stmt {
   friend class ASTStmtReader;
 
   bool IsCXXTry;
-  SourceLocation  TryLoc;
+  SourceLocation TryLoc;
   Stmt *Children[2];
 
   enum { TRY = 0, HANDLER = 1 };
 
   SEHTryStmt(bool isCXXTry, // true if 'try' otherwise '__try'
-             SourceLocation TryLoc,
-             Stmt *TryBlock,
-             Stmt *Handler);
+             SourceLocation TryLoc, Stmt *TryBlock, Stmt *Handler);
 
   explicit SEHTryStmt(EmptyShell E) : Stmt(SEHTryStmtClass, E) {}
 
 public:
-  static SEHTryStmt* Create(const ASTContext &C, bool isCXXTry,
+  static SEHTryStmt *Create(const ASTContext &C, bool isCXXTry,
                             SourceLocation TryLoc, Stmt *TryBlock,
                             Stmt *Handler);
 
@@ -3439,19 +3439,17 @@ public:
 
   bool getIsCXXTry() const { return IsCXXTry; }
 
-  CompoundStmt* getTryBlock() const {
+  CompoundStmt *getTryBlock() const {
     return cast<CompoundStmt>(Children[TRY]);
   }
 
   Stmt *getHandler() const { return Children[HANDLER]; }
 
   /// Returns 0 if not defined
-  SEHExceptStmt  *getExceptHandler() const;
+  SEHExceptStmt *getExceptHandler() const;
   SEHFinallyStmt *getFinallyHandler() const;
 
-  child_range children() {
-    return child_range(Children, Children+2);
-  }
+  child_range children() { return child_range(Children, Children + 2); }
 
   const_child_range children() const {
     return const_child_range(Children, Children + 2);
@@ -3596,8 +3594,8 @@ public:
   static CapturedStmt *Create(const ASTContext &Context, Stmt *S,
                               CapturedRegionKind Kind,
                               ArrayRef<Capture> Captures,
-                              ArrayRef<Expr *> CaptureInits,
-                              CapturedDecl *CD, RecordDecl *RD);
+                              ArrayRef<Expr *> CaptureInits, CapturedDecl *CD,
+                              RecordDecl *RD);
 
   static CapturedStmt *CreateDeserialized(const ASTContext &Context,
                                           unsigned NumCaptures);
diff --color -uprN clang-14.0.6.src/include/clang/Basic/TokenKinds.def clang-14.0.6.src.patched/include/clang/Basic/TokenKinds.def
--- clang-14.0.6.src/include/clang/Basic/TokenKinds.def	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/include/clang/Basic/TokenKinds.def	2024-11-12 13:24:23.346651843 +0800
@@ -896,6 +896,7 @@ ANNOTATION(module_end)
 // Annotation for a header_name token that has been looked up and transformed
 // into the name of a header unit.
 ANNOTATION(header_unit)
+ANNOTATION(loop_bound)
 
 #undef PRAGMA_ANNOTATION
 #undef ANNOTATION
diff --color -uprN clang-14.0.6.src/include/clang/Parse/Parser.h clang-14.0.6.src.patched/include/clang/Parse/Parser.h
--- clang-14.0.6.src/include/clang/Parse/Parser.h	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/include/clang/Parse/Parser.h	2024-11-12 13:24:23.346651843 +0800
@@ -31,27 +31,27 @@
 #include <stack>
 
 namespace clang {
-  class PragmaHandler;
-  class Scope;
-  class BalancedDelimiterTracker;
-  class CorrectionCandidateCallback;
-  class DeclGroupRef;
-  class DiagnosticBuilder;
-  struct LoopHint;
-  class Parser;
-  class ParsingDeclRAIIObject;
-  class ParsingDeclSpec;
-  class ParsingDeclarator;
-  class ParsingFieldDeclarator;
-  class ColonProtectionRAIIObject;
-  class InMessageExpressionRAIIObject;
-  class PoisonSEHIdentifiersRAIIObject;
-  class OMPClause;
-  class ObjCTypeParamList;
-  struct OMPTraitProperty;
-  struct OMPTraitSelector;
-  struct OMPTraitSet;
-  class OMPTraitInfo;
+class PragmaHandler;
+class Scope;
+class BalancedDelimiterTracker;
+class CorrectionCandidateCallback;
+class DeclGroupRef;
+class DiagnosticBuilder;
+struct LoopHint;
+class Parser;
+class ParsingDeclRAIIObject;
+class ParsingDeclSpec;
+class ParsingDeclarator;
+class ParsingFieldDeclarator;
+class ColonProtectionRAIIObject;
+class InMessageExpressionRAIIObject;
+class PoisonSEHIdentifiersRAIIObject;
+class OMPClause;
+class ObjCTypeParamList;
+struct OMPTraitProperty;
+struct OMPTraitSelector;
+struct OMPTraitSet;
+class OMPTraitInfo;
 
 /// Parser - This implements a parser for the C family of languages.  After
 /// parsing units of the grammar, productions are invoked to handle whatever has
@@ -99,17 +99,14 @@ class Parser : public CodeCompletionHand
   /// Identifiers used for SEH handling in Borland. These are only
   /// allowed in particular circumstances
   // __except block
-  IdentifierInfo *Ident__exception_code,
-                 *Ident___exception_code,
-                 *Ident_GetExceptionCode;
+  IdentifierInfo *Ident__exception_code, *Ident___exception_code,
+      *Ident_GetExceptionCode;
   // __except filter expression
-  IdentifierInfo *Ident__exception_info,
-                 *Ident___exception_info,
-                 *Ident_GetExceptionInfo;
+  IdentifierInfo *Ident__exception_info, *Ident___exception_info,
+      *Ident_GetExceptionInfo;
   // __finally
-  IdentifierInfo *Ident__abnormal_termination,
-                 *Ident___abnormal_termination,
-                 *Ident_AbnormalTermination;
+  IdentifierInfo *Ident__abnormal_termination, *Ident___abnormal_termination,
+      *Ident_AbnormalTermination;
 
   /// Contextual keywords for Microsoft extensions.
   IdentifierInfo *Ident__except;
@@ -213,6 +210,10 @@ class Parser : public CodeCompletionHand
   std::unique_ptr<PragmaHandler> MaxTokensHerePragmaHandler;
   std::unique_ptr<PragmaHandler> MaxTokensTotalPragmaHandler;
 
+  // Modified by Zeng-WCh
+  std::unique_ptr<PragmaHandler> LoopBoundHandler;
+  // End Modification
+
   std::unique_ptr<CommentHandler> CommentSemaHandler;
 
   /// Whether the '>' token acts as an operator or not. This will be
@@ -252,13 +253,12 @@ class Parser : public CodeCompletionHand
   class TemplateParameterDepthRAII {
     unsigned &Depth;
     unsigned AddedLevels;
+
   public:
     explicit TemplateParameterDepthRAII(unsigned &Depth)
-      : Depth(Depth), AddedLevels(0) {}
+        : Depth(Depth), AddedLevels(0) {}
 
-    ~TemplateParameterDepthRAII() {
-      Depth -= AddedLevels;
-    }
+    ~TemplateParameterDepthRAII() { Depth -= AddedLevels; }
 
     void operator++() {
       ++Depth;
@@ -363,8 +363,8 @@ class Parser : public CodeCompletionHand
           Locs.back().Priority = Prio;
         }
       } else {
-        Locs.push_back({TemplateName, LessLoc, Prio,
-                        P.ParenCount, P.BracketCount, P.BraceCount});
+        Locs.push_back({TemplateName, LessLoc, Prio, P.ParenCount,
+                        P.BracketCount, P.BraceCount});
       }
     }
 
@@ -446,7 +446,7 @@ public:
     return Actions.incrementMSManglingNumber();
   }
 
-  Decl  *getObjCDeclContext() const { return Actions.getObjCDeclContext(); }
+  Decl *getObjCDeclContext() const { return Actions.getObjCDeclContext(); }
 
   // Type forwarding.  All of these are statically 'void*', but they may all be
   // different actual classes based on the actions in place.
@@ -524,7 +524,6 @@ public:
     return ConsumeToken();
   }
 
-
   SourceLocation getEndOfPreviousToken() {
     return PP.getLocForEndOfToken(PrevTokLocation);
   }
@@ -541,17 +540,13 @@ private:
   //
 
   /// isTokenParen - Return true if the cur token is '(' or ')'.
-  bool isTokenParen() const {
-    return Tok.isOneOf(tok::l_paren, tok::r_paren);
-  }
+  bool isTokenParen() const { return Tok.isOneOf(tok::l_paren, tok::r_paren); }
   /// isTokenBracket - Return true if the cur token is '[' or ']'.
   bool isTokenBracket() const {
     return Tok.isOneOf(tok::l_square, tok::r_square);
   }
   /// isTokenBrace - Return true if the cur token is '{' or '}'.
-  bool isTokenBrace() const {
-    return Tok.isOneOf(tok::l_brace, tok::r_brace);
-  }
+  bool isTokenBrace() const { return Tok.isOneOf(tok::l_brace, tok::r_brace); }
   /// isTokenStringLiteral - True if this token is a string-literal.
   bool isTokenStringLiteral() const {
     return tok::isStringLiteral(Tok.getKind());
@@ -569,10 +564,10 @@ private:
   /// Return the current token to the token stream and make the given
   /// token the current token.
   void UnconsumeToken(Token &Consumed) {
-      Token Next = Tok;
-      PP.EnterToken(Consumed, /*IsReinject*/true);
-      PP.Lex(Tok);
-      PP.EnterToken(Next, /*IsReinject*/true);
+    Token Next = Tok;
+    PP.EnterToken(Consumed, /*IsReinject*/ true);
+    PP.Lex(Tok);
+    PP.EnterToken(Next, /*IsReinject*/ true);
   }
 
   SourceLocation ConsumeAnnotationToken() {
@@ -591,7 +586,7 @@ private:
       ++ParenCount;
     else if (ParenCount) {
       AngleBrackets.clear(*this);
-      --ParenCount;       // Don't let unbalanced )'s drive the count negative.
+      --ParenCount; // Don't let unbalanced )'s drive the count negative.
     }
     PrevTokLocation = Tok.getLocation();
     PP.Lex(Tok);
@@ -606,7 +601,7 @@ private:
       ++BracketCount;
     else if (BracketCount) {
       AngleBrackets.clear(*this);
-      --BracketCount;     // Don't let unbalanced ]'s drive the count negative.
+      --BracketCount; // Don't let unbalanced ]'s drive the count negative.
     }
 
     PrevTokLocation = Tok.getLocation();
@@ -622,7 +617,7 @@ private:
       ++BraceCount;
     else if (BraceCount) {
       AngleBrackets.clear(*this);
-      --BraceCount;     // Don't let unbalanced }'s drive the count negative.
+      --BraceCount; // Don't let unbalanced }'s drive the count negative.
     }
 
     PrevTokLocation = Tok.getLocation();
@@ -783,16 +778,15 @@ private:
   /// the Parser always has one token lexed that the preprocessor doesn't.
   ///
   const Token &GetLookAheadToken(unsigned N) {
-    if (N == 0 || Tok.is(tok::eof)) return Tok;
-    return PP.LookAhead(N-1);
+    if (N == 0 || Tok.is(tok::eof))
+      return Tok;
+    return PP.LookAhead(N - 1);
   }
 
 public:
   /// NextToken - This peeks ahead one token and returns it without
   /// consuming it.
-  const Token &NextToken() {
-    return PP.LookAhead(0);
-  }
+  const Token &NextToken() { return PP.LookAhead(0); }
 
   /// getTypeAnnotation - Read a parsed type out of an annotation token.
   static TypeResult getTypeAnnotation(const Token &Tok) {
@@ -809,7 +803,7 @@ private:
   }
 
   static NamedDecl *getNonTypeAnnotation(const Token &Tok) {
-    return static_cast<NamedDecl*>(Tok.getAnnotationValue());
+    return static_cast<NamedDecl *>(Tok.getAnnotationValue());
   }
 
   static void setNonTypeAnnotation(Token &Tok, NamedDecl *ND) {
@@ -817,7 +811,7 @@ private:
   }
 
   static IdentifierInfo *getIdentifierAnnotation(const Token &Tok) {
-    return static_cast<IdentifierInfo*>(Tok.getAnnotationValue());
+    return static_cast<IdentifierInfo *>(Tok.getAnnotationValue());
   }
 
   static void setIdentifierAnnotation(Token &Tok, IdentifierInfo *ND) {
@@ -875,9 +869,8 @@ private:
   /// TryAltiVecToken - Check for context-sensitive AltiVec identifier tokens,
   /// replacing them with the non-context-sensitive keywords.  This returns
   /// true if the token was replaced.
-  bool TryAltiVecToken(DeclSpec &DS, SourceLocation Loc,
-                       const char *&PrevSpec, unsigned &DiagID,
-                       bool &isInvalid) {
+  bool TryAltiVecToken(DeclSpec &DS, SourceLocation Loc, const char *&PrevSpec,
+                       unsigned &DiagID, bool &isInvalid) {
     if (!getLangOpts().AltiVec && !getLangOpts().ZVector)
       return false;
 
@@ -895,7 +888,8 @@ private:
   /// This returns true if the token was replaced.
   bool TryAltiVecVectorToken() {
     if ((!getLangOpts().AltiVec && !getLangOpts().ZVector) ||
-        Tok.getIdentifierInfo() != Ident_vector) return false;
+        Tok.getIdentifierInfo() != Ident_vector)
+      return false;
     return TryAltiVecVectorTokenOutOfLine();
   }
 
@@ -999,10 +993,11 @@ private:
     Parser &P;
     Decl *DC;
     SaveAndRestore<bool> WithinObjCContainer;
+
   public:
     explicit ObjCDeclContextSwitch(Parser &p)
-      : P(p), DC(p.getObjCDeclContext()),
-        WithinObjCContainer(P.ParsingInObjCContainer, DC != nullptr) {
+        : P(p), DC(p.getObjCDeclContext()),
+          WithinObjCContainer(P.ParsingInObjCContainer, DC != nullptr) {
       if (DC)
         P.Actions.ActOnObjCTemporaryExitContainerContext(cast<DeclContext>(DC));
     }
@@ -1090,7 +1085,7 @@ public:
     // ScopeFlags, but only when we aren't about to enter a compound statement.
     ParseScope(Parser *Self, unsigned ScopeFlags, bool EnteredScope = true,
                bool BeforeCompoundStmt = false)
-      : Self(Self) {
+        : Self(Self) {
       if (EnteredScope && !BeforeCompoundStmt)
         Self->EnterScope(ScopeFlags);
       else {
@@ -1110,9 +1105,7 @@ public:
       }
     }
 
-    ~ParseScope() {
-      Exit();
-    }
+    ~ParseScope() { Exit(); }
   };
 
   /// Introduces zero or more scopes for parsing. The scopes will all be exited
@@ -1121,7 +1114,7 @@ public:
     Parser &Self;
     unsigned NumScopes = 0;
 
-    MultiParseScope(const MultiParseScope&) = delete;
+    MultiParseScope(const MultiParseScope &) = delete;
 
   public:
     MultiParseScope(Parser &Self) : Self(Self) {}
@@ -1135,9 +1128,7 @@ public:
         --NumScopes;
       }
     }
-    ~MultiParseScope() {
-      Exit();
-    }
+    ~MultiParseScope() { Exit(); }
   };
 
   /// EnterScope - Start a new scope.
@@ -1168,9 +1159,7 @@ private:
 public:
   DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID);
   DiagnosticBuilder Diag(const Token &Tok, unsigned DiagID);
-  DiagnosticBuilder Diag(unsigned DiagID) {
-    return Diag(Tok, DiagID);
-  }
+  DiagnosticBuilder Diag(unsigned DiagID) { return Diag(Tok, DiagID); }
 
 private:
   void SuggestParentheses(SourceLocation Loc, unsigned DK,
@@ -1178,10 +1167,9 @@ private:
   void CheckNestedObjCContexts(SourceLocation AtLoc);
 
 public:
-
   /// Control flags for SkipUntil functions.
   enum SkipUntilFlags {
-    StopAtSemi = 1 << 0,  ///< Stop skipping at semicolon
+    StopAtSemi = 1 << 0, ///< Stop skipping at semicolon
     /// Stop skipping at specified token, but don't skip the token itself
     StopBeforeMatch = 1 << 1,
     StopAtCodeCompletion = 1 << 2 ///< Stop at code completion
@@ -1283,11 +1271,11 @@ private:
     IdentifierInfo &AttrName;
     IdentifierInfo *MacroII = nullptr;
     SourceLocation AttrNameLoc;
-    SmallVector<Decl*, 2> Decls;
+    SmallVector<Decl *, 2> Decls;
 
     explicit LateParsedAttribute(Parser *P, IdentifierInfo &Name,
                                  SourceLocation Loc)
-      : Self(P), AttrName(Name), AttrNameLoc(Loc) {}
+        : Self(P), AttrName(Name), AttrNameLoc(Loc) {}
 
     void ParseLexedAttributes() override;
 
@@ -1315,14 +1303,14 @@ private:
   };
 
   // A list of late-parsed attributes.  Used by ParseGNUAttributes.
-  class LateParsedAttrList: public SmallVector<LateParsedAttribute *, 2> {
+  class LateParsedAttrList : public SmallVector<LateParsedAttribute *, 2> {
   public:
-    LateParsedAttrList(bool PSoon = false) : ParseSoon(PSoon) { }
+    LateParsedAttrList(bool PSoon = false) : ParseSoon(PSoon) {}
 
     bool parseSoon() { return ParseSoon; }
 
   private:
-    bool ParseSoon;  // Are we planning to parse these shortly after creation?
+    bool ParseSoon; // Are we planning to parse these shortly after creation?
   };
 
   /// Contains the lexed tokens of a member function definition
@@ -1343,9 +1331,9 @@ private:
   /// occurs within a member function declaration inside the class
   /// (C++ [class.mem]p2).
   struct LateParsedDefaultArgument {
-    explicit LateParsedDefaultArgument(Decl *P,
-                                       std::unique_ptr<CachedTokens> Toks = nullptr)
-      : Param(P), Toks(std::move(Toks)) { }
+    explicit LateParsedDefaultArgument(
+        Decl *P, std::unique_ptr<CachedTokens> Toks = nullptr)
+        : Param(P), Toks(std::move(Toks)) {}
 
     /// Param - The parameter declaration for this parameter.
     Decl *Param;
@@ -1388,8 +1376,7 @@ private:
   /// member whose parsing must to be delayed until the class is completely
   /// defined (C++11 [class.mem]p2).
   struct LateParsedMemberInitializer : public LateParsedDeclaration {
-    LateParsedMemberInitializer(Parser *P, Decl *FD)
-      : Self(P), Field(FD) { }
+    LateParsedMemberInitializer(Parser *P, Decl *FD) : Self(P), Field(FD) {}
 
     void ParseLexedMemberInitializers() override;
 
@@ -1409,7 +1396,8 @@ private:
   /// the method declarations and possibly attached inline definitions
   /// will be stored here with the tokens that will be parsed to create those
   /// entities.
-  typedef SmallVector<LateParsedDeclaration*,2> LateParsedDeclarationsContainer;
+  typedef SmallVector<LateParsedDeclaration *, 2>
+      LateParsedDeclarationsContainer;
 
   /// Representation of a class that has been parsed, including
   /// any member function declarations or definitions that need to be
@@ -1454,8 +1442,8 @@ private:
   public:
     ParsingClassDefinition(Parser &P, Decl *TagOrTemplate, bool TopLevelClass,
                            bool IsInterface)
-      : P(P), Popped(false),
-        State(P.PushParsingClass(TagOrTemplate, TopLevelClass, IsInterface)) {
+        : P(P), Popped(false),
+          State(P.PushParsingClass(TagOrTemplate, TopLevelClass, IsInterface)) {
     }
 
     /// Pop this class of the stack.
@@ -1480,15 +1468,15 @@ private:
     ParsedTemplateInfo(TemplateParameterLists *TemplateParams,
                        bool isSpecialization,
                        bool lastParameterListWasEmpty = false)
-      : Kind(isSpecialization? ExplicitSpecialization : Template),
-        TemplateParams(TemplateParams),
-        LastParameterListWasEmpty(lastParameterListWasEmpty) { }
+        : Kind(isSpecialization ? ExplicitSpecialization : Template),
+          TemplateParams(TemplateParams),
+          LastParameterListWasEmpty(lastParameterListWasEmpty) {}
 
     explicit ParsedTemplateInfo(SourceLocation ExternLoc,
                                 SourceLocation TemplateLoc)
-      : Kind(ExplicitInstantiation), TemplateParams(nullptr),
-        ExternLoc(ExternLoc), TemplateLoc(TemplateLoc),
-        LastParameterListWasEmpty(false){ }
+        : Kind(ExplicitInstantiation), TemplateParams(nullptr),
+          ExternLoc(ExternLoc), TemplateLoc(TemplateLoc),
+          LastParameterListWasEmpty(false) {}
 
     /// The kind of template we are parsing.
     enum {
@@ -1534,10 +1522,7 @@ private:
   void DeallocateParsedClasses(ParsingClass *Class);
   void PopParsingClass(Sema::ParsingClassState);
 
-  enum CachedInitKind {
-    CIK_DefaultArgument,
-    CIK_DefaultInitializer
-  };
+  enum CachedInitKind { CIK_DefaultArgument, CIK_DefaultInitializer };
 
   NamedDecl *ParseCXXInlineMethodDef(AccessSpecifier AS,
                                      ParsedAttributes &AccessAttrs,
@@ -1549,8 +1534,8 @@ private:
   void ParseLexedAttributes(ParsingClass &Class);
   void ParseLexedAttributeList(LateParsedAttrList &LAs, Decl *D,
                                bool EnterScope, bool OnDefinition);
-  void ParseLexedAttribute(LateParsedAttribute &LA,
-                           bool EnterScope, bool OnDefinition);
+  void ParseLexedAttribute(LateParsedAttribute &LA, bool EnterScope,
+                           bool OnDefinition);
   void ParseLexedMethodDeclarations(ParsingClass &Class);
   void ParseLexedMethodDeclaration(LateParsedMethodDeclaration &LM);
   void ParseLexedMethodDefs(ParsingClass &Class);
@@ -1563,15 +1548,13 @@ private:
   bool ConsumeAndStoreFunctionPrologue(CachedTokens &Toks);
   bool ConsumeAndStoreInitializer(CachedTokens &Toks, CachedInitKind CIK);
   bool ConsumeAndStoreConditional(CachedTokens &Toks);
-  bool ConsumeAndStoreUntil(tok::TokenKind T1,
-                            CachedTokens &Toks,
+  bool ConsumeAndStoreUntil(tok::TokenKind T1, CachedTokens &Toks,
                             bool StopAtSemi = true,
                             bool ConsumeFinalToken = true) {
     return ConsumeAndStoreUntil(T1, T1, Toks, StopAtSemi, ConsumeFinalToken);
   }
   bool ConsumeAndStoreUntil(tok::TokenKind T1, tok::TokenKind T2,
-                            CachedTokens &Toks,
-                            bool StopAtSemi = true,
+                            CachedTokens &Toks, bool StopAtSemi = true,
                             bool ConsumeFinalToken = true);
 
   //===--------------------------------------------------------------------===//
@@ -1580,18 +1563,19 @@ private:
                                           ParsingDeclSpec *DS = nullptr);
   bool isDeclarationAfterDeclarator();
   bool isStartOfFunctionDefinition(const ParsingDeclarator &Declarator);
-  DeclGroupPtrTy ParseDeclarationOrFunctionDefinition(
-                                                  ParsedAttributesWithRange &attrs,
-                                                  ParsingDeclSpec *DS = nullptr,
-                                                  AccessSpecifier AS = AS_none);
-  DeclGroupPtrTy ParseDeclOrFunctionDefInternal(ParsedAttributesWithRange &attrs,
-                                                ParsingDeclSpec &DS,
-                                                AccessSpecifier AS);
+  DeclGroupPtrTy
+  ParseDeclarationOrFunctionDefinition(ParsedAttributesWithRange &attrs,
+                                       ParsingDeclSpec *DS = nullptr,
+                                       AccessSpecifier AS = AS_none);
+  DeclGroupPtrTy
+  ParseDeclOrFunctionDefInternal(ParsedAttributesWithRange &attrs,
+                                 ParsingDeclSpec &DS, AccessSpecifier AS);
 
   void SkipFunctionBody();
-  Decl *ParseFunctionDefinition(ParsingDeclarator &D,
-                 const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo(),
-                 LateParsedAttrList *LateParsedAttrs = nullptr);
+  Decl *ParseFunctionDefinition(
+      ParsingDeclarator &D,
+      const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo(),
+      LateParsedAttrList *LateParsedAttrs = nullptr);
   void ParseKNRParamDeclarations(Declarator &D);
   // EndLoc is filled with the location of the last token of the simple-asm.
   ExprResult ParseSimpleAsm(bool ForAsmLabel, SourceLocation *EndLoc);
@@ -1610,48 +1594,38 @@ private:
       SmallVectorImpl<IdentifierLocPair> &protocolIdents,
       SourceLocation &rAngleLoc, bool mayBeProtocolList = true);
 
-  void HelperActionsForIvarDeclarations(Decl *interfaceDecl, SourceLocation atLoc,
+  void HelperActionsForIvarDeclarations(Decl *interfaceDecl,
+                                        SourceLocation atLoc,
                                         BalancedDelimiterTracker &T,
                                         SmallVectorImpl<Decl *> &AllIvarDecls,
                                         bool RBraceMissing);
   void ParseObjCClassInstanceVariables(Decl *interfaceDecl,
                                        tok::ObjCKeywordKind visibility,
                                        SourceLocation atLoc);
-  bool ParseObjCProtocolReferences(SmallVectorImpl<Decl *> &P,
-                                   SmallVectorImpl<SourceLocation> &PLocs,
-                                   bool WarnOnDeclarations,
-                                   bool ForObjCContainer,
-                                   SourceLocation &LAngleLoc,
-                                   SourceLocation &EndProtoLoc,
-                                   bool consumeLastToken);
+  bool ParseObjCProtocolReferences(
+      SmallVectorImpl<Decl *> &P, SmallVectorImpl<SourceLocation> &PLocs,
+      bool WarnOnDeclarations, bool ForObjCContainer, SourceLocation &LAngleLoc,
+      SourceLocation &EndProtoLoc, bool consumeLastToken);
 
   /// Parse the first angle-bracket-delimited clause for an
   /// Objective-C object or object pointer type, which may be either
   /// type arguments or protocol qualifiers.
   void parseObjCTypeArgsOrProtocolQualifiers(
-         ParsedType baseType,
-         SourceLocation &typeArgsLAngleLoc,
-         SmallVectorImpl<ParsedType> &typeArgs,
-         SourceLocation &typeArgsRAngleLoc,
-         SourceLocation &protocolLAngleLoc,
-         SmallVectorImpl<Decl *> &protocols,
-         SmallVectorImpl<SourceLocation> &protocolLocs,
-         SourceLocation &protocolRAngleLoc,
-         bool consumeLastToken,
-         bool warnOnIncompleteProtocols);
+      ParsedType baseType, SourceLocation &typeArgsLAngleLoc,
+      SmallVectorImpl<ParsedType> &typeArgs, SourceLocation &typeArgsRAngleLoc,
+      SourceLocation &protocolLAngleLoc, SmallVectorImpl<Decl *> &protocols,
+      SmallVectorImpl<SourceLocation> &protocolLocs,
+      SourceLocation &protocolRAngleLoc, bool consumeLastToken,
+      bool warnOnIncompleteProtocols);
 
   /// Parse either Objective-C type arguments or protocol qualifiers; if the
   /// former, also parse protocol qualifiers afterward.
   void parseObjCTypeArgsAndProtocolQualifiers(
-         ParsedType baseType,
-         SourceLocation &typeArgsLAngleLoc,
-         SmallVectorImpl<ParsedType> &typeArgs,
-         SourceLocation &typeArgsRAngleLoc,
-         SourceLocation &protocolLAngleLoc,
-         SmallVectorImpl<Decl *> &protocols,
-         SmallVectorImpl<SourceLocation> &protocolLocs,
-         SourceLocation &protocolRAngleLoc,
-         bool consumeLastToken);
+      ParsedType baseType, SourceLocation &typeArgsLAngleLoc,
+      SmallVectorImpl<ParsedType> &typeArgs, SourceLocation &typeArgsRAngleLoc,
+      SourceLocation &protocolLAngleLoc, SmallVectorImpl<Decl *> &protocols,
+      SmallVectorImpl<SourceLocation> &protocolLocs,
+      SourceLocation &protocolRAngleLoc, bool consumeLastToken);
 
   /// Parse a protocol qualifier type such as '<NSCopying>', which is
   /// an anachronistic way of writing 'id<NSCopying>'.
@@ -1664,8 +1638,7 @@ private:
                                                     bool consumeLastToken,
                                                     SourceLocation &endLoc);
 
-  void ParseObjCInterfaceDeclList(tok::ObjCKeywordKind contextKey,
-                                  Decl *CDecl);
+  void ParseObjCInterfaceDeclList(tok::ObjCKeywordKind contextKey, Decl *CDecl);
   DeclGroupPtrTy ParseObjCAtProtocolDeclaration(SourceLocation atLoc,
                                                 ParsedAttributes &prefixAttrs);
 
@@ -1673,11 +1646,11 @@ private:
     Parser &P;
     Decl *Dcl;
     bool HasCFunction;
-    typedef SmallVector<LexedMethod*, 8> LateParsedObjCMethodContainer;
+    typedef SmallVector<LexedMethod *, 8> LateParsedObjCMethodContainer;
     LateParsedObjCMethodContainer LateParsedObjCMethods;
 
     ObjCImplParsingDataRAII(Parser &parser, Decl *D)
-      : P(parser), Dcl(D), HasCFunction(false) {
+        : P(parser), Dcl(D), HasCFunction(false) {
       P.CurParsedObjCImpl = this;
       Finished = false;
     }
@@ -1702,8 +1675,15 @@ private:
   IdentifierInfo *ParseObjCSelectorPiece(SourceLocation &MethodLocation);
   // Definitions for Objective-c context sensitive keywords recognition.
   enum ObjCTypeQual {
-    objc_in=0, objc_out, objc_inout, objc_oneway, objc_bycopy, objc_byref,
-    objc_nonnull, objc_nullable, objc_null_unspecified,
+    objc_in = 0,
+    objc_out,
+    objc_inout,
+    objc_oneway,
+    objc_bycopy,
+    objc_byref,
+    objc_nonnull,
+    objc_nullable,
+    objc_null_unspecified,
     objc_NumQuals
   };
   IdentifierInfo *ObjCTypeQuals[objc_NumQuals];
@@ -1713,11 +1693,12 @@ private:
   ParsedType ParseObjCTypeName(ObjCDeclSpec &DS, DeclaratorContext Ctx,
                                ParsedAttributes *ParamAttrs);
   Decl *ParseObjCMethodPrototype(
-            tok::ObjCKeywordKind MethodImplKind = tok::objc_not_keyword,
-            bool MethodDefinition = true);
-  Decl *ParseObjCMethodDecl(SourceLocation mLoc, tok::TokenKind mType,
-            tok::ObjCKeywordKind MethodImplKind = tok::objc_not_keyword,
-            bool MethodDefinition=true);
+      tok::ObjCKeywordKind MethodImplKind = tok::objc_not_keyword,
+      bool MethodDefinition = true);
+  Decl *ParseObjCMethodDecl(
+      SourceLocation mLoc, tok::TokenKind mType,
+      tok::ObjCKeywordKind MethodImplKind = tok::objc_not_keyword,
+      bool MethodDefinition = true);
   void ParseObjCPropertyAttribute(ObjCDeclSpec &DS);
 
   Decl *ParseObjCMethodDefinition();
@@ -1727,11 +1708,7 @@ public:
   // C99 6.5: Expressions.
 
   /// TypeCastState - State whether an expression is or may be a type cast.
-  enum TypeCastState {
-    NotTypeCast = 0,
-    MaybeTypeCast,
-    IsTypeCast
-  };
+  enum TypeCastState { NotTypeCast = 0, MaybeTypeCast, IsTypeCast };
 
   ExprResult ParseExpression(TypeCastState isTypeCast = NotTypeCast);
   ExprResult ParseConstantExpressionInExprEvalContext(
@@ -1739,8 +1716,7 @@ public:
   ExprResult ParseConstantExpression(TypeCastState isTypeCast = NotTypeCast);
   ExprResult ParseCaseExpression(SourceLocation CaseLoc);
   ExprResult ParseConstraintExpression();
-  ExprResult
-  ParseConstraintLogicalAndExpression(bool IsTrailingRequiresClause);
+  ExprResult ParseConstraintLogicalAndExpression(bool IsTrailingRequiresClause);
   ExprResult ParseConstraintLogicalOrExpression(bool IsTrailingRequiresClause);
   // Expr that doesn't include commas.
   ExprResult ParseAssignmentExpression(TypeCastState isTypeCast = NotTypeCast);
@@ -1756,17 +1732,11 @@ private:
 
   ExprResult ParseExpressionWithLeadingExtension(SourceLocation ExtLoc);
 
-  ExprResult ParseRHSOfBinaryExpression(ExprResult LHS,
-                                        prec::Level MinPrec);
+  ExprResult ParseRHSOfBinaryExpression(ExprResult LHS, prec::Level MinPrec);
   /// Control what ParseCastExpression will parse.
-  enum CastParseKind {
-    AnyCastExpr = 0,
-    UnaryExprOnly,
-    PrimaryExprOnly
-  };
+  enum CastParseKind { AnyCastExpr = 0, UnaryExprOnly, PrimaryExprOnly };
   ExprResult ParseCastExpression(CastParseKind ParseKind,
-                                 bool isAddressOfOperand,
-                                 bool &NotCastExpr,
+                                 bool isAddressOfOperand, bool &NotCastExpr,
                                  TypeCastState isTypeCast,
                                  bool isVectorLiteral = false,
                                  bool *NotPrimaryExpression = nullptr);
@@ -1783,9 +1753,8 @@ private:
   /// suffix.
   bool isPostfixExpressionSuffixStart() {
     tok::TokenKind K = Tok.getKind();
-    return (K == tok::l_square || K == tok::l_paren ||
-            K == tok::period || K == tok::arrow ||
-            K == tok::plusplus || K == tok::minusminus);
+    return (K == tok::l_square || K == tok::l_paren || K == tok::period ||
+            K == tok::arrow || K == tok::plusplus || K == tok::minusminus);
   }
 
   bool diagnoseUnknownTemplateId(ExprResult TemplateName, SourceLocation Less);
@@ -1804,9 +1773,9 @@ private:
   ExprResult ParseSYCLUniqueStableNameExpression();
 
   ExprResult ParseExprAfterUnaryExprOrTypeTrait(const Token &OpTok,
-                                                     bool &isCastExpr,
-                                                     ParsedType &CastTy,
-                                                     SourceRange &CastRange);
+                                                bool &isCastExpr,
+                                                ParsedType &CastTy,
+                                                SourceRange &CastRange);
 
   typedef SmallVector<SourceLocation, 20> CommaLocsTy;
 
@@ -1818,10 +1787,9 @@ private:
 
   /// ParseSimpleExpressionList - A simple comma-separated list of expressions,
   /// used for misc language extensions.
-  bool ParseSimpleExpressionList(SmallVectorImpl<Expr*> &Exprs,
+  bool ParseSimpleExpressionList(SmallVectorImpl<Expr *> &Exprs,
                                  SmallVectorImpl<SourceLocation> &CommaLocs);
 
-
   /// ParenParseOption - Control what ParseParenExpression will parse.
   enum ParenParseOption {
     SimpleExpr,      // Only parse '(' expression ')'
@@ -1831,17 +1799,16 @@ private:
     CastExpr         // Also allow '(' type-name ')' <anything>
   };
   ExprResult ParseParenExpression(ParenParseOption &ExprType,
-                                        bool stopIfCastExpr,
-                                        bool isTypeCast,
-                                        ParsedType &CastTy,
-                                        SourceLocation &RParenLoc);
+                                  bool stopIfCastExpr, bool isTypeCast,
+                                  ParsedType &CastTy,
+                                  SourceLocation &RParenLoc);
 
   ExprResult ParseCXXAmbiguousParenExpression(
       ParenParseOption &ExprType, ParsedType &CastTy,
       BalancedDelimiterTracker &Tracker, ColonProtectionRAIIObject &ColonProt);
   ExprResult ParseCompoundLiteralExpression(ParsedType Ty,
-                                                  SourceLocation LParenLoc,
-                                                  SourceLocation RParenLoc);
+                                            SourceLocation LParenLoc,
+                                            SourceLocation RParenLoc);
 
   ExprResult ParseGenericSelectionExpression();
 
@@ -1861,15 +1828,11 @@ private:
                                   bool EnteringContext, IdentifierInfo &II,
                                   CXXScopeSpec &SS);
 
-  bool ParseOptionalCXXScopeSpecifier(CXXScopeSpec &SS,
-                                      ParsedType ObjectType,
-                                      bool ObjectHasErrors,
-                                      bool EnteringContext,
-                                      bool *MayBePseudoDestructor = nullptr,
-                                      bool IsTypename = false,
-                                      IdentifierInfo **LastII = nullptr,
-                                      bool OnlyNamespace = false,
-                                      bool InUsingDeclaration = false);
+  bool ParseOptionalCXXScopeSpecifier(
+      CXXScopeSpec &SS, ParsedType ObjectType, bool ObjectHasErrors,
+      bool EnteringContext, bool *MayBePseudoDestructor = nullptr,
+      bool IsTypename = false, IdentifierInfo **LastII = nullptr,
+      bool OnlyNamespace = false, bool InUsingDeclaration = false);
 
   //===--------------------------------------------------------------------===//
   // C++11 5.1.2: Lambda expressions
@@ -1914,9 +1877,8 @@ private:
   //===--------------------------------------------------------------------===//
   // C++ 5.2.4: C++ Pseudo-Destructor Expressions
   ExprResult ParseCXXPseudoDestructor(Expr *Base, SourceLocation OpLoc,
-                                            tok::TokenKind OpKind,
-                                            CXXScopeSpec &SS,
-                                            ParsedType ObjectType);
+                                      tok::TokenKind OpKind, CXXScopeSpec &SS,
+                                      ParsedType ObjectType);
 
   //===--------------------------------------------------------------------===//
   // C++ 9.3.2: C++ 'this' pointer
@@ -1927,18 +1889,16 @@ private:
   ExprResult ParseThrowExpression();
 
   ExceptionSpecificationType tryParseExceptionSpecification(
-                    bool Delayed,
-                    SourceRange &SpecificationRange,
-                    SmallVectorImpl<ParsedType> &DynamicExceptions,
-                    SmallVectorImpl<SourceRange> &DynamicExceptionRanges,
-                    ExprResult &NoexceptExpr,
-                    CachedTokens *&ExceptionSpecTokens);
+      bool Delayed, SourceRange &SpecificationRange,
+      SmallVectorImpl<ParsedType> &DynamicExceptions,
+      SmallVectorImpl<SourceRange> &DynamicExceptionRanges,
+      ExprResult &NoexceptExpr, CachedTokens *&ExceptionSpecTokens);
 
   // EndLoc is filled with the location of the last token of the specification.
-  ExceptionSpecificationType ParseDynamicExceptionSpecification(
-                                  SourceRange &SpecificationRange,
-                                  SmallVectorImpl<ParsedType> &Exceptions,
-                                  SmallVectorImpl<SourceRange> &Ranges);
+  ExceptionSpecificationType
+  ParseDynamicExceptionSpecification(SourceRange &SpecificationRange,
+                                     SmallVectorImpl<ParsedType> &Exceptions,
+                                     SmallVectorImpl<SourceRange> &Ranges);
 
   //===--------------------------------------------------------------------===//
   // C++0x 8: Function declaration trailing-return-type
@@ -1962,12 +1922,11 @@ private:
 
   //===--------------------------------------------------------------------===//
   // C++ 5.3.4 and 5.3.5: C++ new and delete
-  bool ParseExpressionListOrTypeId(SmallVectorImpl<Expr*> &Exprs,
+  bool ParseExpressionListOrTypeId(SmallVectorImpl<Expr *> &Exprs,
                                    Declarator &D);
   void ParseDirectNewDeclarator(Declarator &D);
   ExprResult ParseCXXNewExpression(bool UseGlobal, SourceLocation Start);
-  ExprResult ParseCXXDeleteExpression(bool UseGlobal,
-                                            SourceLocation Start);
+  ExprResult ParseCXXDeleteExpression(bool UseGlobal, SourceLocation Start);
 
   //===--------------------------------------------------------------------===//
   // C++ if/switch/while/for condition expression.
@@ -2016,7 +1975,7 @@ private:
   //===--------------------------------------------------------------------===//
   // clang Expressions
 
-  ExprResult ParseBlockLiteralExpression();  // ^{...}
+  ExprResult ParseBlockLiteralExpression(); // ^{...}
 
   //===--------------------------------------------------------------------===//
   // Objective-C Expressions
@@ -2038,8 +1997,8 @@ private:
                                             ParsedType ReceiverType,
                                             Expr *ReceiverExpr);
   ExprResult ParseAssignmentExprWithObjCMessageExprStart(
-      SourceLocation LBracloc, SourceLocation SuperLoc,
-      ParsedType ReceiverType, Expr *ReceiverExpr);
+      SourceLocation LBracloc, SourceLocation SuperLoc, ParsedType ReceiverType,
+      Expr *ReceiverExpr);
   bool ParseObjCXXMessageReceiver(bool &IsExpr, void *&TypeOrExpr);
 
   //===--------------------------------------------------------------------===//
@@ -2047,23 +2006,21 @@ private:
 
   /// A SmallVector of statements, with stack size 32 (as that is the only one
   /// used.)
-  typedef SmallVector<Stmt*, 32> StmtVector;
+  typedef SmallVector<Stmt *, 32> StmtVector;
   /// A SmallVector of expressions, with stack size 12 (the maximum used.)
-  typedef SmallVector<Expr*, 12> ExprVector;
+  typedef SmallVector<Expr *, 12> ExprVector;
   /// A SmallVector of types.
   typedef SmallVector<ParsedType, 12> TypeVector;
 
   StmtResult
   ParseStatement(SourceLocation *TrailingElseLoc = nullptr,
                  ParsedStmtContext StmtCtx = ParsedStmtContext::SubStmt);
-  StmtResult ParseStatementOrDeclaration(
-      StmtVector &Stmts, ParsedStmtContext StmtCtx,
-      SourceLocation *TrailingElseLoc = nullptr);
+  StmtResult
+  ParseStatementOrDeclaration(StmtVector &Stmts, ParsedStmtContext StmtCtx,
+                              SourceLocation *TrailingElseLoc = nullptr);
   StmtResult ParseStatementOrDeclarationAfterAttributes(
-                                         StmtVector &Stmts,
-                                         ParsedStmtContext StmtCtx,
-                                         SourceLocation *TrailingElseLoc,
-                                         ParsedAttributesWithRange &Attrs);
+      StmtVector &Stmts, ParsedStmtContext StmtCtx,
+      SourceLocation *TrailingElseLoc, ParsedAttributesWithRange &Attrs);
   StmtResult ParseExprStatement(ParsedStmtContext StmtCtx);
   StmtResult ParseLabeledStatement(ParsedAttributesWithRange &attrs,
                                    ParsedStmtContext StmtCtx);
@@ -2072,8 +2029,7 @@ private:
                                 ExprResult Expr = ExprResult());
   StmtResult ParseDefaultStatement(ParsedStmtContext StmtCtx);
   StmtResult ParseCompoundStatement(bool isStmtExpr = false);
-  StmtResult ParseCompoundStatement(bool isStmtExpr,
-                                    unsigned ScopeFlags);
+  StmtResult ParseCompoundStatement(bool isStmtExpr, unsigned ScopeFlags);
   void ParseCompoundStatementLeadingPragmas();
   bool ConsumeNullStmt(StmtVector &Stmts);
   StmtResult ParseCompoundStatementBody(bool isStmtExpr = false);
@@ -2093,8 +2049,7 @@ private:
   StmtResult ParseReturnStatement();
   StmtResult ParseAsmStatement(bool &msAsm);
   StmtResult ParseMicrosoftAsmStatement(SourceLocation AsmLoc);
-  StmtResult ParsePragmaLoopHint(StmtVector &Stmts,
-                                 ParsedStmtContext StmtCtx,
+  StmtResult ParsePragmaLoopHint(StmtVector &Stmts, ParsedStmtContext StmtCtx,
                                  SourceLocation *TrailingElseLoc,
                                  ParsedAttributesWithRange &Attrs);
 
@@ -2130,7 +2085,12 @@ private:
     IfExistsBehavior Behavior;
   };
 
-  bool ParseMicrosoftIfExistsCondition(IfExistsCondition& Result);
+  // Modified By Zeng-WCh
+  StmtResult HandlePragmaLoopBound(StmtVector &stmts, ParsedStmtContext StmtCtx,
+                                   SourceLocation *TrailingElseLoc);
+  // End Modification
+
+  bool ParseMicrosoftIfExistsCondition(IfExistsCondition &Result);
   void ParseMicrosoftIfExistsStatement(StmtVector &Stmts);
   void ParseMicrosoftIfExistsExternalDeclaration();
   void ParseMicrosoftIfExistsClassDeclaration(DeclSpec::TST TagType,
@@ -2167,7 +2127,6 @@ private:
   StmtResult ParseObjCSynchronizedStmt(SourceLocation atLoc);
   StmtResult ParseObjCAutoreleasePoolStmt(SourceLocation atLoc);
 
-
   //===--------------------------------------------------------------------===//
   // C99 6.7: Declarations.
 
@@ -2175,16 +2134,17 @@ private:
   /// out, there are other significant restrictions on specifiers than
   /// would be best implemented in the parser.
   enum class DeclSpecContext {
-    DSC_normal, // normal context
-    DSC_class,  // class context, enables 'friend'
+    DSC_normal,         // normal context
+    DSC_class,          // class context, enables 'friend'
     DSC_type_specifier, // C++ type-specifier-seq or C specifier-qualifier-list
     DSC_trailing, // C++11 trailing-type-specifier in a trailing return type
-    DSC_alias_declaration, // C++11 type-specifier-seq in an alias-declaration
-    DSC_top_level, // top-level/namespace declaration context
-    DSC_template_param, // template parameter context
-    DSC_template_type_arg, // template type argument context
-    DSC_objc_method_result, // ObjC method result context, enables 'instancetype'
-    DSC_condition // condition declaration context
+    DSC_alias_declaration,  // C++11 type-specifier-seq in an alias-declaration
+    DSC_top_level,          // top-level/namespace declaration context
+    DSC_template_param,     // template parameter context
+    DSC_template_type_arg,  // template type argument context
+    DSC_objc_method_result, // ObjC method result context, enables
+                            // 'instancetype'
+    DSC_condition           // condition declaration context
   };
 
   /// Is this a context in which we are parsing just a type-specifier (or
@@ -2316,8 +2276,9 @@ private:
   DeclGroupPtrTy ParseDeclGroup(ParsingDeclSpec &DS, DeclaratorContext Context,
                                 SourceLocation *DeclEnd = nullptr,
                                 ForRangeInit *FRI = nullptr);
-  Decl *ParseDeclarationAfterDeclarator(Declarator &D,
-               const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo());
+  Decl *ParseDeclarationAfterDeclarator(
+      Declarator &D,
+      const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo());
   bool ParseAsmAttributesAfterDeclarator(Declarator &D);
   Decl *ParseDeclarationAfterDeclaratorAndAttributes(
       Declarator &D,
@@ -2352,8 +2313,7 @@ private:
       DeclSpec &DS, AccessSpecifier AS = AS_none,
       DeclSpecContext DSC = DeclSpecContext::DSC_normal);
 
-  void ParseObjCTypeQualifierList(ObjCDeclSpec &DS,
-                                  DeclaratorContext Context);
+  void ParseObjCTypeQualifierList(ObjCDeclSpec &DS, DeclaratorContext Context);
 
   void ParseEnumSpecifier(SourceLocation TagLoc, DeclSpec &DS,
                           const ParsedTemplateInfo &TemplateInfo,
@@ -2425,7 +2385,6 @@ private:
     TypeIdAsTemplateArgument
   };
 
-
   /// isTypeIdInParens - Assumes that a '(' was parsed and now we want to know
   /// whether the parens contain an expression or a type-id.
   /// Returns true for a type-id and false for an expression.
@@ -2494,9 +2453,7 @@ private:
 
   /// TPResult - Used as the result value for functions whose purpose is to
   /// disambiguate C++ constructs by "tentatively parsing" them.
-  enum class TPResult {
-    True, False, Ambiguous, Error
-  };
+  enum class TPResult { True, False, Ambiguous, Error };
 
   /// Determine whether we could have an enum-base.
   ///
@@ -2961,9 +2918,10 @@ private:
     CXXScopeSpec &SS;
     bool EnteredScope;
     bool CreatedScope;
+
   public:
     DeclaratorScopeObj(Parser &p, CXXScopeSpec &ss)
-      : P(p), SS(ss), EnteredScope(false), CreatedScope(false) {}
+        : P(p), SS(ss), EnteredScope(false), CreatedScope(false) {}
 
     void EnterDeclaratorScope() {
       assert(!EnteredScope && "Already entered the scope!");
@@ -2989,7 +2947,7 @@ private:
   /// ParseDeclarator - Parse and verify a newly-initialized declarator.
   void ParseDeclarator(Declarator &D);
   /// A function that parses a variant of direct-declarator.
-  typedef void (Parser::*DirectDeclParseFunction)(Declarator&);
+  typedef void (Parser::*DirectDeclParseFunction)(Declarator &);
   void ParseDeclaratorInternal(Declarator &D,
                                DirectDeclParseFunction DirectDeclParser);
 
@@ -2999,11 +2957,10 @@ private:
     AR_GNUAttributesParsed = 1 << 1,
     AR_CXX11AttributesParsed = 1 << 2,
     AR_DeclspecAttributesParsed = 1 << 3,
-    AR_AllAttributesParsed = AR_GNUAttributesParsed |
-                             AR_CXX11AttributesParsed |
+    AR_AllAttributesParsed = AR_GNUAttributesParsed | AR_CXX11AttributesParsed |
                              AR_DeclspecAttributesParsed,
-    AR_VendorAttributesParsed = AR_GNUAttributesParsed |
-                                AR_DeclspecAttributesParsed
+    AR_VendorAttributesParsed =
+        AR_GNUAttributesParsed | AR_DeclspecAttributesParsed
   };
 
   void ParseTypeQualifierListOpt(
@@ -3013,11 +2970,9 @@ private:
   void ParseDirectDeclarator(Declarator &D);
   void ParseDecompositionDeclarator(Declarator &D);
   void ParseParenDeclarator(Declarator &D);
-  void ParseFunctionDeclarator(Declarator &D,
-                               ParsedAttributes &attrs,
+  void ParseFunctionDeclarator(Declarator &D, ParsedAttributes &attrs,
                                BalancedDelimiterTracker &Tracker,
-                               bool IsAmbiguous,
-                               bool RequiresArg = false);
+                               bool IsAmbiguous, bool RequiresArg = false);
   void InitCXXThisScopeForDeclaratorIfRelevant(
       const Declarator &D, const DeclSpec &DS,
       llvm::Optional<Sema::CXXThisScopeRAII> &ThisScope);
@@ -3025,13 +2980,11 @@ private:
                          SourceLocation &RefQualifierLoc);
   bool isFunctionDeclaratorIdentifierList();
   void ParseFunctionDeclaratorIdentifierList(
-         Declarator &D,
-         SmallVectorImpl<DeclaratorChunk::ParamInfo> &ParamInfo);
+      Declarator &D, SmallVectorImpl<DeclaratorChunk::ParamInfo> &ParamInfo);
   void ParseParameterDeclarationClause(
-         DeclaratorContext DeclaratorContext,
-         ParsedAttributes &attrs,
-         SmallVectorImpl<DeclaratorChunk::ParamInfo> &ParamInfo,
-         SourceLocation &EllipsisLoc);
+      DeclaratorContext DeclaratorContext, ParsedAttributes &attrs,
+      SmallVectorImpl<DeclaratorChunk::ParamInfo> &ParamInfo,
+      SourceLocation &EllipsisLoc);
   void ParseBracketDeclarator(Declarator &D);
   void ParseMisplacedBracketDeclarator(Declarator &D);
 
@@ -3075,10 +3028,8 @@ private:
   DeclGroupPtrTy ParseUsingDirectiveOrDeclaration(
       DeclaratorContext Context, const ParsedTemplateInfo &TemplateInfo,
       SourceLocation &DeclEnd, ParsedAttributesWithRange &attrs);
-  Decl *ParseUsingDirective(DeclaratorContext Context,
-                            SourceLocation UsingLoc,
-                            SourceLocation &DeclEnd,
-                            ParsedAttributes &attrs);
+  Decl *ParseUsingDirective(DeclaratorContext Context, SourceLocation UsingLoc,
+                            SourceLocation &DeclEnd, ParsedAttributes &attrs);
 
   struct UsingDeclarator {
     SourceLocation TypenameLoc;
@@ -3119,23 +3070,21 @@ private:
                            DeclSpecContext DSC,
                            ParsedAttributesWithRange &Attributes);
   void SkipCXXMemberSpecification(SourceLocation StartLoc,
-                                  SourceLocation AttrFixitLoc,
-                                  unsigned TagType,
+                                  SourceLocation AttrFixitLoc, unsigned TagType,
                                   Decl *TagDecl);
   void ParseCXXMemberSpecification(SourceLocation StartLoc,
                                    SourceLocation AttrFixitLoc,
                                    ParsedAttributesWithRange &Attrs,
-                                   unsigned TagType,
-                                   Decl *TagDecl);
+                                   unsigned TagType, Decl *TagDecl);
   ExprResult ParseCXXMemberInitializer(Decl *D, bool IsFunction,
                                        SourceLocation &EqualLoc);
-  bool
-  ParseCXXMemberDeclaratorBeforeInitializer(Declarator &DeclaratorInfo,
-                                            VirtSpecifiers &VS,
-                                            ExprResult &BitfieldSize,
-                                            LateParsedAttrList &LateAttrs);
-  void MaybeParseAndDiagnoseDeclSpecAfterCXX11VirtSpecifierSeq(Declarator &D,
-                                                               VirtSpecifiers &VS);
+  bool ParseCXXMemberDeclaratorBeforeInitializer(Declarator &DeclaratorInfo,
+                                                 VirtSpecifiers &VS,
+                                                 ExprResult &BitfieldSize,
+                                                 LateParsedAttrList &LateAttrs);
+  void
+  MaybeParseAndDiagnoseDeclSpecAfterCXX11VirtSpecifierSeq(Declarator &D,
+                                                          VirtSpecifiers &VS);
   DeclGroupPtrTy ParseCXXClassMemberDeclaration(
       AccessSpecifier AS, ParsedAttributes &Attr,
       const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo(),
@@ -3145,7 +3094,7 @@ private:
       DeclSpec::TST TagType, Decl *Tag);
   void ParseConstructorInitializer(Decl *ConstructorDecl);
   MemInitResult ParseMemInitializer(Decl *ConstructorDecl);
-  void HandleMemberFunctionDeclDelays(Declarator& DeclaratorInfo,
+  void HandleMemberFunctionDeclDelays(Declarator &DeclaratorInfo,
                                       Decl *ThisDecl);
 
   //===--------------------------------------------------------------------===//
@@ -3156,18 +3105,15 @@ private:
   BaseResult ParseBaseSpecifier(Decl *ClassDecl);
   AccessSpecifier getAccessSpecifierIfPresent() const;
 
-  bool ParseUnqualifiedIdTemplateId(CXXScopeSpec &SS,
-                                    ParsedType ObjectType,
+  bool ParseUnqualifiedIdTemplateId(CXXScopeSpec &SS, ParsedType ObjectType,
                                     bool ObjectHadErrors,
                                     SourceLocation TemplateKWLoc,
                                     IdentifierInfo *Name,
                                     SourceLocation NameLoc,
-                                    bool EnteringContext,
-                                    UnqualifiedId &Id,
+                                    bool EnteringContext, UnqualifiedId &Id,
                                     bool AssumeTemplateId);
   bool ParseUnqualifiedIdOperator(CXXScopeSpec &SS, bool EnteringContext,
-                                  ParsedType ObjectType,
-                                  UnqualifiedId &Result);
+                                  ParsedType ObjectType, UnqualifiedId &Result);
 
   //===--------------------------------------------------------------------===//
   // OpenMP: Directives and clauses.
@@ -3248,8 +3194,7 @@ private:
   void parseOMPEndDirective(OpenMPDirectiveKind BeginKind,
                             OpenMPDirectiveKind ExpectedKind,
                             OpenMPDirectiveKind FoundKind,
-                            SourceLocation MatchingLoc,
-                            SourceLocation FoundLoc,
+                            SourceLocation MatchingLoc, SourceLocation FoundLoc,
                             bool SkipUntilOpenMPEnd);
 
   /// Parses declarative OpenMP directives.
@@ -3283,8 +3228,8 @@ private:
   ///
   bool ParseOpenMPSimpleVarList(
       OpenMPDirectiveKind Kind,
-      const llvm::function_ref<void(CXXScopeSpec &, DeclarationNameInfo)> &
-          Callback,
+      const llvm::function_ref<void(CXXScopeSpec &, DeclarationNameInfo)>
+          &Callback,
       bool AllowScopeSpecifier);
   /// Parses declarative or executable directive.
   ///
@@ -3306,8 +3251,7 @@ private:
   /// \param ParseOnly true to skip the clause's semantic actions and return
   /// nullptr.
   ///
-  OMPClause *ParseOpenMPSingleExprClause(OpenMPClauseKind Kind,
-                                         bool ParseOnly);
+  OMPClause *ParseOpenMPSingleExprClause(OpenMPClauseKind Kind, bool ParseOnly);
   /// Parses simple clause of a kind \a Kind.
   ///
   /// \param Kind Kind of current clause.
@@ -3386,9 +3330,9 @@ public:
     int ExtraModifier = -1; ///< Additional modifier for linear, map, depend or
                             ///< lastprivate clause.
     SmallVector<OpenMPMapModifierKind, NumberOfOMPMapClauseModifiers>
-    MapTypeModifiers;
+        MapTypeModifiers;
     SmallVector<SourceLocation, NumberOfOMPMapClauseModifiers>
-    MapTypeModifiersLoc;
+        MapTypeModifiersLoc;
     SmallVector<OpenMPMotionModifierKind, NumberOfOMPMotionModifiers>
         MotionModifiers;
     SmallVector<SourceLocation, NumberOfOMPMotionModifiers> MotionModifiersLoc;
@@ -3435,7 +3379,7 @@ private:
                                SourceLocation &LAngleLoc,
                                SourceLocation &RAngleLoc);
   bool ParseTemplateParameterList(unsigned Depth,
-                                  SmallVectorImpl<NamedDecl*> &TemplateParams);
+                                  SmallVectorImpl<NamedDecl *> &TemplateParams);
   TPResult isStartOfTemplateTypeParameter();
   NamedDecl *ParseTemplateParameter(unsigned Depth, unsigned Position);
   NamedDecl *ParseTypeParameter(unsigned Depth, unsigned Position);
@@ -3463,8 +3407,7 @@ private:
                                         TemplateTy NameHint = nullptr);
 
   bool AnnotateTemplateIdToken(TemplateTy Template, TemplateNameKind TNK,
-                               CXXScopeSpec &SS,
-                               SourceLocation TemplateKWLoc,
+                               CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
                                UnqualifiedId &TemplateName,
                                bool AllowTypeAnnotation = true,
                                bool TypeConstraint = false);
@@ -3481,9 +3424,8 @@ private:
                                    ParsedAttributes &AccessAttrs,
                                    AccessSpecifier AS = AS_none);
   // C++2a: Template, concept definition [temp]
-  Decl *
-  ParseConceptDefinition(const ParsedTemplateInfo &TemplateInfo,
-                         SourceLocation &DeclEnd);
+  Decl *ParseConceptDefinition(const ParsedTemplateInfo &TemplateInfo,
+                               SourceLocation &DeclEnd);
 
   //===--------------------------------------------------------------------===//
   // Modules
@@ -3529,9 +3471,9 @@ private:
   public:
     enum AQ {
       AQ_unspecified = 0,
-      AQ_volatile    = 1,
-      AQ_inline      = 2,
-      AQ_goto        = 4,
+      AQ_volatile = 1,
+      AQ_inline = 2,
+      AQ_goto = 4,
     };
     static const char *getQualifierName(AQ Qualifier);
     bool setAsmQualifier(AQ Qualifier);
@@ -3545,6 +3487,6 @@ private:
   bool parseGNUAsmQualifierListOpt(GNUAsmQualifiers &AQ);
 };
 
-}  // end namespace clang
+} // end namespace clang
 
 #endif
diff --color -uprN clang-14.0.6.src/include/clang/Sema/Ownership.h clang-14.0.6.src.patched/include/clang/Sema/Ownership.h
--- clang-14.0.6.src/include/clang/Sema/Ownership.h	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/include/clang/Sema/Ownership.h	2024-11-12 13:24:23.346651843 +0800
@@ -38,101 +38,95 @@ class Stmt;
 class TemplateName;
 class TemplateParameterList;
 
-  /// Wrapper for void* pointer.
-  /// \tparam PtrTy Either a pointer type like 'T*' or a type that behaves like
-  ///               a pointer.
+/// Wrapper for void* pointer.
+/// \tparam PtrTy Either a pointer type like 'T*' or a type that behaves like
+///               a pointer.
+///
+/// This is a very simple POD type that wraps a pointer that the Parser
+/// doesn't know about but that Sema or another client does.  The PtrTy
+/// template argument is used to make sure that "Decl" pointers are not
+/// compatible with "Type" pointers for example.
+template <class PtrTy> class OpaquePtr {
+  void *Ptr = nullptr;
+
+  explicit OpaquePtr(void *Ptr) : Ptr(Ptr) {}
+
+  using Traits = llvm::PointerLikeTypeTraits<PtrTy>;
+
+public:
+  OpaquePtr(std::nullptr_t = nullptr) {}
+
+  static OpaquePtr make(PtrTy P) {
+    OpaquePtr OP;
+    OP.set(P);
+    return OP;
+  }
+
+  /// Returns plain pointer to the entity pointed by this wrapper.
+  /// \tparam PointeeT Type of pointed entity.
+  ///
+  /// It is identical to getPtrAs<PointeeT*>.
+  template <typename PointeeT> PointeeT *getPtrTo() const { return get(); }
+
+  /// Returns pointer converted to the specified type.
+  /// \tparam PtrT Result pointer type.  There must be implicit conversion
+  ///              from PtrTy to PtrT.
   ///
-  /// This is a very simple POD type that wraps a pointer that the Parser
-  /// doesn't know about but that Sema or another client does.  The PtrTy
-  /// template argument is used to make sure that "Decl" pointers are not
-  /// compatible with "Type" pointers for example.
-  template <class PtrTy>
-  class OpaquePtr {
-    void *Ptr = nullptr;
-
-    explicit OpaquePtr(void *Ptr) : Ptr(Ptr) {}
-
-    using Traits = llvm::PointerLikeTypeTraits<PtrTy>;
-
-  public:
-    OpaquePtr(std::nullptr_t = nullptr) {}
-
-    static OpaquePtr make(PtrTy P) { OpaquePtr OP; OP.set(P); return OP; }
-
-    /// Returns plain pointer to the entity pointed by this wrapper.
-    /// \tparam PointeeT Type of pointed entity.
-    ///
-    /// It is identical to getPtrAs<PointeeT*>.
-    template <typename PointeeT> PointeeT* getPtrTo() const {
-      return get();
-    }
-
-    /// Returns pointer converted to the specified type.
-    /// \tparam PtrT Result pointer type.  There must be implicit conversion
-    ///              from PtrTy to PtrT.
-    ///
-    /// In contrast to getPtrTo, this method allows the return type to be
-    /// a smart pointer.
-    template <typename PtrT> PtrT getPtrAs() const {
-      return get();
-    }
-
-    PtrTy get() const {
-      return Traits::getFromVoidPointer(Ptr);
-    }
-
-    void set(PtrTy P) {
-      Ptr = Traits::getAsVoidPointer(P);
-    }
-
-    explicit operator bool() const { return Ptr != nullptr; }
-
-    void *getAsOpaquePtr() const { return Ptr; }
-    static OpaquePtr getFromOpaquePtr(void *P) { return OpaquePtr(P); }
-  };
-
-  /// UnionOpaquePtr - A version of OpaquePtr suitable for membership
-  /// in a union.
-  template <class T> struct UnionOpaquePtr {
-    void *Ptr;
-
-    static UnionOpaquePtr make(OpaquePtr<T> P) {
-      UnionOpaquePtr OP = { P.getAsOpaquePtr() };
-      return OP;
-    }
-
-    OpaquePtr<T> get() const { return OpaquePtr<T>::getFromOpaquePtr(Ptr); }
-    operator OpaquePtr<T>() const { return get(); }
-
-    UnionOpaquePtr &operator=(OpaquePtr<T> P) {
-      Ptr = P.getAsOpaquePtr();
-      return *this;
-    }
-  };
+  /// In contrast to getPtrTo, this method allows the return type to be
+  /// a smart pointer.
+  template <typename PtrT> PtrT getPtrAs() const { return get(); }
+
+  PtrTy get() const { return Traits::getFromVoidPointer(Ptr); }
+
+  void set(PtrTy P) { Ptr = Traits::getAsVoidPointer(P); }
+
+  explicit operator bool() const { return Ptr != nullptr; }
+
+  void *getAsOpaquePtr() const { return Ptr; }
+  static OpaquePtr getFromOpaquePtr(void *P) { return OpaquePtr(P); }
+};
+
+/// UnionOpaquePtr - A version of OpaquePtr suitable for membership
+/// in a union.
+template <class T> struct UnionOpaquePtr {
+  void *Ptr;
+
+  static UnionOpaquePtr make(OpaquePtr<T> P) {
+    UnionOpaquePtr OP = {P.getAsOpaquePtr()};
+    return OP;
+  }
+
+  OpaquePtr<T> get() const { return OpaquePtr<T>::getFromOpaquePtr(Ptr); }
+  operator OpaquePtr<T>() const { return get(); }
+
+  UnionOpaquePtr &operator=(OpaquePtr<T> P) {
+    Ptr = P.getAsOpaquePtr();
+    return *this;
+  }
+};
 
 } // namespace clang
 
 namespace llvm {
 
-  template <class T>
-  struct PointerLikeTypeTraits<clang::OpaquePtr<T>> {
-    static constexpr int NumLowBitsAvailable = 0;
-
-    static inline void *getAsVoidPointer(clang::OpaquePtr<T> P) {
-      // FIXME: Doesn't work? return P.getAs< void >();
-      return P.getAsOpaquePtr();
-    }
-
-    static inline clang::OpaquePtr<T> getFromVoidPointer(void *P) {
-      return clang::OpaquePtr<T>::getFromOpaquePtr(P);
-    }
-  };
+template <class T> struct PointerLikeTypeTraits<clang::OpaquePtr<T>> {
+  static constexpr int NumLowBitsAvailable = 0;
+
+  static inline void *getAsVoidPointer(clang::OpaquePtr<T> P) {
+    // FIXME: Doesn't work? return P.getAs< void >();
+    return P.getAsOpaquePtr();
+  }
+
+  static inline clang::OpaquePtr<T> getFromVoidPointer(void *P) {
+    return clang::OpaquePtr<T>::getFromOpaquePtr(P);
+  }
+};
 
 } // namespace llvm
 
 namespace clang {
 
-  // Basic
+// Basic
 class StreamingDiagnostic;
 
 // Determines whether the low bit of the result pointer for the
@@ -140,165 +134,160 @@ class StreamingDiagnostic;
 // for it's "invalid" flag.
 template <class Ptr> struct IsResultPtrLowBitFree {
   static const bool value = false;
-  };
+};
+
+/// ActionResult - This structure is used while parsing/acting on
+/// expressions, stmts, etc.  It encapsulates both the object returned by
+/// the action, plus a sense of whether or not it is valid.
+/// When CompressInvalid is true, the "invalid" flag will be
+/// stored in the low bit of the Val pointer.
+template <class PtrTy,
+          bool CompressInvalid = IsResultPtrLowBitFree<PtrTy>::value>
+class ActionResult {
+  PtrTy Val;
+  bool Invalid;
+
+public:
+  ActionResult(bool Invalid = false) : Val(PtrTy()), Invalid(Invalid) {}
+  ActionResult(PtrTy val) : Val(val), Invalid(false) {}
+  ActionResult(const DiagnosticBuilder &) : Val(PtrTy()), Invalid(true) {}
+
+  // These two overloads prevent void* -> bool conversions.
+  ActionResult(const void *) = delete;
+  ActionResult(volatile void *) = delete;
+
+  bool isInvalid() const { return Invalid; }
+  bool isUsable() const { return !Invalid && Val; }
+  bool isUnset() const { return !Invalid && !Val; }
+
+  PtrTy get() const { return Val; }
+  template <typename T> T *getAs() { return static_cast<T *>(get()); }
+
+  void set(PtrTy V) { Val = V; }
+
+  const ActionResult &operator=(PtrTy RHS) {
+    Val = RHS;
+    Invalid = false;
+    return *this;
+  }
+};
 
-  /// ActionResult - This structure is used while parsing/acting on
-  /// expressions, stmts, etc.  It encapsulates both the object returned by
-  /// the action, plus a sense of whether or not it is valid.
-  /// When CompressInvalid is true, the "invalid" flag will be
-  /// stored in the low bit of the Val pointer.
-  template<class PtrTy,
-           bool CompressInvalid = IsResultPtrLowBitFree<PtrTy>::value>
-  class ActionResult {
-    PtrTy Val;
-    bool Invalid;
-
-  public:
-    ActionResult(bool Invalid = false) : Val(PtrTy()), Invalid(Invalid) {}
-    ActionResult(PtrTy val) : Val(val), Invalid(false) {}
-    ActionResult(const DiagnosticBuilder &) : Val(PtrTy()), Invalid(true) {}
-
-    // These two overloads prevent void* -> bool conversions.
-    ActionResult(const void *) = delete;
-    ActionResult(volatile void *) = delete;
-
-    bool isInvalid() const { return Invalid; }
-    bool isUsable() const { return !Invalid && Val; }
-    bool isUnset() const { return !Invalid && !Val; }
-
-    PtrTy get() const { return Val; }
-    template <typename T> T *getAs() { return static_cast<T*>(get()); }
-
-    void set(PtrTy V) { Val = V; }
-
-    const ActionResult &operator=(PtrTy RHS) {
-      Val = RHS;
-      Invalid = false;
-      return *this;
-    }
-  };
-
-  // This ActionResult partial specialization places the "invalid"
-  // flag into the low bit of the pointer.
-  template<typename PtrTy>
-  class ActionResult<PtrTy, true> {
-    // A pointer whose low bit is 1 if this result is invalid, 0
-    // otherwise.
-    uintptr_t PtrWithInvalid;
-
-    using PtrTraits = llvm::PointerLikeTypeTraits<PtrTy>;
-
-  public:
-    ActionResult(bool Invalid = false)
-        : PtrWithInvalid(static_cast<uintptr_t>(Invalid)) {}
-
-    ActionResult(PtrTy V) {
-      void *VP = PtrTraits::getAsVoidPointer(V);
-      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);
-      assert((PtrWithInvalid & 0x01) == 0 && "Badly aligned pointer");
-    }
-
-    ActionResult(const DiagnosticBuilder &) : PtrWithInvalid(0x01) {}
-
-    // These two overloads prevent void* -> bool conversions.
-    ActionResult(const void *) = delete;
-    ActionResult(volatile void *) = delete;
-
-    bool isInvalid() const { return PtrWithInvalid & 0x01; }
-    bool isUsable() const { return PtrWithInvalid > 0x01; }
-    bool isUnset() const { return PtrWithInvalid == 0; }
-
-    PtrTy get() const {
-      void *VP = reinterpret_cast<void *>(PtrWithInvalid & ~0x01);
-      return PtrTraits::getFromVoidPointer(VP);
-    }
-
-    template <typename T> T *getAs() { return static_cast<T*>(get()); }
-
-    void set(PtrTy V) {
-      void *VP = PtrTraits::getAsVoidPointer(V);
-      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);
-      assert((PtrWithInvalid & 0x01) == 0 && "Badly aligned pointer");
-    }
-
-    const ActionResult &operator=(PtrTy RHS) {
-      void *VP = PtrTraits::getAsVoidPointer(RHS);
-      PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);
-      assert((PtrWithInvalid & 0x01) == 0 && "Badly aligned pointer");
-      return *this;
-    }
-
-    // For types where we can fit a flag in with the pointer, provide
-    // conversions to/from pointer type.
-    static ActionResult getFromOpaquePointer(void *P) {
-      ActionResult Result;
-      Result.PtrWithInvalid = (uintptr_t)P;
-      return Result;
-    }
-    void *getAsOpaquePointer() const { return (void*)PtrWithInvalid; }
-  };
-
-  /// An opaque type for threading parsed type information through the
-  /// parser.
-  using ParsedType = OpaquePtr<QualType>;
-  using UnionParsedType = UnionOpaquePtr<QualType>;
-
-  // We can re-use the low bit of expression, statement, base, and
-  // member-initializer pointers for the "invalid" flag of
-  // ActionResult.
-  template<> struct IsResultPtrLowBitFree<Expr*> {
-    static const bool value = true;
-  };
-  template<> struct IsResultPtrLowBitFree<Stmt*> {
-    static const bool value = true;
-  };
-  template<> struct IsResultPtrLowBitFree<CXXBaseSpecifier*> {
-    static const bool value = true;
-  };
-  template<> struct IsResultPtrLowBitFree<CXXCtorInitializer*> {
-    static const bool value = true;
-  };
-
-  using ExprResult = ActionResult<Expr *>;
-  using StmtResult = ActionResult<Stmt *>;
-  using TypeResult = ActionResult<ParsedType>;
-  using BaseResult = ActionResult<CXXBaseSpecifier *>;
-  using MemInitResult = ActionResult<CXXCtorInitializer *>;
-
-  using DeclResult = ActionResult<Decl *>;
-  using ParsedTemplateTy = OpaquePtr<TemplateName>;
-  using UnionParsedTemplateTy = UnionOpaquePtr<TemplateName>;
-
-  using MultiExprArg = MutableArrayRef<Expr *>;
-  using MultiStmtArg = MutableArrayRef<Stmt *>;
-  using ASTTemplateArgsPtr = MutableArrayRef<ParsedTemplateArgument>;
-  using MultiTypeArg = MutableArrayRef<ParsedType>;
-  using MultiTemplateParamsArg = MutableArrayRef<TemplateParameterList *>;
-
-  inline ExprResult ExprError() { return ExprResult(true); }
-  inline StmtResult StmtError() { return StmtResult(true); }
-  inline TypeResult TypeError() { return TypeResult(true); }
-
-  inline ExprResult ExprError(const StreamingDiagnostic &) {
-    return ExprError();
-  }
-  inline StmtResult StmtError(const StreamingDiagnostic &) {
-    return StmtError();
-  }
-
-  inline ExprResult ExprEmpty() { return ExprResult(false); }
-  inline StmtResult StmtEmpty() { return StmtResult(false); }
-
-  inline Expr *AssertSuccess(ExprResult R) {
-    assert(!R.isInvalid() && "operation was asserted to never fail!");
-    return R.get();
-  }
-
-  inline Stmt *AssertSuccess(StmtResult R) {
-    assert(!R.isInvalid() && "operation was asserted to never fail!");
-    return R.get();
+// This ActionResult partial specialization places the "invalid"
+// flag into the low bit of the pointer.
+template <typename PtrTy> class ActionResult<PtrTy, true> {
+  // A pointer whose low bit is 1 if this result is invalid, 0
+  // otherwise.
+  uintptr_t PtrWithInvalid;
+
+  using PtrTraits = llvm::PointerLikeTypeTraits<PtrTy>;
+
+public:
+  ActionResult(bool Invalid = false)
+      : PtrWithInvalid(static_cast<uintptr_t>(Invalid)) {}
+
+  ActionResult(PtrTy V) {
+    void *VP = PtrTraits::getAsVoidPointer(V);
+    PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);
+    assert((PtrWithInvalid & 0x01) == 0 && "Badly aligned pointer");
   }
 
+  ActionResult(const DiagnosticBuilder &) : PtrWithInvalid(0x01) {}
+
+  // These two overloads prevent void* -> bool conversions.
+  ActionResult(const void *) = delete;
+  ActionResult(volatile void *) = delete;
+
+  bool isInvalid() const { return PtrWithInvalid & 0x01; }
+  bool isUsable() const { return PtrWithInvalid > 0x01; }
+  bool isUnset() const { return PtrWithInvalid == 0; }
+
+  PtrTy get() const {
+    void *VP = reinterpret_cast<void *>(PtrWithInvalid & ~0x01);
+    return PtrTraits::getFromVoidPointer(VP);
+  }
+
+  template <typename T> T *getAs() { return static_cast<T *>(get()); }
+
+  void set(PtrTy V) {
+    void *VP = PtrTraits::getAsVoidPointer(V);
+    PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);
+    assert((PtrWithInvalid & 0x01) == 0 && "Badly aligned pointer");
+  }
+
+  const ActionResult &operator=(PtrTy RHS) {
+    void *VP = PtrTraits::getAsVoidPointer(RHS);
+    PtrWithInvalid = reinterpret_cast<uintptr_t>(VP);
+    assert((PtrWithInvalid & 0x01) == 0 && "Badly aligned pointer");
+    return *this;
+  }
+
+  // For types where we can fit a flag in with the pointer, provide
+  // conversions to/from pointer type.
+  static ActionResult getFromOpaquePointer(void *P) {
+    ActionResult Result;
+    Result.PtrWithInvalid = (uintptr_t)P;
+    return Result;
+  }
+  void *getAsOpaquePointer() const { return (void *)PtrWithInvalid; }
+};
+
+/// An opaque type for threading parsed type information through the
+/// parser.
+using ParsedType = OpaquePtr<QualType>;
+using UnionParsedType = UnionOpaquePtr<QualType>;
+
+// We can re-use the low bit of expression, statement, base, and
+// member-initializer pointers for the "invalid" flag of
+// ActionResult.
+template <> struct IsResultPtrLowBitFree<Expr *> {
+  static const bool value = true;
+};
+template <> struct IsResultPtrLowBitFree<Stmt *> {
+  static const bool value = true;
+};
+template <> struct IsResultPtrLowBitFree<CXXBaseSpecifier *> {
+  static const bool value = true;
+};
+template <> struct IsResultPtrLowBitFree<CXXCtorInitializer *> {
+  static const bool value = true;
+};
+
+using ExprResult = ActionResult<Expr *>;
+using StmtResult = ActionResult<Stmt *>;
+using TypeResult = ActionResult<ParsedType>;
+using BaseResult = ActionResult<CXXBaseSpecifier *>;
+using MemInitResult = ActionResult<CXXCtorInitializer *>;
+
+using DeclResult = ActionResult<Decl *>;
+using ParsedTemplateTy = OpaquePtr<TemplateName>;
+using UnionParsedTemplateTy = UnionOpaquePtr<TemplateName>;
+
+using MultiExprArg = MutableArrayRef<Expr *>;
+using MultiStmtArg = MutableArrayRef<Stmt *>;
+using ASTTemplateArgsPtr = MutableArrayRef<ParsedTemplateArgument>;
+using MultiTypeArg = MutableArrayRef<ParsedType>;
+using MultiTemplateParamsArg = MutableArrayRef<TemplateParameterList *>;
+
+inline ExprResult ExprError() { return ExprResult(true); }
+inline StmtResult StmtError() { return StmtResult(true); }
+inline TypeResult TypeError() { return TypeResult(true); }
+
+inline ExprResult ExprError(const StreamingDiagnostic &) { return ExprError(); }
+inline StmtResult StmtError(const StreamingDiagnostic &) { return StmtError(); }
+
+inline ExprResult ExprEmpty() { return ExprResult(false); }
+inline StmtResult StmtEmpty() { return StmtResult(false); }
+
+inline Expr *AssertSuccess(ExprResult R) {
+  assert(!R.isInvalid() && "operation was asserted to never fail!");
+  return R.get();
+}
+
+inline Stmt *AssertSuccess(StmtResult R) {
+  assert(!R.isInvalid() && "operation was asserted to never fail!");
+  return R.get();
+}
+
 } // namespace clang
 
 #endif // LLVM_CLANG_SEMA_OWNERSHIP_H
diff --color -uprN clang-14.0.6.src/include/clang/Sema/Sema.h clang-14.0.6.src.patched/include/clang/Sema/Sema.h
--- clang-14.0.6.src/include/clang/Sema/Sema.h	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/include/clang/Sema/Sema.h	2024-11-12 13:24:23.346651843 +0800
@@ -43,6 +43,7 @@
 #include "clang/Basic/OpenCLOptions.h"
 #include "clang/Basic/OpenMPKinds.h"
 #include "clang/Basic/PragmaKinds.h"
+#include "clang/Basic/SourceLocation.h"
 #include "clang/Basic/Specifiers.h"
 #include "clang/Basic/TemplateKinds.h"
 #include "clang/Basic/TypeTraits.h"
@@ -73,172 +74,173 @@
 #include <vector>
 
 namespace llvm {
-  class APSInt;
-  template <typename ValueT, typename ValueInfoT> class DenseSet;
-  class SmallBitVector;
-  struct InlineAsmIdentifierInfo;
-}
+class APSInt;
+template <typename ValueT, typename ValueInfoT> class DenseSet;
+class SmallBitVector;
+struct InlineAsmIdentifierInfo;
+} // namespace llvm
 
 namespace clang {
-  class ADLResult;
-  class ASTConsumer;
-  class ASTContext;
-  class ASTMutationListener;
-  class ASTReader;
-  class ASTWriter;
-  class ArrayType;
-  class ParsedAttr;
-  class BindingDecl;
-  class BlockDecl;
-  class CapturedDecl;
-  class CXXBasePath;
-  class CXXBasePaths;
-  class CXXBindTemporaryExpr;
-  typedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;
-  class CXXConstructorDecl;
-  class CXXConversionDecl;
-  class CXXDeleteExpr;
-  class CXXDestructorDecl;
-  class CXXFieldCollector;
-  class CXXMemberCallExpr;
-  class CXXMethodDecl;
-  class CXXScopeSpec;
-  class CXXTemporary;
-  class CXXTryStmt;
-  class CallExpr;
-  class ClassTemplateDecl;
-  class ClassTemplatePartialSpecializationDecl;
-  class ClassTemplateSpecializationDecl;
-  class VarTemplatePartialSpecializationDecl;
-  class CodeCompleteConsumer;
-  class CodeCompletionAllocator;
-  class CodeCompletionTUInfo;
-  class CodeCompletionResult;
-  class CoroutineBodyStmt;
-  class Decl;
-  class DeclAccessPair;
-  class DeclContext;
-  class DeclRefExpr;
-  class DeclaratorDecl;
-  class DeducedTemplateArgument;
-  class DependentDiagnostic;
-  class DesignatedInitExpr;
-  class Designation;
-  class EnableIfAttr;
-  class EnumConstantDecl;
-  class Expr;
-  class ExtVectorType;
-  class FormatAttr;
-  class FriendDecl;
-  class FunctionDecl;
-  class FunctionProtoType;
-  class FunctionTemplateDecl;
-  class ImplicitConversionSequence;
-  typedef MutableArrayRef<ImplicitConversionSequence> ConversionSequenceList;
-  class InitListExpr;
-  class InitializationKind;
-  class InitializationSequence;
-  class InitializedEntity;
-  class IntegerLiteral;
-  class LabelStmt;
-  class LambdaExpr;
-  class LangOptions;
-  class LocalInstantiationScope;
-  class LookupResult;
-  class MacroInfo;
-  typedef ArrayRef<std::pair<IdentifierInfo *, SourceLocation>> ModuleIdPath;
-  class ModuleLoader;
-  class MultiLevelTemplateArgumentList;
-  class NamedDecl;
-  class ObjCCategoryDecl;
-  class ObjCCategoryImplDecl;
-  class ObjCCompatibleAliasDecl;
-  class ObjCContainerDecl;
-  class ObjCImplDecl;
-  class ObjCImplementationDecl;
-  class ObjCInterfaceDecl;
-  class ObjCIvarDecl;
-  template <class T> class ObjCList;
-  class ObjCMessageExpr;
-  class ObjCMethodDecl;
-  class ObjCPropertyDecl;
-  class ObjCProtocolDecl;
-  class OMPThreadPrivateDecl;
-  class OMPRequiresDecl;
-  class OMPDeclareReductionDecl;
-  class OMPDeclareSimdDecl;
-  class OMPClause;
-  struct OMPVarListLocTy;
-  struct OverloadCandidate;
-  enum class OverloadCandidateParamOrder : char;
-  enum OverloadCandidateRewriteKind : unsigned;
-  class OverloadCandidateSet;
-  class OverloadExpr;
-  class ParenListExpr;
-  class ParmVarDecl;
-  class Preprocessor;
-  class PseudoDestructorTypeStorage;
-  class PseudoObjectExpr;
-  class QualType;
-  class StandardConversionSequence;
-  class Stmt;
-  class StringLiteral;
-  class SwitchStmt;
-  class TemplateArgument;
-  class TemplateArgumentList;
-  class TemplateArgumentLoc;
-  class TemplateDecl;
-  class TemplateInstantiationCallback;
-  class TemplateParameterList;
-  class TemplatePartialOrderingContext;
-  class TemplateTemplateParmDecl;
-  class Token;
-  class TypeAliasDecl;
-  class TypedefDecl;
-  class TypedefNameDecl;
-  class TypeLoc;
-  class TypoCorrectionConsumer;
-  class UnqualifiedId;
-  class UnresolvedLookupExpr;
-  class UnresolvedMemberExpr;
-  class UnresolvedSetImpl;
-  class UnresolvedSetIterator;
-  class UsingDecl;
-  class UsingShadowDecl;
-  class ValueDecl;
-  class VarDecl;
-  class VarTemplateSpecializationDecl;
-  class VisibilityAttr;
-  class VisibleDeclConsumer;
-  class IndirectFieldDecl;
-  struct DeductionFailureInfo;
-  class TemplateSpecCandidateSet;
+class ADLResult;
+class ASTConsumer;
+class ASTContext;
+class ASTMutationListener;
+class ASTReader;
+class ASTWriter;
+class ArrayType;
+class ParsedAttr;
+class BindingDecl;
+class BlockDecl;
+class CapturedDecl;
+class CXXBasePath;
+class CXXBasePaths;
+class CXXBindTemporaryExpr;
+typedef SmallVector<CXXBaseSpecifier *, 4> CXXCastPath;
+class CXXConstructorDecl;
+class CXXConversionDecl;
+class CXXDeleteExpr;
+class CXXDestructorDecl;
+class CXXFieldCollector;
+class CXXMemberCallExpr;
+class CXXMethodDecl;
+class CXXScopeSpec;
+class CXXTemporary;
+class CXXTryStmt;
+class CallExpr;
+class ClassTemplateDecl;
+class ClassTemplatePartialSpecializationDecl;
+class ClassTemplateSpecializationDecl;
+class VarTemplatePartialSpecializationDecl;
+class CodeCompleteConsumer;
+class CodeCompletionAllocator;
+class CodeCompletionTUInfo;
+class CodeCompletionResult;
+class CoroutineBodyStmt;
+class Decl;
+class DeclAccessPair;
+class DeclContext;
+class DeclRefExpr;
+class DeclaratorDecl;
+class DeducedTemplateArgument;
+class DependentDiagnostic;
+class DesignatedInitExpr;
+class Designation;
+class EnableIfAttr;
+class EnumConstantDecl;
+class Expr;
+class ExtVectorType;
+class FormatAttr;
+class FriendDecl;
+class FunctionDecl;
+class FunctionProtoType;
+class FunctionTemplateDecl;
+class ImplicitConversionSequence;
+typedef MutableArrayRef<ImplicitConversionSequence> ConversionSequenceList;
+class InitListExpr;
+class InitializationKind;
+class InitializationSequence;
+class InitializedEntity;
+class IntegerLiteral;
+class LabelStmt;
+class LambdaExpr;
+class LangOptions;
+class LocalInstantiationScope;
+class LookupResult;
+class MacroInfo;
+typedef ArrayRef<std::pair<IdentifierInfo *, SourceLocation>> ModuleIdPath;
+class ModuleLoader;
+class MultiLevelTemplateArgumentList;
+class NamedDecl;
+class ObjCCategoryDecl;
+class ObjCCategoryImplDecl;
+class ObjCCompatibleAliasDecl;
+class ObjCContainerDecl;
+class ObjCImplDecl;
+class ObjCImplementationDecl;
+class ObjCInterfaceDecl;
+class ObjCIvarDecl;
+template <class T> class ObjCList;
+class ObjCMessageExpr;
+class ObjCMethodDecl;
+class ObjCPropertyDecl;
+class ObjCProtocolDecl;
+class OMPThreadPrivateDecl;
+class OMPRequiresDecl;
+class OMPDeclareReductionDecl;
+class OMPDeclareSimdDecl;
+class OMPClause;
+struct OMPVarListLocTy;
+struct OverloadCandidate;
+enum class OverloadCandidateParamOrder : char;
+enum OverloadCandidateRewriteKind : unsigned;
+class OverloadCandidateSet;
+class OverloadExpr;
+class ParenListExpr;
+class ParmVarDecl;
+class Preprocessor;
+class PseudoDestructorTypeStorage;
+class PseudoObjectExpr;
+class QualType;
+class StandardConversionSequence;
+class Stmt;
+class StringLiteral;
+class SwitchStmt;
+class TemplateArgument;
+class TemplateArgumentList;
+class TemplateArgumentLoc;
+class TemplateDecl;
+class TemplateInstantiationCallback;
+class TemplateParameterList;
+class TemplatePartialOrderingContext;
+class TemplateTemplateParmDecl;
+class Token;
+class TypeAliasDecl;
+class TypedefDecl;
+class TypedefNameDecl;
+class TypeLoc;
+class TypoCorrectionConsumer;
+class UnqualifiedId;
+class UnresolvedLookupExpr;
+class UnresolvedMemberExpr;
+class UnresolvedSetImpl;
+class UnresolvedSetIterator;
+class UsingDecl;
+class UsingShadowDecl;
+class ValueDecl;
+class VarDecl;
+class VarTemplateSpecializationDecl;
+class VisibilityAttr;
+class VisibleDeclConsumer;
+class IndirectFieldDecl;
+struct DeductionFailureInfo;
+class TemplateSpecCandidateSet;
 
 namespace sema {
-  class AccessedEntity;
-  class BlockScopeInfo;
-  class Capture;
-  class CapturedRegionScopeInfo;
-  class CapturingScopeInfo;
-  class CompoundScopeInfo;
-  class DelayedDiagnostic;
-  class DelayedDiagnosticPool;
-  class FunctionScopeInfo;
-  class LambdaScopeInfo;
-  class PossiblyUnreachableDiag;
-  class SemaPPCallbacks;
-  class TemplateDeductionInfo;
-}
+class AccessedEntity;
+class BlockScopeInfo;
+class Capture;
+class CapturedRegionScopeInfo;
+class CapturingScopeInfo;
+class CompoundScopeInfo;
+class DelayedDiagnostic;
+class DelayedDiagnosticPool;
+class FunctionScopeInfo;
+class LambdaScopeInfo;
+class PossiblyUnreachableDiag;
+class SemaPPCallbacks;
+class TemplateDeductionInfo;
+} // namespace sema
 
 namespace threadSafety {
-  class BeforeSet;
-  void threadSafetyCleanup(BeforeSet* Cache);
-}
+class BeforeSet;
+void threadSafetyCleanup(BeforeSet *Cache);
+} // namespace threadSafety
 
 // FIXME: No way to easily map from TemplateTypeParmTypes to
 // TemplateTypeParmDecls, so we have this horrible PointerUnion.
-typedef std::pair<llvm::PointerUnion<const TemplateTypeParmType*, NamedDecl*>,
-                  SourceLocation> UnexpandedParameterPack;
+typedef std::pair<llvm::PointerUnion<const TemplateTypeParmType *, NamedDecl *>,
+                  SourceLocation>
+    UnexpandedParameterPack;
 
 /// Describes whether we've seen any nullability information for the given
 /// file.
@@ -355,10 +357,10 @@ class Sema final {
   Sema(const Sema &) = delete;
   void operator=(const Sema &) = delete;
 
-  ///Source of additional semantic information.
+  /// Source of additional semantic information.
   ExternalSemaSource *ExternalSource;
 
-  ///Whether Sema has generated a multiplexer and has to delete it.
+  /// Whether Sema has generated a multiplexer and has to delete it.
   bool isMultiplexExternalSource;
 
   static bool mightHaveNonExternalLinkage(const DeclaratorDecl *FD);
@@ -371,7 +373,7 @@ class Sema final {
   bool shouldLinkPossiblyHiddenDecl(const NamedDecl *Old,
                                     const NamedDecl *New) {
     if (isVisible(Old))
-     return true;
+      return true;
     // See comment in below overload for why it's safe to compute the linkage
     // of the new declaration here.
     if (New->isExternallyDeclarable()) {
@@ -436,7 +438,7 @@ public:
       MSPointerToMemberRepresentationMethod;
 
   /// Stack of active SEH __finally scopes.  Can be empty.
-  SmallVector<Scope*, 2> CurrentSEHFinally;
+  SmallVector<Scope *, 2> CurrentSEHFinally;
 
   /// Source location for newly created implicit MSInheritanceAttrs
   SourceLocation ImplicitMSInheritanceAttrLoc;
@@ -449,39 +451,36 @@ public:
 
   /// pragma clang section kind
   enum PragmaClangSectionKind {
-    PCSK_Invalid      = 0,
-    PCSK_BSS          = 1,
-    PCSK_Data         = 2,
-    PCSK_Rodata       = 3,
-    PCSK_Text         = 4,
-    PCSK_Relro        = 5
-   };
-
-  enum PragmaClangSectionAction {
-    PCSA_Set     = 0,
-    PCSA_Clear   = 1
+    PCSK_Invalid = 0,
+    PCSK_BSS = 1,
+    PCSK_Data = 2,
+    PCSK_Rodata = 3,
+    PCSK_Text = 4,
+    PCSK_Relro = 5
   };
 
+  enum PragmaClangSectionAction { PCSA_Set = 0, PCSA_Clear = 1 };
+
   struct PragmaClangSection {
     std::string SectionName;
     bool Valid = false;
     SourceLocation PragmaLocation;
   };
 
-   PragmaClangSection PragmaClangBSSSection;
-   PragmaClangSection PragmaClangDataSection;
-   PragmaClangSection PragmaClangRodataSection;
-   PragmaClangSection PragmaClangRelroSection;
-   PragmaClangSection PragmaClangTextSection;
+  PragmaClangSection PragmaClangBSSSection;
+  PragmaClangSection PragmaClangDataSection;
+  PragmaClangSection PragmaClangRodataSection;
+  PragmaClangSection PragmaClangRelroSection;
+  PragmaClangSection PragmaClangTextSection;
 
   enum PragmaMsStackAction {
-    PSK_Reset     = 0x0,                // #pragma ()
-    PSK_Set       = 0x1,                // #pragma (value)
-    PSK_Push      = 0x2,                // #pragma (push[, id])
-    PSK_Pop       = 0x4,                // #pragma (pop[, id])
-    PSK_Show      = 0x8,                // #pragma (show) -- only for "pack"!
-    PSK_Push_Set  = PSK_Push | PSK_Set, // #pragma (push[, id], value)
-    PSK_Pop_Set   = PSK_Pop | PSK_Set,  // #pragma (pop[, id], value)
+    PSK_Reset = 0x0,                   // #pragma ()
+    PSK_Set = 0x1,                     // #pragma (value)
+    PSK_Push = 0x2,                    // #pragma (push[, id])
+    PSK_Pop = 0x4,                     // #pragma (pop[, id])
+    PSK_Show = 0x8,                    // #pragma (show) -- only for "pack"!
+    PSK_Push_Set = PSK_Push | PSK_Set, // #pragma (push[, id], value)
+    PSK_Pop_Set = PSK_Pop | PSK_Set,   // #pragma (pop[, id], value)
   };
 
   // #pragma pack and align.
@@ -586,8 +585,7 @@ public:
     static constexpr uint32_t PackNumMask{0x0000'01F0};
   };
 
-  template<typename ValueType>
-  struct PragmaStack {
+  template <typename ValueType> struct PragmaStack {
     struct Slot {
       llvm::StringRef StackSlotLabel;
       ValueType Value;
@@ -787,7 +785,7 @@ public:
   /// context.
   unsigned FunctionScopesStart = 0;
 
-  ArrayRef<sema::FunctionScopeInfo*> getFunctionScopes() const {
+  ArrayRef<sema::FunctionScopeInfo *> getFunctionScopes() const {
     return llvm::makeArrayRef(FunctionScopes.begin() + FunctionScopesStart,
                               FunctionScopes.end());
   }
@@ -811,7 +809,7 @@ public:
 
   typedef LazyVector<TypedefNameDecl *, ExternalSemaSource,
                      &ExternalSemaSource::ReadExtVectorDecls, 2, 2>
-    ExtVectorDeclsType;
+      ExtVectorDeclsType;
 
   /// ExtVectorDecls - This is a list all the extended vector types. This allows
   /// us to associate a raw vector type with one of the ext_vector type names.
@@ -839,7 +837,7 @@ public:
   typedef llvm::SmallVector<DeleteExprLoc, 4> DeleteLocs;
   llvm::MapVector<FieldDecl *, DeleteLocs> DeleteExprs;
 
-  typedef llvm::SmallPtrSet<const CXXRecordDecl*, 8> RecordDeclSetTy;
+  typedef llvm::SmallPtrSet<const CXXRecordDecl *, 8> RecordDeclSetTy;
 
   /// PureVirtualClassDiagSet - a set of class declarations which we have
   /// emitted a list of pure virtual functions. Used to prevent emitting the
@@ -848,14 +846,14 @@ public:
 
   /// ParsingInitForAutoVars - a set of declarations with auto types for which
   /// we are currently parsing the initializer.
-  llvm::SmallPtrSet<const Decl*, 4> ParsingInitForAutoVars;
+  llvm::SmallPtrSet<const Decl *, 4> ParsingInitForAutoVars;
 
   /// Look for a locally scoped extern "C" declaration by the given name.
   NamedDecl *findLocallyScopedExternCDecl(DeclarationName Name);
 
   typedef LazyVector<VarDecl *, ExternalSemaSource,
                      &ExternalSemaSource::ReadTentativeDefinitions, 2, 2>
-    TentativeDefinitionsType;
+      TentativeDefinitionsType;
 
   /// All the tentative definitions encountered in the TU.
   TentativeDefinitionsType TentativeDefinitions;
@@ -865,7 +863,7 @@ public:
 
   typedef LazyVector<const DeclaratorDecl *, ExternalSemaSource,
                      &ExternalSemaSource::ReadUnusedFileScopedDecls, 2, 2>
-    UnusedFileScopedDeclsType;
+      UnusedFileScopedDeclsType;
 
   /// The set of file scoped decls seen so far that have not been used
   /// and must warn if not used. Only contains the first declaration.
@@ -873,7 +871,7 @@ public:
 
   typedef LazyVector<CXXConstructorDecl *, ExternalSemaSource,
                      &ExternalSemaSource::ReadDelegatingConstructors, 2, 2>
-    DelegatingCtorDeclsType;
+      DelegatingCtorDeclsType;
 
   /// All the delegating constructors seen so far in the file, used for
   /// cycle detection at the end of the TU.
@@ -882,16 +880,16 @@ public:
   /// All the overriding functions seen during a class definition
   /// that had their exception spec checks delayed, plus the overridden
   /// function.
-  SmallVector<std::pair<const CXXMethodDecl*, const CXXMethodDecl*>, 2>
-    DelayedOverridingExceptionSpecChecks;
+  SmallVector<std::pair<const CXXMethodDecl *, const CXXMethodDecl *>, 2>
+      DelayedOverridingExceptionSpecChecks;
 
   /// All the function redeclarations seen during a class definition that had
   /// their exception spec checks delayed, plus the prior declaration they
   /// should be checked against. Except during error recovery, the new decl
   /// should always be a friend declaration, as that's the only valid way to
   /// redeclare a special member before its class is complete.
-  SmallVector<std::pair<FunctionDecl*, FunctionDecl*>, 2>
-    DelayedEquivalentExceptionSpecChecks;
+  SmallVector<std::pair<FunctionDecl *, FunctionDecl *>, 2>
+      DelayedEquivalentExceptionSpecChecks;
 
   typedef llvm::MapVector<const FunctionDecl *,
                           std::unique_ptr<LateParsedTemplate>>
@@ -906,8 +904,7 @@ public:
   void *OpaqueParser;
 
   void SetLateTemplateParser(LateTemplateParserCB *LTP,
-                             LateTemplateParserCleanupCB *LTPCleanup,
-                             void *P) {
+                             LateTemplateParserCleanupCB *LTPCleanup, void *P) {
     LateTemplateParser = LTP;
     LateTemplateParserCleanup = LTPCleanup;
     OpaqueParser = P;
@@ -939,9 +936,7 @@ public:
     bool shouldDelayDiagnostics() { return CurPool != nullptr; }
 
     /// Returns the current delayed-diagnostics pool.
-    sema::DelayedDiagnosticPool *getCurrentPool() const {
-      return CurPool;
-    }
+    sema::DelayedDiagnosticPool *getCurrentPool() const { return CurPool; }
 
     /// Enter a new scope.  Access and deprecation diagnostics will be
     /// collected in this pool.
@@ -987,12 +982,11 @@ public:
 
   public:
     ContextRAII(Sema &S, DeclContext *ContextToPush, bool NewThisContext = true)
-      : S(S), SavedContext(S.CurContext),
-        SavedContextState(S.DelayedDiagnostics.pushUndelayed()),
-        SavedCXXThisTypeOverride(S.CXXThisTypeOverride),
-        SavedFunctionScopesStart(S.FunctionScopesStart),
-        SavedInventedParameterInfosStart(S.InventedParameterInfosStart)
-    {
+        : S(S), SavedContext(S.CurContext),
+          SavedContextState(S.DelayedDiagnostics.pushUndelayed()),
+          SavedCXXThisTypeOverride(S.CXXThisTypeOverride),
+          SavedFunctionScopesStart(S.FunctionScopesStart),
+          SavedInventedParameterInfosStart(S.InventedParameterInfosStart) {
       assert(ContextToPush && "pushing null context");
       S.CurContext = ContextToPush;
       if (NewThisContext)
@@ -1003,7 +997,8 @@ public:
     }
 
     void pop() {
-      if (!SavedContext) return;
+      if (!SavedContext)
+        return;
       S.CurContext = SavedContext;
       S.DelayedDiagnostics.popUndelayed(SavedContextState);
       S.CXXThisTypeOverride = SavedCXXThisTypeOverride;
@@ -1012,9 +1007,7 @@ public:
       SavedContext = nullptr;
     }
 
-    ~ContextRAII() {
-      pop();
-    }
+    ~ContextRAII() { pop(); }
   };
 
   /// Whether the AST is currently being rebuilt to correct immediate
@@ -1081,8 +1074,7 @@ public:
   /// \#pragma redefine_extname before declared.  Used in Solaris system headers
   /// to define functions that occur in multiple standards to call the version
   /// in the currently selected standard.
-  llvm::DenseMap<IdentifierInfo*,AsmLabelAttr*> ExtnameUndeclaredIdentifiers;
-
+  llvm::DenseMap<IdentifierInfo *, AsmLabelAttr *> ExtnameUndeclaredIdentifiers;
 
   /// Load weak undeclared identifiers from the external source.
   void LoadExternalWeakUndeclaredIdentifiers();
@@ -1092,7 +1084,7 @@ public:
   /// I couldn't figure out a clean way to generate these in-line, so
   /// we store them here and handle separately -- which is a hack.
   /// It would be best to refactor this.
-  SmallVector<Decl*,2> WeakTopLevelDecl;
+  SmallVector<Decl *, 2> WeakTopLevelDecl;
 
   IdentifierResolver IdResolver;
 
@@ -1281,10 +1273,11 @@ public:
     /// Expressions appearing as the LHS of a volatile assignment in this
     /// context. We produce a warning for these when popping the context if
     /// they are not discarded-value expressions nor unevaluated operands.
-    SmallVector<Expr*, 2> VolatileAssignmentLHSs;
+    SmallVector<Expr *, 2> VolatileAssignmentLHSs;
 
     /// Set of candidates for starting an immediate invocation.
-    llvm::SmallVector<ImmediateInvocationCandidate, 4> ImmediateInvocationCandidates;
+    llvm::SmallVector<ImmediateInvocationCandidate, 4>
+        ImmediateInvocationCandidates;
 
     /// Set of DeclRefExprs referencing a consteval function when used in a
     /// context not already known to be immediately invoked.
@@ -1293,7 +1286,9 @@ public:
     /// \brief Describes whether we are in an expression constext which we have
     /// to handle differently.
     enum ExpressionKind {
-      EK_Decltype, EK_TemplateArgument, EK_Other
+      EK_Decltype,
+      EK_TemplateArgument,
+      EK_Other
     } ExprContext;
 
     // A context can be nested in both a discarded statement context and
@@ -1350,7 +1345,6 @@ public:
   std::tuple<MangleNumberingContext *, Decl *>
   getCurrentMangleNumberContext(const DeclContext *DC);
 
-
   /// SpecialMemberOverloadResult - The overloading result for a special member
   /// function.
   ///
@@ -1358,11 +1352,7 @@ public:
   /// integer are used to determine whether overload resolution succeeded.
   class SpecialMemberOverloadResult {
   public:
-    enum Kind {
-      NoMemberOrDeleted,
-      Ambiguous,
-      Success
-    };
+    enum Kind { NoMemberOrDeleted, Ambiguous, Success };
 
   private:
     llvm::PointerIntPair<CXXMethodDecl *, 2> Pair;
@@ -1379,13 +1369,11 @@ public:
     void setKind(Kind K) { Pair.setInt(K); }
   };
 
-  class SpecialMemberOverloadResultEntry
-      : public llvm::FastFoldingSetNode,
-        public SpecialMemberOverloadResult {
+  class SpecialMemberOverloadResultEntry : public llvm::FastFoldingSetNode,
+                                           public SpecialMemberOverloadResult {
   public:
     SpecialMemberOverloadResultEntry(const llvm::FoldingSetNodeID &ID)
-      : FastFoldingSetNode(ID)
-    {}
+        : FastFoldingSetNode(ID) {}
   };
 
   /// A cache of special member function overload resolution results
@@ -1394,7 +1382,7 @@ public:
 
   /// A cache of the flags available in enumerations with the flag_bits
   /// attribute.
-  mutable llvm::DenseMap<const EnumDecl*, llvm::APInt> FlagBitsCache;
+  mutable llvm::DenseMap<const EnumDecl *, llvm::APInt> FlagBitsCache;
 
   /// The kind of translation unit we are processing.
   ///
@@ -1411,7 +1399,7 @@ public:
   unsigned NumSFINAEErrors;
 
   typedef llvm::DenseMap<ParmVarDecl *, llvm::TinyPtrVector<ParmVarDecl *>>
-    UnparsedDefaultArgInstantiationsMap;
+      UnparsedDefaultArgInstantiationsMap;
 
   /// A mapping from parameters with unparsed default arguments to the
   /// set of instantiations of each parameter.
@@ -1437,7 +1425,7 @@ public:
 
   /// Obtain a sorted list of functions that are undefined but ODR-used.
   void getUndefinedButUsed(
-      SmallVectorImpl<std::pair<NamedDecl *, SourceLocation> > &Undefined);
+      SmallVectorImpl<std::pair<NamedDecl *, SourceLocation>> &Undefined);
 
   /// Retrieves list of suspicious delete-expressions that will be checked at
   /// the end of translation unit.
@@ -1551,7 +1539,7 @@ public:
     FPOptionsOverride getOverrides() { return OldOverrides; }
 
   private:
-    Sema& S;
+    Sema &S;
     FPOptions OldFPFeaturesState;
     FPOptionsOverride OldOverrides;
   };
@@ -1589,7 +1577,7 @@ public:
 
   const LangOptions &getLangOpts() const { return LangOpts; }
   OpenCLOptions &getOpenCLOptions() { return OpenCLFeatures; }
-  FPOptions     &getCurFPFeatures() { return CurFPFeatures; }
+  FPOptions &getCurFPFeatures() { return CurFPFeatures; }
 
   DiagnosticsEngine &getDiagnostics() const { return Diags; }
   SourceManager &getSourceManager() const { return SourceMgr; }
@@ -1597,14 +1585,14 @@ public:
   ASTContext &getASTContext() const { return Context; }
   ASTConsumer &getASTConsumer() const { return Consumer; }
   ASTMutationListener *getASTMutationListener() const;
-  ExternalSemaSource* getExternalSource() const { return ExternalSource; }
+  ExternalSemaSource *getExternalSource() const { return ExternalSource; }
 
   DarwinSDKInfo *getDarwinSDKInfoForAvailabilityChecking(SourceLocation Loc,
                                                          StringRef Platform);
   DarwinSDKInfo *getDarwinSDKInfoForAvailabilityChecking();
 
-  ///Registers an external source. If an external source already exists,
-  /// creates a multiplex external source and appends to it.
+  /// Registers an external source. If an external source already exists,
+  ///  creates a multiplex external source and appends to it.
   ///
   ///\param[in] E - A non-null external sema source.
   ///
@@ -1651,7 +1639,8 @@ public:
 
     ~ImmediateDiagBuilder() {
       // If we aren't active, there is nothing to do.
-      if (!isActive()) return;
+      if (!isActive())
+        return;
 
       // Otherwise, we need to emit the diagnostic. First clear the diagnostic
       // builder itself so it won't emit the diagnostic in its own destructor.
@@ -1842,8 +1831,8 @@ public:
   bool findMacroSpelling(SourceLocation &loc, StringRef name);
 
   /// Get a string to suggest for zero-initialization of a type.
-  std::string
-  getFixItZeroInitializerForType(QualType T, SourceLocation Loc) const;
+  std::string getFixItZeroInitializerForType(QualType T,
+                                             SourceLocation Loc) const;
   std::string getFixItZeroLiteralForType(QualType T, SourceLocation Loc) const;
 
   /// Calls \c Lexer::getLocForEndOfToken()
@@ -1859,12 +1848,12 @@ public:
 
   void emitAndClearUnusedLocalTypedefWarnings();
 
-  private:
-    /// Function or variable declarations to be checked for whether the deferred
-    /// diagnostics should be emitted.
-    llvm::SmallSetVector<Decl *, 4> DeclsToCheckForDeferredDiags;
+private:
+  /// Function or variable declarations to be checked for whether the deferred
+  /// diagnostics should be emitted.
+  llvm::SmallSetVector<Decl *, 4> DeclsToCheckForDeferredDiags;
 
-  public:
+public:
   // Emit all deferred diagnostics.
   void emitDeferredDiags();
 
@@ -1984,13 +1973,13 @@ public:
                               const DeclSpec *DS = nullptr);
   QualType BuildQualifiedType(QualType T, SourceLocation Loc, unsigned CVRA,
                               const DeclSpec *DS = nullptr);
-  QualType BuildPointerType(QualType T,
-                            SourceLocation Loc, DeclarationName Entity);
-  QualType BuildReferenceType(QualType T, bool LValueRef,
-                              SourceLocation Loc, DeclarationName Entity);
+  QualType BuildPointerType(QualType T, SourceLocation Loc,
+                            DeclarationName Entity);
+  QualType BuildReferenceType(QualType T, bool LValueRef, SourceLocation Loc,
+                              DeclarationName Entity);
   QualType BuildArrayType(QualType T, ArrayType::ArraySizeModifier ASM,
-                          Expr *ArraySize, unsigned Quals,
-                          SourceRange Brackets, DeclarationName Entity);
+                          Expr *ArraySize, unsigned Quals, SourceRange Brackets,
+                          DeclarationName Entity);
   QualType BuildVectorType(QualType T, Expr *VecSize, SourceLocation AttrLoc);
   QualType BuildExtVectorType(QualType T, Expr *ArraySize,
                               SourceLocation AttrLoc);
@@ -2035,22 +2024,18 @@ public:
   /// \returns A suitable function type, if there are no errors. The
   /// unqualified type will always be a FunctionProtoType.
   /// Otherwise, returns a NULL type.
-  QualType BuildFunctionType(QualType T,
-                             MutableArrayRef<QualType> ParamTypes,
+  QualType BuildFunctionType(QualType T, MutableArrayRef<QualType> ParamTypes,
                              SourceLocation Loc, DeclarationName Entity,
                              const FunctionProtoType::ExtProtoInfo &EPI);
 
   QualType BuildMemberPointerType(QualType T, QualType Class,
-                                  SourceLocation Loc,
-                                  DeclarationName Entity);
-  QualType BuildBlockPointerType(QualType T,
-                                 SourceLocation Loc, DeclarationName Entity);
+                                  SourceLocation Loc, DeclarationName Entity);
+  QualType BuildBlockPointerType(QualType T, SourceLocation Loc,
+                                 DeclarationName Entity);
   QualType BuildParenType(QualType T);
   QualType BuildAtomicType(QualType T, SourceLocation Loc);
-  QualType BuildReadPipeType(QualType T,
-                         SourceLocation Loc);
-  QualType BuildWritePipeType(QualType T,
-                         SourceLocation Loc);
+  QualType BuildReadPipeType(QualType T, SourceLocation Loc);
+  QualType BuildWritePipeType(QualType T, SourceLocation Loc);
   QualType BuildBitIntType(bool IsUnsigned, Expr *BitWidth, SourceLocation Loc);
 
   TypeSourceInfo *GetTypeForDeclarator(Declarator &D, Scope *S);
@@ -2074,22 +2059,22 @@ public:
   bool CheckSpecifiedExceptionType(QualType &T, SourceRange Range);
   bool CheckDistantExceptionSpec(QualType T);
   bool CheckEquivalentExceptionSpec(FunctionDecl *Old, FunctionDecl *New);
-  bool CheckEquivalentExceptionSpec(
-      const FunctionProtoType *Old, SourceLocation OldLoc,
-      const FunctionProtoType *New, SourceLocation NewLoc);
-  bool CheckEquivalentExceptionSpec(
-      const PartialDiagnostic &DiagID, const PartialDiagnostic & NoteID,
-      const FunctionProtoType *Old, SourceLocation OldLoc,
-      const FunctionProtoType *New, SourceLocation NewLoc);
+  bool CheckEquivalentExceptionSpec(const FunctionProtoType *Old,
+                                    SourceLocation OldLoc,
+                                    const FunctionProtoType *New,
+                                    SourceLocation NewLoc);
+  bool CheckEquivalentExceptionSpec(const PartialDiagnostic &DiagID,
+                                    const PartialDiagnostic &NoteID,
+                                    const FunctionProtoType *Old,
+                                    SourceLocation OldLoc,
+                                    const FunctionProtoType *New,
+                                    SourceLocation NewLoc);
   bool handlerCanCatch(QualType HandlerType, QualType ExceptionType);
-  bool CheckExceptionSpecSubset(const PartialDiagnostic &DiagID,
-                                const PartialDiagnostic &NestedDiagID,
-                                const PartialDiagnostic &NoteID,
-                                const PartialDiagnostic &NoThrowDiagID,
-                                const FunctionProtoType *Superset,
-                                SourceLocation SuperLoc,
-                                const FunctionProtoType *Subset,
-                                SourceLocation SubLoc);
+  bool CheckExceptionSpecSubset(
+      const PartialDiagnostic &DiagID, const PartialDiagnostic &NestedDiagID,
+      const PartialDiagnostic &NoteID, const PartialDiagnostic &NoThrowDiagID,
+      const FunctionProtoType *Superset, SourceLocation SuperLoc,
+      const FunctionProtoType *Subset, SourceLocation SubLoc);
   bool CheckParamExceptionSpec(const PartialDiagnostic &NestedDiagID,
                                const PartialDiagnostic &NoteID,
                                const FunctionProtoType *Target,
@@ -2114,7 +2099,7 @@ public:
   static int getPrintable(int I) { return I; }
   static unsigned getPrintable(unsigned I) { return I; }
   static bool getPrintable(bool B) { return B; }
-  static const char * getPrintable(const char *S) { return S; }
+  static const char *getPrintable(const char *S) { return S; }
   static StringRef getPrintable(StringRef S) { return S; }
   static const std::string &getPrintable(const std::string &S) { return S; }
   static const IdentifierInfo *getPrintable(const IdentifierInfo *II) {
@@ -2125,7 +2110,7 @@ public:
   static SourceRange getPrintable(SourceRange R) { return R; }
   static SourceRange getPrintable(SourceLocation L) { return L; }
   static SourceRange getPrintable(const Expr *E) { return E->getSourceRange(); }
-  static SourceRange getPrintable(TypeLoc TL) { return TL.getSourceRange();}
+  static SourceRange getPrintable(TypeLoc TL) { return TL.getSourceRange(); }
 
   template <typename... Ts> class BoundTypeDiagnoser : public TypeDiagnoser {
   protected:
@@ -2170,7 +2155,7 @@ public:
   template <typename... Ts>
   class SizelessTypeDiagnoser : public BoundTypeDiagnoser<Ts...> {
   public:
-    SizelessTypeDiagnoser(unsigned DiagID, const Ts &... Args)
+    SizelessTypeDiagnoser(unsigned DiagID, const Ts &...Args)
         : BoundTypeDiagnoser<Ts...>(DiagID, Args...) {}
 
     void diagnose(Sema &S, SourceLocation Loc, QualType T) override {
@@ -2220,7 +2205,7 @@ private:
   llvm::SmallVector<ModuleScope, 16> ModuleScopes;
 
   /// Namespace definitions that we will export when they finish.
-  llvm::SmallPtrSet<const NamespaceDecl*, 8> DeferredExportedNamespaces;
+  llvm::SmallPtrSet<const NamespaceDecl *, 8> DeferredExportedNamespaces;
 
   /// Get the module whose scope we are currently within.
   Module *getCurrentModule() const {
@@ -2285,7 +2270,7 @@ public:
                             bool OnlyNeedComplete = false);
   bool hasVisibleDefinition(const NamedDecl *D) {
     NamedDecl *Hidden;
-    return hasVisibleDefinition(const_cast<NamedDecl*>(D), &Hidden);
+    return hasVisibleDefinition(const_cast<NamedDecl *>(D), &Hidden);
   }
 
   /// Determine if the template parameter \p D has a visible default argument.
@@ -2341,7 +2326,7 @@ public:
 
   template <typename... Ts>
   bool RequireCompleteSizedType(SourceLocation Loc, QualType T, unsigned DiagID,
-                                const Ts &... Args) {
+                                const Ts &...Args) {
     SizelessTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);
     return RequireCompleteType(Loc, T, CompleteTypeKind::Normal, Diagnoser);
   }
@@ -2369,7 +2354,7 @@ public:
 
   template <typename... Ts>
   bool RequireCompleteSizedExprType(Expr *E, unsigned DiagID,
-                                    const Ts &... Args) {
+                                    const Ts &...Args) {
     SizelessTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);
     return RequireCompleteExprType(E, CompleteTypeKind::Normal, Diagnoser);
   }
@@ -2430,10 +2415,8 @@ public:
                          IdentifierInfo **CorrectedII = nullptr);
   TypeSpecifierType isTagName(IdentifierInfo &II, Scope *S);
   bool isMicrosoftMissingTypename(const CXXScopeSpec *SS, Scope *S);
-  void DiagnoseUnknownTypeName(IdentifierInfo *&II,
-                               SourceLocation IILoc,
-                               Scope *S,
-                               CXXScopeSpec *SS,
+  void DiagnoseUnknownTypeName(IdentifierInfo *&II, SourceLocation IILoc,
+                               Scope *S, CXXScopeSpec *SS,
                                ParsedType &SuggestedType,
                                bool IsTemplateName = false);
 
@@ -2502,9 +2485,7 @@ public:
 
     NameClassification(const IdentifierInfo *Keyword) : Kind(NC_Keyword) {}
 
-    static NameClassification Error() {
-      return NameClassification(NC_Error);
-    }
+    static NameClassification Error() { return NameClassification(NC_Error); }
 
     static NameClassification Unknown() {
       return NameClassification(NC_Unknown);
@@ -2688,8 +2669,8 @@ public:
 
   NamedDecl *HandleDeclarator(Scope *S, Declarator &D,
                               MultiTemplateParamsArg TemplateParameterLists);
-  bool tryToFixVariablyModifiedVarType(TypeSourceInfo *&TInfo,
-                                       QualType &T, SourceLocation Loc,
+  bool tryToFixVariablyModifiedVarType(TypeSourceInfo *&TInfo, QualType &T,
+                                       SourceLocation Loc,
                                        unsigned FailedFoldDiagID);
   void RegisterLocallyScopedExternCDecl(NamedDecl *ND, Scope *S);
   bool DiagnoseClassNameShadow(DeclContext *DC, DeclarationNameInfo Info);
@@ -2733,10 +2714,10 @@ public:
   void setTagNameForLinkagePurposes(TagDecl *TagFromDeclSpec,
                                     TypedefNameDecl *NewTD);
   void CheckTypedefForVariablyModifiedType(Scope *S, TypedefNameDecl *D);
-  NamedDecl* ActOnTypedefDeclarator(Scope* S, Declarator& D, DeclContext* DC,
+  NamedDecl *ActOnTypedefDeclarator(Scope *S, Declarator &D, DeclContext *DC,
                                     TypeSourceInfo *TInfo,
                                     LookupResult &Previous);
-  NamedDecl* ActOnTypedefNameDecl(Scope* S, DeclContext* DC, TypedefNameDecl *D,
+  NamedDecl *ActOnTypedefNameDecl(Scope *S, DeclContext *DC, TypedefNameDecl *D,
                                   LookupResult &Previous, bool &Redeclaration);
   NamedDecl *ActOnVariableDeclarator(Scope *S, Declarator &D, DeclContext *DC,
                                      TypeSourceInfo *TInfo,
@@ -2756,7 +2737,7 @@ public:
   void CheckCompleteDecompositionDeclaration(DecompositionDecl *DD);
   void MaybeSuggestAddingStaticToDecl(const FunctionDecl *D);
 
-  NamedDecl* ActOnFunctionDeclarator(Scope* S, Declarator& D, DeclContext* DC,
+  NamedDecl *ActOnFunctionDeclarator(Scope *S, Declarator &D, DeclContext *DC,
                                      TypeSourceInfo *TInfo,
                                      LookupResult &Previous,
                                      MultiTemplateParamsArg TemplateParamLists,
@@ -2775,13 +2756,15 @@ public:
                                         CheckConstexprKind Kind);
 
   void DiagnoseHiddenVirtualMethods(CXXMethodDecl *MD);
-  void FindHiddenVirtualMethods(CXXMethodDecl *MD,
-                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods);
-  void NoteHiddenVirtualMethods(CXXMethodDecl *MD,
-                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods);
+  void
+  FindHiddenVirtualMethods(CXXMethodDecl *MD,
+                           SmallVectorImpl<CXXMethodDecl *> &OverloadedMethods);
+  void
+  NoteHiddenVirtualMethods(CXXMethodDecl *MD,
+                           SmallVectorImpl<CXXMethodDecl *> &OverloadedMethods);
   // Returns true if the function declaration is a redeclaration
-  bool CheckFunctionDeclaration(Scope *S,
-                                FunctionDecl *NewFD, LookupResult &Previous,
+  bool CheckFunctionDeclaration(Scope *S, FunctionDecl *NewFD,
+                                LookupResult &Previous,
                                 bool IsMemberSpecialization);
   bool shouldLinkDependentDeclWithPrevious(Decl *D, Decl *OldDecl);
   bool canFullyTypeCheckRedeclaration(ValueDecl *NewD, ValueDecl *OldD,
@@ -2792,15 +2775,13 @@ public:
                                                    bool IsDefinition);
   void CheckFunctionOrTemplateParamDeclarator(Scope *S, Declarator &D);
   Decl *ActOnParamDeclarator(Scope *S, Declarator &D);
-  ParmVarDecl *BuildParmVarDeclForTypedef(DeclContext *DC,
-                                          SourceLocation Loc,
+  ParmVarDecl *BuildParmVarDeclForTypedef(DeclContext *DC, SourceLocation Loc,
                                           QualType T);
   ParmVarDecl *CheckParameter(DeclContext *DC, SourceLocation StartLoc,
                               SourceLocation NameLoc, IdentifierInfo *Name,
                               QualType T, TypeSourceInfo *TSInfo,
                               StorageClass SC);
-  void ActOnParamDefaultArgument(Decl *param,
-                                 SourceLocation EqualLoc,
+  void ActOnParamDefaultArgument(Decl *param, SourceLocation EqualLoc,
                                  Expr *defarg);
   void ActOnParamUnparsedDefaultArgument(Decl *param, SourceLocation EqualLoc,
                                          SourceLocation ArgLoc);
@@ -2889,9 +2870,7 @@ public:
   ExprResult ActOnFinishTrailingRequiresClause(ExprResult ConstraintExpr);
   ExprResult ActOnRequiresClause(ExprResult ConstraintExpr);
   void ActOnStartOfObjCMethodDef(Scope *S, Decl *D);
-  bool isObjCMethodDecl(Decl *D) {
-    return D && isa<ObjCMethodDecl>(D);
-  }
+  bool isObjCMethodDecl(Decl *D) { return D && isa<ObjCMethodDecl>(D); }
 
   /// Determine whether we can delay parsing the body of a function or
   /// function template until it is used, assuming we don't care about emitting
@@ -2934,8 +2913,7 @@ public:
                                          QualType ReturnTy, NamedDecl *D);
 
   void DiagnoseInvalidJumps(Stmt *Body);
-  Decl *ActOnFileScopeAsmDecl(Expr *expr,
-                              SourceLocation AsmLoc,
+  Decl *ActOnFileScopeAsmDecl(Expr *expr, SourceLocation AsmLoc,
                               SourceLocation RParenLoc);
 
   /// Handle a C++11 empty-declaration and attribute-declaration.
@@ -3047,8 +3025,7 @@ public:
                                    bool IsExplicitInstantiation,
                                    RecordDecl *&AnonRecord);
 
-  Decl *BuildAnonymousStructOrUnion(Scope *S, DeclSpec &DS,
-                                    AccessSpecifier AS,
+  Decl *BuildAnonymousStructOrUnion(Scope *S, DeclSpec &DS, AccessSpecifier AS,
                                     RecordDecl *Record,
                                     const PrintingPolicy &Policy);
 
@@ -3073,9 +3050,8 @@ public:
   /// what kind of non-tag type this is.
   NonTagKind getNonTagTypeDeclKind(const Decl *D, TagTypeKind TTK);
 
-  bool isAcceptableTagRedeclaration(const TagDecl *Previous,
-                                    TagTypeKind NewTag, bool isDefinition,
-                                    SourceLocation NewTagLoc,
+  bool isAcceptableTagRedeclaration(const TagDecl *Previous, TagTypeKind NewTag,
+                                    bool isDefinition, SourceLocation NewTagLoc,
                                     const IdentifierInfo *Name);
 
   enum TagUseKind {
@@ -3102,24 +3078,18 @@ public:
                                 const ParsedAttributesView &Attr,
                                 MultiTemplateParamsArg TempParamLists);
 
-  TypeResult ActOnDependentTag(Scope *S,
-                               unsigned TagSpec,
-                               TagUseKind TUK,
-                               const CXXScopeSpec &SS,
-                               IdentifierInfo *Name,
-                               SourceLocation TagLoc,
-                               SourceLocation NameLoc);
+  TypeResult ActOnDependentTag(Scope *S, unsigned TagSpec, TagUseKind TUK,
+                               const CXXScopeSpec &SS, IdentifierInfo *Name,
+                               SourceLocation TagLoc, SourceLocation NameLoc);
 
   void ActOnDefs(Scope *S, Decl *TagD, SourceLocation DeclStart,
-                 IdentifierInfo *ClassName,
-                 SmallVectorImpl<Decl *> &Decls);
+                 IdentifierInfo *ClassName, SmallVectorImpl<Decl *> &Decls);
   Decl *ActOnField(Scope *S, Decl *TagD, SourceLocation DeclStart,
                    Declarator &D, Expr *BitfieldWidth);
 
   FieldDecl *HandleField(Scope *S, RecordDecl *TagD, SourceLocation DeclStart,
                          Declarator &D, Expr *BitfieldWidth,
-                         InClassInitStyle InitStyle,
-                         AccessSpecifier AS);
+                         InClassInitStyle InitStyle, AccessSpecifier AS);
   MSPropertyDecl *HandleMSProperty(Scope *S, RecordDecl *TagD,
                                    SourceLocation DeclStart, Declarator &D,
                                    Expr *BitfieldWidth,
@@ -3128,13 +3098,11 @@ public:
                                    const ParsedAttr &MSPropertyAttr);
 
   FieldDecl *CheckFieldDecl(DeclarationName Name, QualType T,
-                            TypeSourceInfo *TInfo,
-                            RecordDecl *Record, SourceLocation Loc,
-                            bool Mutable, Expr *BitfieldWidth,
-                            InClassInitStyle InitStyle,
-                            SourceLocation TSSL,
-                            AccessSpecifier AS, NamedDecl *PrevDecl,
-                            Declarator *D = nullptr);
+                            TypeSourceInfo *TInfo, RecordDecl *Record,
+                            SourceLocation Loc, bool Mutable,
+                            Expr *BitfieldWidth, InClassInitStyle InitStyle,
+                            SourceLocation TSSL, AccessSpecifier AS,
+                            NamedDecl *PrevDecl, Declarator *D = nullptr);
 
   bool CheckNontrivialField(FieldDecl *FD);
   void DiagnoseNontrivial(const CXXRecordDecl *Record, CXXSpecialMember CSM);
@@ -3198,9 +3166,8 @@ public:
 
   void ActOnLastBitfield(SourceLocation DeclStart,
                          SmallVectorImpl<Decl *> &AllIvarDecls);
-  Decl *ActOnIvar(Scope *S, SourceLocation DeclStart,
-                  Declarator &D, Expr *BitfieldWidth,
-                  tok::ObjCKeywordKind visibility);
+  Decl *ActOnIvar(Scope *S, SourceLocation DeclStart, Declarator &D,
+                  Expr *BitfieldWidth, tok::ObjCKeywordKind visibility);
 
   // This is used for both record definitions and ObjC interface declarations.
   void ActOnFields(Scope *S, SourceLocation RecLoc, Decl *TagDecl,
@@ -3256,8 +3223,7 @@ public:
 
   EnumConstantDecl *CheckEnumConstant(EnumDecl *Enum,
                                       EnumConstantDecl *LastEnumConst,
-                                      SourceLocation IdLoc,
-                                      IdentifierInfo *Id,
+                                      SourceLocation IdLoc, IdentifierInfo *Id,
                                       Expr *val);
   bool CheckEnumUnderlyingType(TypeSourceInfo *TI);
   bool CheckEnumRedeclaration(SourceLocation EnumLoc, bool IsScoped,
@@ -3286,13 +3252,13 @@ public:
   void EnterDeclaratorContext(Scope *S, DeclContext *DC);
   void ExitDeclaratorContext(Scope *S);
 
-  /// Enter a template parameter scope, after it's been associated with a particular
-  /// DeclContext. Causes lookup within the scope to chain through enclosing contexts
-  /// in the correct order.
+  /// Enter a template parameter scope, after it's been associated with a
+  /// particular DeclContext. Causes lookup within the scope to chain through
+  /// enclosing contexts in the correct order.
   void EnterTemplatedContext(Scope *S, DeclContext *DC);
 
   /// Push the parameters of D, which must be a function, into scope.
-  void ActOnReenterFunctionContext(Scope* S, Decl* D);
+  void ActOnReenterFunctionContext(Scope *S, Decl *D);
   void ActOnExitFunctionContext();
 
   DeclContext *getFunctionLevelDeclContext();
@@ -3419,10 +3385,10 @@ public:
   InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D, const ParsedAttr &AL);
   InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D,
                                                 const InternalLinkageAttr &AL);
-  WebAssemblyImportNameAttr *mergeImportNameAttr(
-      Decl *D, const WebAssemblyImportNameAttr &AL);
-  WebAssemblyImportModuleAttr *mergeImportModuleAttr(
-      Decl *D, const WebAssemblyImportModuleAttr &AL);
+  WebAssemblyImportNameAttr *
+  mergeImportNameAttr(Decl *D, const WebAssemblyImportNameAttr &AL);
+  WebAssemblyImportModuleAttr *
+  mergeImportModuleAttr(Decl *D, const WebAssemblyImportModuleAttr &AL);
   EnforceTCBAttr *mergeEnforceTCBAttr(Decl *D, const EnforceTCBAttr &AL);
   EnforceTCBLeafAttr *mergeEnforceTCBLeafAttr(Decl *D,
                                               const EnforceTCBLeafAttr &AL);
@@ -3471,10 +3437,8 @@ public:
     /// non-function.
     Ovl_NonFunction
   };
-  OverloadKind CheckOverload(Scope *S,
-                             FunctionDecl *New,
-                             const LookupResult &OldDecls,
-                             NamedDecl *&OldDecl,
+  OverloadKind CheckOverload(Scope *S, FunctionDecl *New,
+                             const LookupResult &OldDecls, NamedDecl *&OldDecl,
                              bool IsForUsingDecl);
   bool IsOverload(FunctionDecl *New, FunctionDecl *Old, bool IsForUsingDecl,
                   bool ConsiderCudaAttrs = true,
@@ -3489,44 +3453,38 @@ public:
     All
   };
 
-  ImplicitConversionSequence
-  TryImplicitConversion(Expr *From, QualType ToType,
-                        bool SuppressUserConversions,
-                        AllowedExplicit AllowExplicit,
-                        bool InOverloadResolution,
-                        bool CStyle,
-                        bool AllowObjCWritebackConversion);
+  ImplicitConversionSequence TryImplicitConversion(
+      Expr *From, QualType ToType, bool SuppressUserConversions,
+      AllowedExplicit AllowExplicit, bool InOverloadResolution, bool CStyle,
+      bool AllowObjCWritebackConversion);
 
   bool IsIntegralPromotion(Expr *From, QualType FromType, QualType ToType);
   bool IsFloatingPointPromotion(QualType FromType, QualType ToType);
   bool IsComplexPromotion(QualType FromType, QualType ToType);
   bool IsPointerConversion(Expr *From, QualType FromType, QualType ToType,
-                           bool InOverloadResolution,
-                           QualType& ConvertedType, bool &IncompatibleObjC);
+                           bool InOverloadResolution, QualType &ConvertedType,
+                           bool &IncompatibleObjC);
   bool isObjCPointerConversion(QualType FromType, QualType ToType,
-                               QualType& ConvertedType, bool &IncompatibleObjC);
+                               QualType &ConvertedType, bool &IncompatibleObjC);
   bool isObjCWritebackConversion(QualType FromType, QualType ToType,
                                  QualType &ConvertedType);
   bool IsBlockPointerConversion(QualType FromType, QualType ToType,
-                                QualType& ConvertedType);
+                                QualType &ConvertedType);
   bool FunctionParamTypesAreEqual(const FunctionProtoType *OldType,
                                   const FunctionProtoType *NewType,
                                   unsigned *ArgPos = nullptr);
-  void HandleFunctionTypeMismatch(PartialDiagnostic &PDiag,
-                                  QualType FromType, QualType ToType);
+  void HandleFunctionTypeMismatch(PartialDiagnostic &PDiag, QualType FromType,
+                                  QualType ToType);
 
   void maybeExtendBlockObject(ExprResult &E);
   CastKind PrepareCastToObjCObjectPointer(ExprResult &E);
-  bool CheckPointerConversion(Expr *From, QualType ToType,
-                              CastKind &Kind,
-                              CXXCastPath& BasePath,
-                              bool IgnoreBaseAccess,
+  bool CheckPointerConversion(Expr *From, QualType ToType, CastKind &Kind,
+                              CXXCastPath &BasePath, bool IgnoreBaseAccess,
                               bool Diagnose = true);
   bool IsMemberPointerConversion(Expr *From, QualType FromType, QualType ToType,
                                  bool InOverloadResolution,
                                  QualType &ConvertedType);
-  bool CheckMemberPointerConversion(Expr *From, QualType ToType,
-                                    CastKind &Kind,
+  bool CheckMemberPointerConversion(Expr *From, QualType ToType, CastKind &Kind,
                                     CXXCastPath &BasePath,
                                     bool IgnoreBaseAccess);
   bool IsQualificationConversion(QualType FromType, QualType ToType,
@@ -3544,8 +3502,7 @@ public:
   bool CanPerformCopyInitialization(const InitializedEntity &Entity,
                                     ExprResult Init);
   ExprResult PerformCopyInitialization(const InitializedEntity &Entity,
-                                       SourceLocation EqualLoc,
-                                       ExprResult Init,
+                                       SourceLocation EqualLoc, ExprResult Init,
                                        bool TopLevelOfInitList = false,
                                        bool AllowExplicit = false);
   ExprResult PerformObjectArgumentInitialization(Expr *From,
@@ -3593,8 +3550,8 @@ public:
 
     /// Emits a diagnostic complaining that the expression does not have
     /// integral or enumeration type.
-    virtual SemaDiagnosticBuilder
-    diagnoseNoMatch(Sema &S, SourceLocation Loc, QualType T) = 0;
+    virtual SemaDiagnosticBuilder diagnoseNoMatch(Sema &S, SourceLocation Loc,
+                                                  QualType T) = 0;
 
     /// Emits a diagnostic when the expression has incomplete class type.
     virtual SemaDiagnosticBuilder
@@ -3602,8 +3559,10 @@ public:
 
     /// Emits a diagnostic when the only matching conversion function
     /// is explicit.
-    virtual SemaDiagnosticBuilder diagnoseExplicitConv(
-        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) = 0;
+    virtual SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S,
+                                                       SourceLocation Loc,
+                                                       QualType T,
+                                                       QualType ConvTy) = 0;
 
     /// Emits a note for the explicit conversion function.
     virtual SemaDiagnosticBuilder
@@ -3611,8 +3570,8 @@ public:
 
     /// Emits a diagnostic when there are multiple possible conversion
     /// functions.
-    virtual SemaDiagnosticBuilder
-    diagnoseAmbiguous(Sema &S, SourceLocation Loc, QualType T) = 0;
+    virtual SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
+                                                    QualType T) = 0;
 
     /// Emits a note for one of the candidate conversions.
     virtual SemaDiagnosticBuilder
@@ -3620,8 +3579,10 @@ public:
 
     /// Emits a diagnostic when we picked a conversion function
     /// (for cases when we are not allowed to pick a conversion function).
-    virtual SemaDiagnosticBuilder diagnoseConversion(
-        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) = 0;
+    virtual SemaDiagnosticBuilder diagnoseConversion(Sema &S,
+                                                     SourceLocation Loc,
+                                                     QualType T,
+                                                     QualType ConvTy) = 0;
 
     virtual ~ContextualImplicitConverter() {}
   };
@@ -3630,35 +3591,31 @@ public:
     bool AllowScopedEnumerations;
 
   public:
-    ICEConvertDiagnoser(bool AllowScopedEnumerations,
-                        bool Suppress, bool SuppressConversion)
+    ICEConvertDiagnoser(bool AllowScopedEnumerations, bool Suppress,
+                        bool SuppressConversion)
         : ContextualImplicitConverter(Suppress, SuppressConversion),
           AllowScopedEnumerations(AllowScopedEnumerations) {}
 
     /// Match an integral or (possibly scoped) enumeration type.
     bool match(QualType T) override;
 
-    SemaDiagnosticBuilder
-    diagnoseNoMatch(Sema &S, SourceLocation Loc, QualType T) override {
+    SemaDiagnosticBuilder diagnoseNoMatch(Sema &S, SourceLocation Loc,
+                                          QualType T) override {
       return diagnoseNotInt(S, Loc, T);
     }
 
     /// Emits a diagnostic complaining that the expression does not have
     /// integral or enumeration type.
-    virtual SemaDiagnosticBuilder
-    diagnoseNotInt(Sema &S, SourceLocation Loc, QualType T) = 0;
+    virtual SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
+                                                 QualType T) = 0;
   };
 
   /// Perform a contextual implicit conversion.
-  ExprResult PerformContextualImplicitConversion(
-      SourceLocation Loc, Expr *FromE, ContextualImplicitConverter &Converter);
-
+  ExprResult
+  PerformContextualImplicitConversion(SourceLocation Loc, Expr *FromE,
+                                      ContextualImplicitConverter &Converter);
 
-  enum ObjCSubscriptKind {
-    OS_Array,
-    OS_Dictionary,
-    OS_Error
-  };
+  enum ObjCSubscriptKind { OS_Array, OS_Dictionary, OS_Error };
   ObjCSubscriptKind CheckSubscriptingKind(Expr *FromE);
 
   // Note that LK_String is intentionally after the other literals, as
@@ -3681,7 +3638,7 @@ public:
 
   // Members have to be NamespaceDecl* or TranslationUnitDecl*.
   // TODO: make this is a typesafe union.
-  typedef llvm::SmallSetVector<DeclContext   *, 16> AssociatedNamespaceSet;
+  typedef llvm::SmallSetVector<DeclContext *, 16> AssociatedNamespaceSet;
   typedef llvm::SmallSetVector<CXXRecordDecl *, 16> AssociatedClassSet;
 
   using ADLCallKind = CallExpr::ADLCallKind;
@@ -3696,41 +3653,34 @@ public:
                             ADLCallKind IsADLCandidate = ADLCallKind::NotADL,
                             ConversionSequenceList EarlyConversions = None,
                             OverloadCandidateParamOrder PO = {});
-  void AddFunctionCandidates(const UnresolvedSetImpl &Functions,
-                      ArrayRef<Expr *> Args,
-                      OverloadCandidateSet &CandidateSet,
-                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr,
-                      bool SuppressUserConversions = false,
-                      bool PartialOverloading = false,
-                      bool FirstArgumentIsBase = false);
-  void AddMethodCandidate(DeclAccessPair FoundDecl,
-                          QualType ObjectType,
+  void AddFunctionCandidates(
+      const UnresolvedSetImpl &Functions, ArrayRef<Expr *> Args,
+      OverloadCandidateSet &CandidateSet,
+      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr,
+      bool SuppressUserConversions = false, bool PartialOverloading = false,
+      bool FirstArgumentIsBase = false);
+  void AddMethodCandidate(DeclAccessPair FoundDecl, QualType ObjectType,
                           Expr::Classification ObjectClassification,
                           ArrayRef<Expr *> Args,
-                          OverloadCandidateSet& CandidateSet,
+                          OverloadCandidateSet &CandidateSet,
                           bool SuppressUserConversion = false,
                           OverloadCandidateParamOrder PO = {});
-  void AddMethodCandidate(CXXMethodDecl *Method,
-                          DeclAccessPair FoundDecl,
+  void AddMethodCandidate(CXXMethodDecl *Method, DeclAccessPair FoundDecl,
                           CXXRecordDecl *ActingContext, QualType ObjectType,
                           Expr::Classification ObjectClassification,
                           ArrayRef<Expr *> Args,
-                          OverloadCandidateSet& CandidateSet,
+                          OverloadCandidateSet &CandidateSet,
                           bool SuppressUserConversions = false,
                           bool PartialOverloading = false,
                           ConversionSequenceList EarlyConversions = None,
                           OverloadCandidateParamOrder PO = {});
-  void AddMethodTemplateCandidate(FunctionTemplateDecl *MethodTmpl,
-                                  DeclAccessPair FoundDecl,
-                                  CXXRecordDecl *ActingContext,
-                                 TemplateArgumentListInfo *ExplicitTemplateArgs,
-                                  QualType ObjectType,
-                                  Expr::Classification ObjectClassification,
-                                  ArrayRef<Expr *> Args,
-                                  OverloadCandidateSet& CandidateSet,
-                                  bool SuppressUserConversions = false,
-                                  bool PartialOverloading = false,
-                                  OverloadCandidateParamOrder PO = {});
+  void AddMethodTemplateCandidate(
+      FunctionTemplateDecl *MethodTmpl, DeclAccessPair FoundDecl,
+      CXXRecordDecl *ActingContext,
+      TemplateArgumentListInfo *ExplicitTemplateArgs, QualType ObjectType,
+      Expr::Classification ObjectClassification, ArrayRef<Expr *> Args,
+      OverloadCandidateSet &CandidateSet, bool SuppressUserConversions = false,
+      bool PartialOverloading = false, OverloadCandidateParamOrder PO = {});
   void AddTemplateOverloadCandidate(
       FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,
       TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,
@@ -3758,9 +3708,9 @@ public:
   void AddSurrogateCandidate(CXXConversionDecl *Conversion,
                              DeclAccessPair FoundDecl,
                              CXXRecordDecl *ActingContext,
-                             const FunctionProtoType *Proto,
-                             Expr *Object, ArrayRef<Expr *> Args,
-                             OverloadCandidateSet& CandidateSet);
+                             const FunctionProtoType *Proto, Expr *Object,
+                             ArrayRef<Expr *> Args,
+                             OverloadCandidateSet &CandidateSet);
   void AddNonMemberOperatorCandidates(
       const UnresolvedSetImpl &Functions, ArrayRef<Expr *> Args,
       OverloadCandidateSet &CandidateSet,
@@ -3770,18 +3720,16 @@ public:
                                    OverloadCandidateSet &CandidateSet,
                                    OverloadCandidateParamOrder PO = {});
   void AddBuiltinCandidate(QualType *ParamTys, ArrayRef<Expr *> Args,
-                           OverloadCandidateSet& CandidateSet,
+                           OverloadCandidateSet &CandidateSet,
                            bool IsAssignmentOperator = false,
                            unsigned NumContextualBoolArguments = 0);
   void AddBuiltinOperatorCandidates(OverloadedOperatorKind Op,
                                     SourceLocation OpLoc, ArrayRef<Expr *> Args,
-                                    OverloadCandidateSet& CandidateSet);
-  void AddArgumentDependentLookupCandidates(DeclarationName Name,
-                                            SourceLocation Loc,
-                                            ArrayRef<Expr *> Args,
-                                TemplateArgumentListInfo *ExplicitTemplateArgs,
-                                            OverloadCandidateSet& CandidateSet,
-                                            bool PartialOverloading = false);
+                                    OverloadCandidateSet &CandidateSet);
+  void AddArgumentDependentLookupCandidates(
+      DeclarationName Name, SourceLocation Loc, ArrayRef<Expr *> Args,
+      TemplateArgumentListInfo *ExplicitTemplateArgs,
+      OverloadCandidateSet &CandidateSet, bool PartialOverloading = false);
 
   // Emit as a 'note' the specific overload candidate
   void NoteOverloadCandidate(
@@ -3843,10 +3791,8 @@ public:
   QualType ExtractUnqualifiedFunctionType(QualType PossiblyAFunctionType);
 
   FunctionDecl *
-  ResolveAddressOfOverloadedFunction(Expr *AddressOfExpr,
-                                     QualType TargetType,
-                                     bool Complain,
-                                     DeclAccessPair &Found,
+  ResolveAddressOfOverloadedFunction(Expr *AddressOfExpr, QualType TargetType,
+                                     bool Complain, DeclAccessPair &Found,
                                      bool *pHadMultipleCandidates = nullptr);
 
   FunctionDecl *
@@ -3861,16 +3807,12 @@ public:
                                               DeclAccessPair *Found = nullptr);
 
   bool ResolveAndFixSingleFunctionTemplateSpecialization(
-                      ExprResult &SrcExpr,
-                      bool DoFunctionPointerConverion = false,
-                      bool Complain = false,
-                      SourceRange OpRangeForComplaining = SourceRange(),
-                      QualType DestTypeForComplaining = QualType(),
-                      unsigned DiagIDForComplaining = 0);
+      ExprResult &SrcExpr, bool DoFunctionPointerConverion = false,
+      bool Complain = false, SourceRange OpRangeForComplaining = SourceRange(),
+      QualType DestTypeForComplaining = QualType(),
+      unsigned DiagIDForComplaining = 0);
 
-
-  Expr *FixOverloadedFunctionReference(Expr *E,
-                                       DeclAccessPair FoundDecl,
+  Expr *FixOverloadedFunctionReference(Expr *E, DeclAccessPair FoundDecl,
                                        FunctionDecl *Fn);
   ExprResult FixOverloadedFunctionReference(ExprResult,
                                             DeclAccessPair FoundDecl,
@@ -3899,14 +3841,10 @@ public:
                                            OverloadCandidateSet *CandidateSet,
                                            Expr *Range, ExprResult *CallExpr);
 
-  ExprResult BuildOverloadedCallExpr(Scope *S, Expr *Fn,
-                                     UnresolvedLookupExpr *ULE,
-                                     SourceLocation LParenLoc,
-                                     MultiExprArg Args,
-                                     SourceLocation RParenLoc,
-                                     Expr *ExecConfig,
-                                     bool AllowTypoCorrection=true,
-                                     bool CalleesAddressIsTaken=false);
+  ExprResult BuildOverloadedCallExpr(
+      Scope *S, Expr *Fn, UnresolvedLookupExpr *ULE, SourceLocation LParenLoc,
+      MultiExprArg Args, SourceLocation RParenLoc, Expr *ExecConfig,
+      bool AllowTypoCorrection = true, bool CalleesAddressIsTaken = false);
 
   bool buildOverloadedCallSet(Scope *S, Expr *Fn, UnresolvedLookupExpr *ULE,
                               MultiExprArg Args, SourceLocation RParenLoc,
@@ -3921,18 +3859,16 @@ public:
 
   ExprResult CreateOverloadedUnaryOp(SourceLocation OpLoc,
                                      UnaryOperatorKind Opc,
-                                     const UnresolvedSetImpl &Fns,
-                                     Expr *input, bool RequiresADL = true);
+                                     const UnresolvedSetImpl &Fns, Expr *input,
+                                     bool RequiresADL = true);
 
   void LookupOverloadedBinOp(OverloadCandidateSet &CandidateSet,
                              OverloadedOperatorKind Op,
                              const UnresolvedSetImpl &Fns,
                              ArrayRef<Expr *> Args, bool RequiresADL = true);
-  ExprResult CreateOverloadedBinOp(SourceLocation OpLoc,
-                                   BinaryOperatorKind Opc,
-                                   const UnresolvedSetImpl &Fns,
-                                   Expr *LHS, Expr *RHS,
-                                   bool RequiresADL = true,
+  ExprResult CreateOverloadedBinOp(SourceLocation OpLoc, BinaryOperatorKind Opc,
+                                   const UnresolvedSetImpl &Fns, Expr *LHS,
+                                   Expr *RHS, bool RequiresADL = true,
                                    bool AllowRewrittenCandidates = true,
                                    FunctionDecl *DefaultedFn = nullptr);
   ExprResult BuildSynthesizedThreeWayComparison(SourceLocation OpLoc,
@@ -3941,20 +3877,17 @@ public:
                                                 FunctionDecl *DefaultedFn);
 
   ExprResult CreateOverloadedArraySubscriptExpr(SourceLocation LLoc,
-                                                SourceLocation RLoc,
-                                                Expr *Base,Expr *Idx);
+                                                SourceLocation RLoc, Expr *Base,
+                                                Expr *Idx);
 
-  ExprResult BuildCallToMemberFunction(Scope *S, Expr *MemExpr,
-                                       SourceLocation LParenLoc,
-                                       MultiExprArg Args,
-                                       SourceLocation RParenLoc,
-                                       Expr *ExecConfig = nullptr,
-                                       bool IsExecConfig = false,
-                                       bool AllowRecovery = false);
-  ExprResult
-  BuildCallToObjectOfClassType(Scope *S, Expr *Object, SourceLocation LParenLoc,
-                               MultiExprArg Args,
-                               SourceLocation RParenLoc);
+  ExprResult BuildCallToMemberFunction(
+      Scope *S, Expr *MemExpr, SourceLocation LParenLoc, MultiExprArg Args,
+      SourceLocation RParenLoc, Expr *ExecConfig = nullptr,
+      bool IsExecConfig = false, bool AllowRecovery = false);
+  ExprResult BuildCallToObjectOfClassType(Scope *S, Expr *Object,
+                                          SourceLocation LParenLoc,
+                                          MultiExprArg Args,
+                                          SourceLocation RParenLoc);
 
   ExprResult BuildOverloadedArrowExpr(Scope *S, Expr *Base,
                                       SourceLocation OpLoc,
@@ -4074,7 +4007,7 @@ public:
     // the context has internal linkage, redeclaration lookup won't find things
     // from other TUs, and we can't safely compute linkage yet in general.
     if (cast<Decl>(CurContext)
-            ->getOwningModuleForLinkage(/*IgnoreLinkage*/true))
+            ->getOwningModuleForLinkage(/*IgnoreLinkage*/ true))
       return ForVisibleRedeclaration;
     return ForExternalRedeclaration;
   }
@@ -4101,13 +4034,10 @@ public:
     LOLR_StringTemplatePack,
   };
 
-  SpecialMemberOverloadResult LookupSpecialMember(CXXRecordDecl *D,
-                                                  CXXSpecialMember SM,
-                                                  bool ConstArg,
-                                                  bool VolatileArg,
-                                                  bool RValueThis,
-                                                  bool ConstThis,
-                                                  bool VolatileThis);
+  SpecialMemberOverloadResult
+  LookupSpecialMember(CXXRecordDecl *D, CXXSpecialMember SM, bool ConstArg,
+                      bool VolatileArg, bool RValueThis, bool ConstThis,
+                      bool VolatileThis);
 
   typedef std::function<void(const TypoCorrection &)> TypoDiagnosticGenerator;
   typedef std::function<ExprResult(Sema &, TypoExpr *, TypoCorrection)>
@@ -4137,7 +4067,7 @@ private:
   //
   // The boolean value will be true to indicate that the namespace was loaded
   // from an AST/PCH file, or false otherwise.
-  llvm::MapVector<NamespaceDecl*, bool> KnownNamespaces;
+  llvm::MapVector<NamespaceDecl *, bool> KnownNamespaces;
 
   /// Whether we have already loaded known namespaces from an extenal
   /// source.
@@ -4146,14 +4076,11 @@ private:
   /// Helper for CorrectTypo and CorrectTypoDelayed used to create and
   /// populate a new TypoCorrectionConsumer. Returns nullptr if typo correction
   /// should be skipped entirely.
-  std::unique_ptr<TypoCorrectionConsumer>
-  makeTypoCorrectionConsumer(const DeclarationNameInfo &Typo,
-                             Sema::LookupNameKind LookupKind, Scope *S,
-                             CXXScopeSpec *SS,
-                             CorrectionCandidateCallback &CCC,
-                             DeclContext *MemberContext, bool EnteringContext,
-                             const ObjCObjectPointerType *OPT,
-                             bool ErrorRecovery);
+  std::unique_ptr<TypoCorrectionConsumer> makeTypoCorrectionConsumer(
+      const DeclarationNameInfo &Typo, Sema::LookupNameKind LookupKind,
+      Scope *S, CXXScopeSpec *SS, CorrectionCandidateCallback &CCC,
+      DeclContext *MemberContext, bool EnteringContext,
+      const ObjCObjectPointerType *OPT, bool ErrorRecovery);
 
 public:
   const TypoExprState &getTypoExprState(TypoExpr *TE) const;
@@ -4167,14 +4094,11 @@ public:
   /// It is preferable to use the elaborated form and explicitly handle
   /// ambiguity and overloaded.
   NamedDecl *LookupSingleName(Scope *S, DeclarationName Name,
-                              SourceLocation Loc,
-                              LookupNameKind NameKind,
-                              RedeclarationKind Redecl
-                                = NotForRedeclaration);
+                              SourceLocation Loc, LookupNameKind NameKind,
+                              RedeclarationKind Redecl = NotForRedeclaration);
   bool LookupBuiltin(LookupResult &R);
   void LookupNecessaryTypesForBuiltin(Scope *S, unsigned ID);
-  bool LookupName(LookupResult &R, Scope *S,
-                  bool AllowBuiltinCreation = false);
+  bool LookupName(LookupResult &R, Scope *S, bool AllowBuiltinCreation = false);
   bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,
                            bool InUnqualifiedLookup = false);
   bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,
@@ -4182,9 +4106,9 @@ public:
   bool LookupParsedName(LookupResult &R, Scope *S, CXXScopeSpec *SS,
                         bool AllowBuiltinCreation = false,
                         bool EnteringContext = false);
-  ObjCProtocolDecl *LookupProtocol(IdentifierInfo *II, SourceLocation IdLoc,
-                                   RedeclarationKind Redecl
-                                     = NotForRedeclaration);
+  ObjCProtocolDecl *
+  LookupProtocol(IdentifierInfo *II, SourceLocation IdLoc,
+                 RedeclarationKind Redecl = NotForRedeclaration);
   bool LookupInSuper(LookupResult &R, CXXRecordDecl *Class);
 
   void LookupOverloadedOperatorName(OverloadedOperatorKind Op, Scope *S,
@@ -4247,24 +4171,20 @@ public:
   };
 
   TypoCorrection CorrectTypo(const DeclarationNameInfo &Typo,
-                             Sema::LookupNameKind LookupKind,
-                             Scope *S, CXXScopeSpec *SS,
-                             CorrectionCandidateCallback &CCC,
+                             Sema::LookupNameKind LookupKind, Scope *S,
+                             CXXScopeSpec *SS, CorrectionCandidateCallback &CCC,
                              CorrectTypoKind Mode,
                              DeclContext *MemberContext = nullptr,
                              bool EnteringContext = false,
                              const ObjCObjectPointerType *OPT = nullptr,
                              bool RecordFailure = true);
 
-  TypoExpr *CorrectTypoDelayed(const DeclarationNameInfo &Typo,
-                               Sema::LookupNameKind LookupKind, Scope *S,
-                               CXXScopeSpec *SS,
-                               CorrectionCandidateCallback &CCC,
-                               TypoDiagnosticGenerator TDG,
-                               TypoRecoveryCallback TRC, CorrectTypoKind Mode,
-                               DeclContext *MemberContext = nullptr,
-                               bool EnteringContext = false,
-                               const ObjCObjectPointerType *OPT = nullptr);
+  TypoExpr *CorrectTypoDelayed(
+      const DeclarationNameInfo &Typo, Sema::LookupNameKind LookupKind,
+      Scope *S, CXXScopeSpec *SS, CorrectionCandidateCallback &CCC,
+      TypoDiagnosticGenerator TDG, TypoRecoveryCallback TRC,
+      CorrectTypoKind Mode, DeclContext *MemberContext = nullptr,
+      bool EnteringContext = false, const ObjCObjectPointerType *OPT = nullptr);
 
   /// Process any TypoExprs in the given Expr and its children,
   /// generating diagnostics as appropriate and returning a new Expr if there
@@ -4311,10 +4231,10 @@ public:
 
   void MarkTypoCorrectedFunctionDefinition(const NamedDecl *F);
 
-  void FindAssociatedClassesAndNamespaces(SourceLocation InstantiationLoc,
-                                          ArrayRef<Expr *> Args,
-                                   AssociatedNamespaceSet &AssociatedNamespaces,
-                                   AssociatedClassSet &AssociatedClasses);
+  void FindAssociatedClassesAndNamespaces(
+      SourceLocation InstantiationLoc, ArrayRef<Expr *> Args,
+      AssociatedNamespaceSet &AssociatedNamespaces,
+      AssociatedClassSet &AssociatedClasses);
 
   void FilterLookupForScope(LookupResult &R, DeclContext *Ctx, Scope *S,
                             bool ConsiderLinkage, bool AllowInlineNamespace);
@@ -4336,9 +4256,8 @@ public:
                                           bool TypoCorrection = false);
   FunctionDecl *CreateBuiltin(IdentifierInfo *II, QualType Type, unsigned ID,
                               SourceLocation Loc);
-  NamedDecl *LazilyCreateBuiltin(IdentifierInfo *II, unsigned ID,
-                                 Scope *S, bool ForRedeclaration,
-                                 SourceLocation Loc);
+  NamedDecl *LazilyCreateBuiltin(IdentifierInfo *II, unsigned ID, Scope *S,
+                                 bool ForRedeclaration, SourceLocation Loc);
   NamedDecl *ImplicitlyDefineFunction(SourceLocation Loc, IdentifierInfo &II,
                                       Scope *S);
   void AddKnownFunctionAttributesForReplaceableGlobalAllocationFunction(
@@ -4353,10 +4272,11 @@ public:
   // Helper for delayed processing of attributes.
   void ProcessDeclAttributeDelayed(Decl *D,
                                    const ParsedAttributesView &AttrList);
-  void ProcessDeclAttributeList(Scope *S, Decl *D, const ParsedAttributesView &AL,
-                             bool IncludeCXX11Attributes = true);
+  void ProcessDeclAttributeList(Scope *S, Decl *D,
+                                const ParsedAttributesView &AL,
+                                bool IncludeCXX11Attributes = true);
   bool ProcessAccessDeclAttributeList(AccessSpecDecl *ASDecl,
-                                   const ParsedAttributesView &AttrList);
+                                      const ParsedAttributesView &AttrList);
 
   void checkUnusedDeclAttributes(Declarator &D);
 
@@ -4388,9 +4308,9 @@ public:
                                    const StringLiteral *Literal,
                                    bool &HasDefault, bool &HasCommas,
                                    SmallVectorImpl<StringRef> &Strings);
-  bool checkMSInheritanceAttrOnDefinition(
-      CXXRecordDecl *RD, SourceRange Range, bool BestCase,
-      MSInheritanceModel SemanticSpelling);
+  bool checkMSInheritanceAttrOnDefinition(CXXRecordDecl *RD, SourceRange Range,
+                                          bool BestCase,
+                                          MSInheritanceModel SemanticSpelling);
 
   void CheckAlignasUnderalignment(Decl *D);
 
@@ -4420,13 +4340,12 @@ public:
                                    bool IsProtocolMethodDecl);
 
   void CheckConflictingOverridingMethod(ObjCMethodDecl *Method,
-                                   ObjCMethodDecl *Overridden,
-                                   bool IsProtocolMethodDecl);
+                                        ObjCMethodDecl *Overridden,
+                                        bool IsProtocolMethodDecl);
 
   /// WarnExactTypedMethods - This routine issues a warning if method
   /// implementation declaration matches exactly that of its declaration.
-  void WarnExactTypedMethods(ObjCMethodDecl *Method,
-                             ObjCMethodDecl *MethodDecl,
+  void WarnExactTypedMethods(ObjCMethodDecl *Method, ObjCMethodDecl *MethodDecl,
                              bool IsProtocolMethodDecl);
 
   typedef llvm::SmallPtrSet<Selector, 8> SelectorSet;
@@ -4439,13 +4358,13 @@ public:
 
   /// ImplMethodsVsClassMethods - This is main routine to warn if any method
   /// remains unimplemented in the class or category \@implementation.
-  void ImplMethodsVsClassMethods(Scope *S, ObjCImplDecl* IMPDecl,
-                                 ObjCContainerDecl* IDecl,
+  void ImplMethodsVsClassMethods(Scope *S, ObjCImplDecl *IMPDecl,
+                                 ObjCContainerDecl *IDecl,
                                  bool IncompleteImpl = false);
 
   /// DiagnoseUnimplementedProperties - This routine warns on those properties
   /// which must be implemented by this implementation.
-  void DiagnoseUnimplementedProperties(Scope *S, ObjCImplDecl* IMPDecl,
+  void DiagnoseUnimplementedProperties(Scope *S, ObjCImplDecl *IMPDecl,
                                        ObjCContainerDecl *CDecl,
                                        bool SynthesizeProperties);
 
@@ -4465,71 +4384,54 @@ public:
   bool IvarBacksCurrentMethodAccessor(ObjCInterfaceDecl *IFace,
                                       ObjCMethodDecl *Method, ObjCIvarDecl *IV);
 
-  /// DiagnoseUnusedBackingIvarInAccessor - Issue an 'unused' warning if ivar which
-  /// backs the property is not used in the property's accessor.
+  /// DiagnoseUnusedBackingIvarInAccessor - Issue an 'unused' warning if ivar
+  /// which backs the property is not used in the property's accessor.
   void DiagnoseUnusedBackingIvarInAccessor(Scope *S,
                                            const ObjCImplementationDecl *ImplD);
 
   /// GetIvarBackingPropertyAccessor - If method is a property setter/getter and
-  /// it property has a backing ivar, returns this ivar; otherwise, returns NULL.
-  /// It also returns ivar's property on success.
-  ObjCIvarDecl *GetIvarBackingPropertyAccessor(const ObjCMethodDecl *Method,
-                                               const ObjCPropertyDecl *&PDecl) const;
+  /// it property has a backing ivar, returns this ivar; otherwise, returns
+  /// NULL. It also returns ivar's property on success.
+  ObjCIvarDecl *
+  GetIvarBackingPropertyAccessor(const ObjCMethodDecl *Method,
+                                 const ObjCPropertyDecl *&PDecl) const;
 
   /// Called by ActOnProperty to handle \@property declarations in
   /// class extensions.
-  ObjCPropertyDecl *HandlePropertyInClassExtension(Scope *S,
-                      SourceLocation AtLoc,
-                      SourceLocation LParenLoc,
-                      FieldDeclarator &FD,
-                      Selector GetterSel,
-                      SourceLocation GetterNameLoc,
-                      Selector SetterSel,
-                      SourceLocation SetterNameLoc,
-                      const bool isReadWrite,
-                      unsigned &Attributes,
-                      const unsigned AttributesAsWritten,
-                      QualType T,
-                      TypeSourceInfo *TSI,
-                      tok::ObjCKeywordKind MethodImplKind);
+  ObjCPropertyDecl *HandlePropertyInClassExtension(
+      Scope *S, SourceLocation AtLoc, SourceLocation LParenLoc,
+      FieldDeclarator &FD, Selector GetterSel, SourceLocation GetterNameLoc,
+      Selector SetterSel, SourceLocation SetterNameLoc, const bool isReadWrite,
+      unsigned &Attributes, const unsigned AttributesAsWritten, QualType T,
+      TypeSourceInfo *TSI, tok::ObjCKeywordKind MethodImplKind);
 
   /// Called by ActOnProperty and HandlePropertyInClassExtension to
   /// handle creating the ObjcPropertyDecl for a category or \@interface.
-  ObjCPropertyDecl *CreatePropertyDecl(Scope *S,
-                                       ObjCContainerDecl *CDecl,
-                                       SourceLocation AtLoc,
-                                       SourceLocation LParenLoc,
-                                       FieldDeclarator &FD,
-                                       Selector GetterSel,
-                                       SourceLocation GetterNameLoc,
-                                       Selector SetterSel,
-                                       SourceLocation SetterNameLoc,
-                                       const bool isReadWrite,
-                                       const unsigned Attributes,
-                                       const unsigned AttributesAsWritten,
-                                       QualType T,
-                                       TypeSourceInfo *TSI,
-                                       tok::ObjCKeywordKind MethodImplKind,
-                                       DeclContext *lexicalDC = nullptr);
+  ObjCPropertyDecl *
+  CreatePropertyDecl(Scope *S, ObjCContainerDecl *CDecl, SourceLocation AtLoc,
+                     SourceLocation LParenLoc, FieldDeclarator &FD,
+                     Selector GetterSel, SourceLocation GetterNameLoc,
+                     Selector SetterSel, SourceLocation SetterNameLoc,
+                     const bool isReadWrite, const unsigned Attributes,
+                     const unsigned AttributesAsWritten, QualType T,
+                     TypeSourceInfo *TSI, tok::ObjCKeywordKind MethodImplKind,
+                     DeclContext *lexicalDC = nullptr);
 
   /// AtomicPropertySetterGetterRules - This routine enforces the rule (via
   /// warning) when atomic property has one but not the other user-declared
   /// setter or getter.
-  void AtomicPropertySetterGetterRules(ObjCImplDecl* IMPDecl,
-                                       ObjCInterfaceDecl* IDecl);
+  void AtomicPropertySetterGetterRules(ObjCImplDecl *IMPDecl,
+                                       ObjCInterfaceDecl *IDecl);
 
   void DiagnoseOwningPropertyGetterSynthesis(const ObjCImplementationDecl *D);
 
-  void DiagnoseMissingDesignatedInitOverrides(
-                                          const ObjCImplementationDecl *ImplD,
-                                          const ObjCInterfaceDecl *IFD);
+  void
+  DiagnoseMissingDesignatedInitOverrides(const ObjCImplementationDecl *ImplD,
+                                         const ObjCInterfaceDecl *IFD);
 
   void DiagnoseDuplicateIvars(ObjCInterfaceDecl *ID, ObjCInterfaceDecl *SID);
 
-  enum MethodMatchStrategy {
-    MMS_loose,
-    MMS_strict
-  };
+  enum MethodMatchStrategy { MMS_loose, MMS_strict };
 
   /// MatchTwoMethodDeclarations - Checks if two methods' type match and returns
   /// true, or false, accordingly.
@@ -4539,15 +4441,11 @@ public:
 
   /// MatchAllMethodDeclarations - Check methods declaraed in interface or
   /// or protocol against those declared in their implementations.
-  void MatchAllMethodDeclarations(const SelectorSet &InsMap,
-                                  const SelectorSet &ClsMap,
-                                  SelectorSet &InsMapSeen,
-                                  SelectorSet &ClsMapSeen,
-                                  ObjCImplDecl* IMPDecl,
-                                  ObjCContainerDecl* IDecl,
-                                  bool &IncompleteImpl,
-                                  bool ImmediateClass,
-                                  bool WarnCategoryMethodImpl=false);
+  void MatchAllMethodDeclarations(
+      const SelectorSet &InsMap, const SelectorSet &ClsMap,
+      SelectorSet &InsMapSeen, SelectorSet &ClsMapSeen, ObjCImplDecl *IMPDecl,
+      ObjCContainerDecl *IDecl, bool &IncompleteImpl, bool ImmediateClass,
+      bool WarnCategoryMethodImpl = false);
 
   /// CheckCategoryVsClassMethodMatches - Checks that methods implemented in
   /// category matches with those implemented in its primary class and
@@ -4579,17 +4477,17 @@ public:
   /// returns true.
   bool
   CollectMultipleMethodsInGlobalPool(Selector Sel,
-                                     SmallVectorImpl<ObjCMethodDecl*>& Methods,
+                                     SmallVectorImpl<ObjCMethodDecl *> &Methods,
                                      bool InstanceFirst, bool CheckTheOther,
                                      const ObjCObjectType *TypeBound = nullptr);
 
   bool
   AreMultipleMethodsInGlobalPool(Selector Sel, ObjCMethodDecl *BestMethod,
                                  SourceRange R, bool receiverIdOrClass,
-                                 SmallVectorImpl<ObjCMethodDecl*>& Methods);
+                                 SmallVectorImpl<ObjCMethodDecl *> &Methods);
 
   void
-  DiagnoseMultipleMethodInGlobalPool(SmallVectorImpl<ObjCMethodDecl*> &Methods,
+  DiagnoseMultipleMethodInGlobalPool(SmallVectorImpl<ObjCMethodDecl *> &Methods,
                                      Selector Sel, SourceRange R,
                                      bool receiverIdOrClass);
 
@@ -4598,8 +4496,7 @@ private:
   /// nullptr if none could be found
   ObjCMethodDecl *SelectBestMethod(Selector Sel, MultiExprArg Args,
                                    bool IsInstance,
-                                   SmallVectorImpl<ObjCMethodDecl*>& Methods);
-
+                                   SmallVectorImpl<ObjCMethodDecl *> &Methods);
 
   /// Record the typo correction failure and return an empty correction.
   TypoCorrection FailedCorrection(IdentifierInfo *Typo, SourceLocation TypoLoc,
@@ -4614,13 +4511,14 @@ public:
   /// unit are added to a global pool. This allows us to efficiently associate
   /// a selector with a method declaraation for purposes of typechecking
   /// messages sent to "id" (where the class of the object is unknown).
-  void AddInstanceMethodToGlobalPool(ObjCMethodDecl *Method, bool impl=false) {
-    AddMethodToGlobalPool(Method, impl, /*instance*/true);
+  void AddInstanceMethodToGlobalPool(ObjCMethodDecl *Method,
+                                     bool impl = false) {
+    AddMethodToGlobalPool(Method, impl, /*instance*/ true);
   }
 
   /// AddFactoryMethodToGlobalPool - Same as above, but for factory methods.
-  void AddFactoryMethodToGlobalPool(ObjCMethodDecl *Method, bool impl=false) {
-    AddMethodToGlobalPool(Method, impl, /*instance*/false);
+  void AddFactoryMethodToGlobalPool(ObjCMethodDecl *Method, bool impl = false) {
+    AddMethodToGlobalPool(Method, impl, /*instance*/ false);
   }
 
   /// AddAnyMethodToGlobalPool - Add any method, instance or factory to global
@@ -4629,48 +4527,47 @@ public:
 
   /// LookupInstanceMethodInGlobalPool - Returns the method and warns if
   /// there are multiple signatures.
-  ObjCMethodDecl *LookupInstanceMethodInGlobalPool(Selector Sel, SourceRange R,
-                                                   bool receiverIdOrClass=false) {
+  ObjCMethodDecl *
+  LookupInstanceMethodInGlobalPool(Selector Sel, SourceRange R,
+                                   bool receiverIdOrClass = false) {
     return LookupMethodInGlobalPool(Sel, R, receiverIdOrClass,
-                                    /*instance*/true);
+                                    /*instance*/ true);
   }
 
   /// LookupFactoryMethodInGlobalPool - Returns the method and warns if
   /// there are multiple signatures.
-  ObjCMethodDecl *LookupFactoryMethodInGlobalPool(Selector Sel, SourceRange R,
-                                                  bool receiverIdOrClass=false) {
+  ObjCMethodDecl *
+  LookupFactoryMethodInGlobalPool(Selector Sel, SourceRange R,
+                                  bool receiverIdOrClass = false) {
     return LookupMethodInGlobalPool(Sel, R, receiverIdOrClass,
-                                    /*instance*/false);
+                                    /*instance*/ false);
   }
 
-  const ObjCMethodDecl *SelectorsForTypoCorrection(Selector Sel,
-                              QualType ObjectType=QualType());
+  const ObjCMethodDecl *
+  SelectorsForTypoCorrection(Selector Sel, QualType ObjectType = QualType());
   /// LookupImplementedMethodInGlobalPool - Returns the method which has an
   /// implementation.
   ObjCMethodDecl *LookupImplementedMethodInGlobalPool(Selector Sel);
 
   /// CollectIvarsToConstructOrDestruct - Collect those ivars which require
   /// initialization.
-  void CollectIvarsToConstructOrDestruct(ObjCInterfaceDecl *OI,
-                                  SmallVectorImpl<ObjCIvarDecl*> &Ivars);
+  void
+  CollectIvarsToConstructOrDestruct(ObjCInterfaceDecl *OI,
+                                    SmallVectorImpl<ObjCIvarDecl *> &Ivars);
 
   //===--------------------------------------------------------------------===//
   // Statement Parsing Callbacks: SemaStmt.cpp.
 public:
   class FullExprArg {
   public:
-    FullExprArg() : E(nullptr) { }
-    FullExprArg(Sema &actions) : E(nullptr) { }
+    FullExprArg() : E(nullptr) {}
+    FullExprArg(Sema &actions) : E(nullptr) {}
 
-    ExprResult release() {
-      return E;
-    }
+    ExprResult release() { return E; }
 
     Expr *get() const { return E; }
 
-    Expr *operator->() {
-      return E;
-    }
+    Expr *operator->() { return E; }
 
   private:
     // FIXME: No need to make the entire Sema class a friend when it's just
@@ -4715,9 +4612,7 @@ public:
       S.ActOnStartOfCompoundStmt(IsStmtExpr);
     }
 
-    ~CompoundScopeRAII() {
-      S.ActOnFinishOfCompoundStmt();
-    }
+    ~CompoundScopeRAII() { S.ActOnFinishOfCompoundStmt(); }
 
   private:
     Sema &S;
@@ -4735,9 +4630,8 @@ public:
     void disable() { Active = false; }
   };
 
-  StmtResult ActOnDeclStmt(DeclGroupPtrTy Decl,
-                                   SourceLocation StartLoc,
-                                   SourceLocation EndLoc);
+  StmtResult ActOnDeclStmt(DeclGroupPtrTy Decl, SourceLocation StartLoc,
+                           SourceLocation EndLoc);
   void ActOnForEachDeclStmt(DeclGroupPtrTy Decl);
   StmtResult ActOnForEachLValueExpr(Expr *E);
   ExprResult ActOnCaseExpr(SourceLocation CaseLoc, ExprResult Val);
@@ -4747,8 +4641,8 @@ public:
   void ActOnCaseStmtBody(Stmt *CaseStmt, Stmt *SubStmt);
 
   StmtResult ActOnDefaultStmt(SourceLocation DefaultLoc,
-                                      SourceLocation ColonLoc,
-                                      Stmt *SubStmt, Scope *CurScope);
+                              SourceLocation ColonLoc, Stmt *SubStmt,
+                              Scope *CurScope);
   StmtResult ActOnLabelStmt(SourceLocation IdentLoc, LabelDecl *TheDecl,
                             SourceLocation ColonLoc, Stmt *SubStmt);
 
@@ -4771,8 +4665,8 @@ public:
                                     SourceLocation LParenLoc, Stmt *InitStmt,
                                     ConditionResult Cond,
                                     SourceLocation RParenLoc);
-  StmtResult ActOnFinishSwitchStmt(SourceLocation SwitchLoc,
-                                           Stmt *Switch, Stmt *Body);
+  StmtResult ActOnFinishSwitchStmt(SourceLocation SwitchLoc, Stmt *Switch,
+                                   Stmt *Body);
   StmtResult ActOnWhileStmt(SourceLocation WhileLoc, SourceLocation LParenLoc,
                             ConditionResult Cond, SourceLocation RParenLoc,
                             Stmt *Body);
@@ -4780,17 +4674,14 @@ public:
                          SourceLocation WhileLoc, SourceLocation CondLParen,
                          Expr *Cond, SourceLocation CondRParen);
 
-  StmtResult ActOnForStmt(SourceLocation ForLoc,
-                          SourceLocation LParenLoc,
-                          Stmt *First,
-                          ConditionResult Second,
-                          FullExprArg Third,
-                          SourceLocation RParenLoc,
+  StmtResult ActOnForStmt(SourceLocation ForLoc, SourceLocation LParenLoc,
+                          Stmt *First, ConditionResult Second,
+                          FullExprArg Third, SourceLocation RParenLoc,
                           Stmt *Body);
   ExprResult CheckObjCForCollectionOperand(SourceLocation forLoc,
                                            Expr *collection);
-  StmtResult ActOnObjCForCollectionStmt(SourceLocation ForColLoc,
-                                        Stmt *First, Expr *collection,
+  StmtResult ActOnObjCForCollectionStmt(SourceLocation ForColLoc, Stmt *First,
+                                        Expr *collection,
                                         SourceLocation RParenLoc);
   StmtResult FinishObjCForCollectionStmt(Stmt *ForCollection, Stmt *Body);
 
@@ -4806,29 +4697,22 @@ public:
   };
 
   StmtResult ActOnCXXForRangeStmt(Scope *S, SourceLocation ForLoc,
-                                  SourceLocation CoawaitLoc,
-                                  Stmt *InitStmt,
-                                  Stmt *LoopVar,
-                                  SourceLocation ColonLoc, Expr *Collection,
-                                  SourceLocation RParenLoc,
+                                  SourceLocation CoawaitLoc, Stmt *InitStmt,
+                                  Stmt *LoopVar, SourceLocation ColonLoc,
+                                  Expr *Collection, SourceLocation RParenLoc,
                                   BuildForRangeKind Kind);
   StmtResult BuildCXXForRangeStmt(SourceLocation ForLoc,
-                                  SourceLocation CoawaitLoc,
-                                  Stmt *InitStmt,
-                                  SourceLocation ColonLoc,
-                                  Stmt *RangeDecl, Stmt *Begin, Stmt *End,
-                                  Expr *Cond, Expr *Inc,
-                                  Stmt *LoopVarDecl,
-                                  SourceLocation RParenLoc,
+                                  SourceLocation CoawaitLoc, Stmt *InitStmt,
+                                  SourceLocation ColonLoc, Stmt *RangeDecl,
+                                  Stmt *Begin, Stmt *End, Expr *Cond, Expr *Inc,
+                                  Stmt *LoopVarDecl, SourceLocation RParenLoc,
                                   BuildForRangeKind Kind);
   StmtResult FinishCXXForRangeStmt(Stmt *ForRange, Stmt *Body);
 
-  StmtResult ActOnGotoStmt(SourceLocation GotoLoc,
-                           SourceLocation LabelLoc,
+  StmtResult ActOnGotoStmt(SourceLocation GotoLoc, SourceLocation LabelLoc,
                            LabelDecl *TheDecl);
   StmtResult ActOnIndirectGotoStmt(SourceLocation GotoLoc,
-                                   SourceLocation StarLoc,
-                                   Expr *DestExp);
+                                   SourceLocation StarLoc, Expr *DestExp);
   StmtResult ActOnContinueStmt(SourceLocation ContinueLoc, Scope *CurScope);
   StmtResult ActOnBreakStmt(SourceLocation BreakLoc, Scope *CurScope);
 
@@ -4879,8 +4763,7 @@ public:
                              unsigned NumInputs, IdentifierInfo **Names,
                              MultiExprArg Constraints, MultiExprArg Exprs,
                              Expr *AsmString, MultiExprArg Clobbers,
-                             unsigned NumLabels,
-                             SourceLocation RParenLoc);
+                             unsigned NumLabels, SourceLocation RParenLoc);
 
   void FillInlineAsmIdentifierInfo(Expr *Res,
                                    llvm::InlineAsmIdentifierInfo &Info);
@@ -4888,26 +4771,22 @@ public:
                                        SourceLocation TemplateKWLoc,
                                        UnqualifiedId &Id,
                                        bool IsUnevaluatedContext);
-  bool LookupInlineAsmField(StringRef Base, StringRef Member,
-                            unsigned &Offset, SourceLocation AsmLoc);
+  bool LookupInlineAsmField(StringRef Base, StringRef Member, unsigned &Offset,
+                            SourceLocation AsmLoc);
   ExprResult LookupInlineAsmVarDeclField(Expr *RefExpr, StringRef Member,
                                          SourceLocation AsmLoc);
   StmtResult ActOnMSAsmStmt(SourceLocation AsmLoc, SourceLocation LBraceLoc,
-                            ArrayRef<Token> AsmToks,
-                            StringRef AsmString,
+                            ArrayRef<Token> AsmToks, StringRef AsmString,
                             unsigned NumOutputs, unsigned NumInputs,
                             ArrayRef<StringRef> Constraints,
                             ArrayRef<StringRef> Clobbers,
-                            ArrayRef<Expr*> Exprs,
-                            SourceLocation EndLoc);
+                            ArrayRef<Expr *> Exprs, SourceLocation EndLoc);
   LabelDecl *GetOrCreateMSAsmLabel(StringRef ExternalLabelName,
-                                   SourceLocation Location,
-                                   bool AlwaysCreate);
+                                   SourceLocation Location, bool AlwaysCreate);
 
   VarDecl *BuildObjCExceptionDecl(TypeSourceInfo *TInfo, QualType ExceptionType,
-                                  SourceLocation StartLoc,
-                                  SourceLocation IdLoc, IdentifierInfo *Id,
-                                  bool Invalid = false);
+                                  SourceLocation StartLoc, SourceLocation IdLoc,
+                                  IdentifierInfo *Id, bool Invalid = false);
 
   Decl *ActOnObjCExceptionDecl(Scope *S, Declarator &D);
 
@@ -4924,29 +4803,26 @@ public:
                                   Scope *CurScope);
   ExprResult ActOnObjCAtSynchronizedOperand(SourceLocation atLoc,
                                             Expr *operand);
-  StmtResult ActOnObjCAtSynchronizedStmt(SourceLocation AtLoc,
-                                         Expr *SynchExpr,
+  StmtResult ActOnObjCAtSynchronizedStmt(SourceLocation AtLoc, Expr *SynchExpr,
                                          Stmt *SynchBody);
 
   StmtResult ActOnObjCAutoreleasePoolStmt(SourceLocation AtLoc, Stmt *Body);
 
   VarDecl *BuildExceptionDeclaration(Scope *S, TypeSourceInfo *TInfo,
                                      SourceLocation StartLoc,
-                                     SourceLocation IdLoc,
-                                     IdentifierInfo *Id);
+                                     SourceLocation IdLoc, IdentifierInfo *Id);
 
   Decl *ActOnExceptionDeclarator(Scope *S, Declarator &D);
 
-  StmtResult ActOnCXXCatchBlock(SourceLocation CatchLoc,
-                                Decl *ExDecl, Stmt *HandlerBlock);
+  StmtResult ActOnCXXCatchBlock(SourceLocation CatchLoc, Decl *ExDecl,
+                                Stmt *HandlerBlock);
   StmtResult ActOnCXXTryBlock(SourceLocation TryLoc, Stmt *TryBlock,
                               ArrayRef<Stmt *> Handlers);
 
   StmtResult ActOnSEHTryBlock(bool IsCXXTry, // try (true) or __try (false) ?
                               SourceLocation TryLoc, Stmt *TryBlock,
                               Stmt *Handler);
-  StmtResult ActOnSEHExceptBlock(SourceLocation Loc,
-                                 Expr *FilterExpr,
+  StmtResult ActOnSEHExceptBlock(SourceLocation Loc, Expr *FilterExpr,
                                  Stmt *Block);
   void ActOnStartSEHFinallyBlock();
   void ActOnAbortSEHFinallyBlock();
@@ -4977,14 +4853,12 @@ public:
   /// This helps prevent bugs due to typos, such as:
   ///     if (condition);
   ///       do_stuff();
-  void DiagnoseEmptyStmtBody(SourceLocation StmtLoc,
-                             const Stmt *Body,
+  void DiagnoseEmptyStmtBody(SourceLocation StmtLoc, const Stmt *Body,
                              unsigned DiagID);
 
   /// Warn if a for/while loop statement \p S, which is followed by
   /// \p PossibleBody, has a suspicious null statement as a body.
-  void DiagnoseEmptyLoopBody(const Stmt *S,
-                             const Stmt *PossibleBody);
+  void DiagnoseEmptyLoopBody(const Stmt *S, const Stmt *PossibleBody);
 
   /// Warn if a value is moved to itself.
   void DiagnoseSelfMove(const Expr *LHSExpr, const Expr *RHSExpr,
@@ -5094,7 +4968,9 @@ public:
   void CleanupVarDeclMarking();
 
   enum TryCaptureKind {
-    TryCapture_Implicit, TryCapture_ExplicitByVal, TryCapture_ExplicitByRef
+    TryCapture_Implicit,
+    TryCapture_ExplicitByVal,
+    TryCapture_ExplicitByRef
   };
 
   /// Try to capture the given variable.
@@ -5132,8 +5008,7 @@ public:
   /// captured) and false if the capture succeeded.
   bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc, TryCaptureKind Kind,
                           SourceLocation EllipsisLoc, bool BuildAndDiagnose,
-                          QualType &CaptureType,
-                          QualType &DeclRefType,
+                          QualType &CaptureType, QualType &DeclRefType,
                           const unsigned *const FunctionScopeIndexToStopAt);
 
   /// Try to capture the given variable.
@@ -5192,17 +5067,18 @@ public:
                            const PartialDiagnostic &PD);
   /// Similar, but diagnostic is only produced if all the specified statements
   /// are reachable.
-  bool DiagRuntimeBehavior(SourceLocation Loc, ArrayRef<const Stmt*> Stmts,
+  bool DiagRuntimeBehavior(SourceLocation Loc, ArrayRef<const Stmt *> Stmts,
                            const PartialDiagnostic &PD);
 
   // Primary Expressions.
   SourceRange getExprRange(Expr *E) const;
 
-  ExprResult ActOnIdExpression(
-      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-      UnqualifiedId &Id, bool HasTrailingLParen, bool IsAddressOfOperand,
-      CorrectionCandidateCallback *CCC = nullptr,
-      bool IsInlineAsmIdentifier = false, Token *KeywordReplacement = nullptr);
+  ExprResult ActOnIdExpression(Scope *S, CXXScopeSpec &SS,
+                               SourceLocation TemplateKWLoc, UnqualifiedId &Id,
+                               bool HasTrailingLParen, bool IsAddressOfOperand,
+                               CorrectionCandidateCallback *CCC = nullptr,
+                               bool IsInlineAsmIdentifier = false,
+                               Token *KeywordReplacement = nullptr);
 
   void DecomposeUnqualifiedId(const UnqualifiedId &Id,
                               TemplateArgumentListInfo &Buffer,
@@ -5223,13 +5099,12 @@ public:
 
   ExprResult LookupInObjCMethod(LookupResult &LookUp, Scope *S,
                                 IdentifierInfo *II,
-                                bool AllowBuiltinCreation=false);
+                                bool AllowBuiltinCreation = false);
 
-  ExprResult ActOnDependentIdExpression(const CXXScopeSpec &SS,
-                                        SourceLocation TemplateKWLoc,
-                                        const DeclarationNameInfo &NameInfo,
-                                        bool isAddressOfOperand,
-                                const TemplateArgumentListInfo *TemplateArgs);
+  ExprResult ActOnDependentIdExpression(
+      const CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
+      const DeclarationNameInfo &NameInfo, bool isAddressOfOperand,
+      const TemplateArgumentListInfo *TemplateArgs);
 
   /// If \p D cannot be odr-used in the current expression evaluation context,
   /// return a reason explaining why. Otherwise, return NOUR_None.
@@ -5248,32 +5123,26 @@ public:
   DeclRefExpr *
   BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,
                    const DeclarationNameInfo &NameInfo,
-                   NestedNameSpecifierLoc NNS,
-                   NamedDecl *FoundD = nullptr,
+                   NestedNameSpecifierLoc NNS, NamedDecl *FoundD = nullptr,
                    SourceLocation TemplateKWLoc = SourceLocation(),
                    const TemplateArgumentListInfo *TemplateArgs = nullptr);
 
-  ExprResult
-  BuildAnonymousStructUnionMemberReference(
-      const CXXScopeSpec &SS,
-      SourceLocation nameLoc,
+  ExprResult BuildAnonymousStructUnionMemberReference(
+      const CXXScopeSpec &SS, SourceLocation nameLoc,
       IndirectFieldDecl *indirectField,
       DeclAccessPair FoundDecl = DeclAccessPair::make(nullptr, AS_none),
-      Expr *baseObjectExpr = nullptr,
-      SourceLocation opLoc = SourceLocation());
+      Expr *baseObjectExpr = nullptr, SourceLocation opLoc = SourceLocation());
 
   ExprResult BuildPossibleImplicitMemberExpr(
       const CXXScopeSpec &SS, SourceLocation TemplateKWLoc, LookupResult &R,
       const TemplateArgumentListInfo *TemplateArgs, const Scope *S,
       UnresolvedLookupExpr *AsULE = nullptr);
-  ExprResult BuildImplicitMemberExpr(const CXXScopeSpec &SS,
-                                     SourceLocation TemplateKWLoc,
-                                     LookupResult &R,
-                                const TemplateArgumentListInfo *TemplateArgs,
-                                     bool IsDefiniteInstance,
-                                     const Scope *S);
-  bool UseArgumentDependentLookup(const CXXScopeSpec &SS,
-                                  const LookupResult &R,
+  ExprResult
+  BuildImplicitMemberExpr(const CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
+                          LookupResult &R,
+                          const TemplateArgumentListInfo *TemplateArgs,
+                          bool IsDefiniteInstance, const Scope *S);
+  bool UseArgumentDependentLookup(const CXXScopeSpec &SS, const LookupResult &R,
                                   bool HasTrailingLParen);
 
   ExprResult
@@ -5282,13 +5151,13 @@ public:
                                     bool IsAddressOfOperand, const Scope *S,
                                     TypeSourceInfo **RecoveryTSI = nullptr);
 
-  ExprResult BuildDependentDeclRefExpr(const CXXScopeSpec &SS,
-                                       SourceLocation TemplateKWLoc,
-                                const DeclarationNameInfo &NameInfo,
-                                const TemplateArgumentListInfo *TemplateArgs);
+  ExprResult
+  BuildDependentDeclRefExpr(const CXXScopeSpec &SS,
+                            SourceLocation TemplateKWLoc,
+                            const DeclarationNameInfo &NameInfo,
+                            const TemplateArgumentListInfo *TemplateArgs);
 
-  ExprResult BuildDeclarationNameExpr(const CXXScopeSpec &SS,
-                                      LookupResult &R,
+  ExprResult BuildDeclarationNameExpr(const CXXScopeSpec &SS, LookupResult &R,
                                       bool NeedsADL,
                                       bool AcceptInvalidDecl = false);
   ExprResult BuildDeclarationNameExpr(
@@ -5297,11 +5166,10 @@ public:
       const TemplateArgumentListInfo *TemplateArgs = nullptr,
       bool AcceptInvalidDecl = false);
 
-  ExprResult BuildLiteralOperatorCall(LookupResult &R,
-                      DeclarationNameInfo &SuffixInfo,
-                      ArrayRef<Expr *> Args,
-                      SourceLocation LitEndLoc,
-                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);
+  ExprResult BuildLiteralOperatorCall(
+      LookupResult &R, DeclarationNameInfo &SuffixInfo, ArrayRef<Expr *> Args,
+      SourceLocation LitEndLoc,
+      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);
 
   ExprResult BuildPredefinedExpr(SourceLocation Loc,
                                  PredefinedExpr::IdentKind IK);
@@ -5323,8 +5191,7 @@ public:
   ExprResult ActOnCharacterConstant(const Token &Tok,
                                     Scope *UDLScope = nullptr);
   ExprResult ActOnParenExpr(SourceLocation L, SourceLocation R, Expr *E);
-  ExprResult ActOnParenListExpr(SourceLocation L,
-                                SourceLocation R,
+  ExprResult ActOnParenListExpr(SourceLocation L, SourceLocation R,
                                 MultiExprArg Val);
 
   /// ActOnStringLiteral - The specified tokens were lexed as pasted string
@@ -5348,10 +5215,10 @@ public:
   // Binary/Unary Operators.  'Tok' is the token for the operator.
   ExprResult CreateBuiltinUnaryOp(SourceLocation OpLoc, UnaryOperatorKind Opc,
                                   Expr *InputExpr);
-  ExprResult BuildUnaryOp(Scope *S, SourceLocation OpLoc,
-                          UnaryOperatorKind Opc, Expr *Input);
-  ExprResult ActOnUnaryOp(Scope *S, SourceLocation OpLoc,
-                          tok::TokenKind Op, Expr *Input);
+  ExprResult BuildUnaryOp(Scope *S, SourceLocation OpLoc, UnaryOperatorKind Opc,
+                          Expr *Input);
+  ExprResult ActOnUnaryOp(Scope *S, SourceLocation OpLoc, tok::TokenKind Op,
+                          Expr *Input);
 
   bool isQualifiedMemberAccess(Expr *E);
   QualType CheckAddressOfOperand(ExprResult &Operand, SourceLocation OpLoc);
@@ -5362,11 +5229,10 @@ public:
                                             SourceRange R);
   ExprResult CreateUnaryExprOrTypeTraitExpr(Expr *E, SourceLocation OpLoc,
                                             UnaryExprOrTypeTrait ExprKind);
-  ExprResult
-    ActOnUnaryExprOrTypeTraitExpr(SourceLocation OpLoc,
-                                  UnaryExprOrTypeTrait ExprKind,
-                                  bool IsType, void *TyOrEx,
-                                  SourceRange ArgRange);
+  ExprResult ActOnUnaryExprOrTypeTraitExpr(SourceLocation OpLoc,
+                                           UnaryExprOrTypeTrait ExprKind,
+                                           bool IsType, void *TyOrEx,
+                                           SourceRange ArgRange);
 
   ExprResult CheckPlaceholderExpr(Expr *E);
   bool CheckVecStepExpr(Expr *E);
@@ -5375,8 +5241,7 @@ public:
   bool CheckUnaryExprOrTypeTraitOperand(QualType ExprType, SourceLocation OpLoc,
                                         SourceRange ExprRange,
                                         UnaryExprOrTypeTrait ExprKind);
-  ExprResult ActOnSizeofParameterPackExpr(Scope *S,
-                                          SourceLocation OpLoc,
+  ExprResult ActOnSizeofParameterPackExpr(Scope *S, SourceLocation OpLoc,
                                           IdentifierInfo &Name,
                                           SourceLocation NameLoc,
                                           SourceLocation RParenLoc);
@@ -5433,8 +5298,7 @@ public:
       Expr *Base, QualType BaseType, SourceLocation OpLoc, bool IsArrow,
       CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
       NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,
-      const TemplateArgumentListInfo *TemplateArgs,
-      const Scope *S,
+      const TemplateArgumentListInfo *TemplateArgs, const Scope *S,
       ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);
 
   ExprResult
@@ -5443,8 +5307,7 @@ public:
                            SourceLocation TemplateKWLoc,
                            NamedDecl *FirstQualifierInScope, LookupResult &R,
                            const TemplateArgumentListInfo *TemplateArgs,
-                           const Scope *S,
-                           bool SuppressQualifierCheck = false,
+                           const Scope *S, bool SuppressQualifierCheck = false,
                            ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);
 
   ExprResult BuildFieldReferenceExpr(Expr *BaseExpr, bool IsArrow,
@@ -5459,30 +5322,23 @@ public:
                                      const CXXScopeSpec &SS,
                                      const LookupResult &R);
 
-  ExprResult ActOnDependentMemberExpr(Expr *Base, QualType BaseType,
-                                      bool IsArrow, SourceLocation OpLoc,
-                                      const CXXScopeSpec &SS,
-                                      SourceLocation TemplateKWLoc,
-                                      NamedDecl *FirstQualifierInScope,
-                               const DeclarationNameInfo &NameInfo,
-                               const TemplateArgumentListInfo *TemplateArgs);
+  ExprResult ActOnDependentMemberExpr(
+      Expr *Base, QualType BaseType, bool IsArrow, SourceLocation OpLoc,
+      const CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
+      NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,
+      const TemplateArgumentListInfo *TemplateArgs);
 
-  ExprResult ActOnMemberAccessExpr(Scope *S, Expr *Base,
-                                   SourceLocation OpLoc,
-                                   tok::TokenKind OpKind,
-                                   CXXScopeSpec &SS,
+  ExprResult ActOnMemberAccessExpr(Scope *S, Expr *Base, SourceLocation OpLoc,
+                                   tok::TokenKind OpKind, CXXScopeSpec &SS,
                                    SourceLocation TemplateKWLoc,
-                                   UnqualifiedId &Member,
-                                   Decl *ObjCImpDecl);
+                                   UnqualifiedId &Member, Decl *ObjCImpDecl);
 
-  MemberExpr *
-  BuildMemberExpr(Expr *Base, bool IsArrow, SourceLocation OpLoc,
-                  const CXXScopeSpec *SS, SourceLocation TemplateKWLoc,
-                  ValueDecl *Member, DeclAccessPair FoundDecl,
-                  bool HadMultipleCandidates,
-                  const DeclarationNameInfo &MemberNameInfo, QualType Ty,
-                  ExprValueKind VK, ExprObjectKind OK,
-                  const TemplateArgumentListInfo *TemplateArgs = nullptr);
+  MemberExpr *BuildMemberExpr(
+      Expr *Base, bool IsArrow, SourceLocation OpLoc, const CXXScopeSpec *SS,
+      SourceLocation TemplateKWLoc, ValueDecl *Member, DeclAccessPair FoundDecl,
+      bool HadMultipleCandidates, const DeclarationNameInfo &MemberNameInfo,
+      QualType Ty, ExprValueKind VK, ExprObjectKind OK,
+      const TemplateArgumentListInfo *TemplateArgs = nullptr);
   MemberExpr *
   BuildMemberExpr(Expr *Base, bool IsArrow, SourceLocation OpLoc,
                   NestedNameSpecifierLoc NNS, SourceLocation TemplateKWLoc,
@@ -5493,14 +5349,11 @@ public:
                   const TemplateArgumentListInfo *TemplateArgs = nullptr);
 
   void ActOnDefaultCtorInitializers(Decl *CDtorDecl);
-  bool ConvertArgumentsForCall(CallExpr *Call, Expr *Fn,
-                               FunctionDecl *FDecl,
+  bool ConvertArgumentsForCall(CallExpr *Call, Expr *Fn, FunctionDecl *FDecl,
                                const FunctionProtoType *Proto,
-                               ArrayRef<Expr *> Args,
-                               SourceLocation RParenLoc,
+                               ArrayRef<Expr *> Args, SourceLocation RParenLoc,
                                bool ExecConfig = false);
-  void CheckStaticArrayArgument(SourceLocation CallLoc,
-                                ParmVarDecl *Param,
+  void CheckStaticArrayArgument(SourceLocation CallLoc, ParmVarDecl *Param,
                                 const Expr *ArgExpr);
 
   /// ActOnCallExpr - Handle a call to Fn with the specified array of arguments.
@@ -5532,13 +5385,11 @@ public:
                                      MultiExprArg ExecConfig,
                                      SourceLocation GGGLoc);
 
-  ExprResult ActOnCastExpr(Scope *S, SourceLocation LParenLoc,
-                           Declarator &D, ParsedType &Ty,
-                           SourceLocation RParenLoc, Expr *CastExpr);
-  ExprResult BuildCStyleCastExpr(SourceLocation LParenLoc,
-                                 TypeSourceInfo *Ty,
-                                 SourceLocation RParenLoc,
-                                 Expr *Op);
+  ExprResult ActOnCastExpr(Scope *S, SourceLocation LParenLoc, Declarator &D,
+                           ParsedType &Ty, SourceLocation RParenLoc,
+                           Expr *CastExpr);
+  ExprResult BuildCStyleCastExpr(SourceLocation LParenLoc, TypeSourceInfo *Ty,
+                                 SourceLocation RParenLoc, Expr *Op);
   CastKind PrepareScalarCast(ExprResult &src, QualType destType);
 
   /// Build an altivec or OpenCL literal.
@@ -5548,37 +5399,32 @@ public:
 
   ExprResult MaybeConvertParenListExprToParenExpr(Scope *S, Expr *ME);
 
-  ExprResult ActOnCompoundLiteral(SourceLocation LParenLoc,
-                                  ParsedType Ty,
-                                  SourceLocation RParenLoc,
-                                  Expr *InitExpr);
+  ExprResult ActOnCompoundLiteral(SourceLocation LParenLoc, ParsedType Ty,
+                                  SourceLocation RParenLoc, Expr *InitExpr);
 
   ExprResult BuildCompoundLiteralExpr(SourceLocation LParenLoc,
                                       TypeSourceInfo *TInfo,
                                       SourceLocation RParenLoc,
                                       Expr *LiteralExpr);
 
-  ExprResult ActOnInitList(SourceLocation LBraceLoc,
-                           MultiExprArg InitArgList,
+  ExprResult ActOnInitList(SourceLocation LBraceLoc, MultiExprArg InitArgList,
                            SourceLocation RBraceLoc);
 
-  ExprResult BuildInitList(SourceLocation LBraceLoc,
-                           MultiExprArg InitArgList,
+  ExprResult BuildInitList(SourceLocation LBraceLoc, MultiExprArg InitArgList,
                            SourceLocation RBraceLoc);
 
   ExprResult ActOnDesignatedInitializer(Designation &Desig,
                                         SourceLocation EqualOrColonLoc,
-                                        bool GNUSyntax,
-                                        ExprResult Init);
+                                        bool GNUSyntax, ExprResult Init);
 
 private:
   static BinaryOperatorKind ConvertTokenKindToBinaryOpcode(tok::TokenKind Kind);
 
 public:
-  ExprResult ActOnBinOp(Scope *S, SourceLocation TokLoc,
-                        tok::TokenKind Kind, Expr *LHSExpr, Expr *RHSExpr);
-  ExprResult BuildBinOp(Scope *S, SourceLocation OpLoc,
-                        BinaryOperatorKind Opc, Expr *LHSExpr, Expr *RHSExpr);
+  ExprResult ActOnBinOp(Scope *S, SourceLocation TokLoc, tok::TokenKind Kind,
+                        Expr *LHSExpr, Expr *RHSExpr);
+  ExprResult BuildBinOp(Scope *S, SourceLocation OpLoc, BinaryOperatorKind Opc,
+                        Expr *LHSExpr, Expr *RHSExpr);
   ExprResult CreateBuiltinBinOp(SourceLocation OpLoc, BinaryOperatorKind Opc,
                                 Expr *LHSExpr, Expr *RHSExpr);
   void LookupBinOp(Scope *S, SourceLocation OpLoc, BinaryOperatorKind Opc,
@@ -5589,8 +5435,8 @@ public:
   /// ActOnConditionalOp - Parse a ?: operation.  Note that 'LHS' may be null
   /// in the case of a the GNU conditional expr extension.
   ExprResult ActOnConditionalOp(SourceLocation QuestionLoc,
-                                SourceLocation ColonLoc,
-                                Expr *CondExpr, Expr *LHSExpr, Expr *RHSExpr);
+                                SourceLocation ColonLoc, Expr *CondExpr,
+                                Expr *LHSExpr, Expr *RHSExpr);
 
   /// ActOnAddrLabel - Parse the GNU address of label extension: "&&foo".
   ExprResult ActOnAddrLabel(SourceLocation OpLoc, SourceLocation LabLoc,
@@ -5608,7 +5454,7 @@ public:
   // __builtin_offsetof(type, identifier(.identifier|[expr])*)
   struct OffsetOfComponent {
     SourceLocation LocStart, LocEnd;
-    bool isBrackets;  // true if [expr], false if .ident
+    bool isBrackets; // true if [expr], false if .ident
     union {
       IdentifierInfo *IdentInfo;
       Expr *E;
@@ -5620,17 +5466,16 @@ public:
                                   TypeSourceInfo *TInfo,
                                   ArrayRef<OffsetOfComponent> Components,
                                   SourceLocation RParenLoc);
-  ExprResult ActOnBuiltinOffsetOf(Scope *S,
-                                  SourceLocation BuiltinLoc,
+  ExprResult ActOnBuiltinOffsetOf(Scope *S, SourceLocation BuiltinLoc,
                                   SourceLocation TypeLoc,
                                   ParsedType ParsedArgTy,
                                   ArrayRef<OffsetOfComponent> Components,
                                   SourceLocation RParenLoc);
 
   // __builtin_choose_expr(constExpr, expr1, expr2)
-  ExprResult ActOnChooseExpr(SourceLocation BuiltinLoc,
-                             Expr *CondExpr, Expr *LHSExpr,
-                             Expr *RHSExpr, SourceLocation RPLoc);
+  ExprResult ActOnChooseExpr(SourceLocation BuiltinLoc, Expr *CondExpr,
+                             Expr *LHSExpr, Expr *RHSExpr,
+                             SourceLocation RPLoc);
 
   // __builtin_va_arg(expr, type)
   ExprResult ActOnVAArg(SourceLocation BuiltinLoc, Expr *E, ParsedType Ty,
@@ -5674,10 +5519,10 @@ public:
   CheckMicrosoftIfExistsSymbol(Scope *S, CXXScopeSpec &SS,
                                const DeclarationNameInfo &TargetNameInfo);
 
-  IfExistsResult
-  CheckMicrosoftIfExistsSymbol(Scope *S, SourceLocation KeywordLoc,
-                               bool IsIfExists, CXXScopeSpec &SS,
-                               UnqualifiedId &Name);
+  IfExistsResult CheckMicrosoftIfExistsSymbol(Scope *S,
+                                              SourceLocation KeywordLoc,
+                                              bool IsIfExists, CXXScopeSpec &SS,
+                                              UnqualifiedId &Name);
 
   StmtResult BuildMSDependentExistsStmt(SourceLocation KeywordLoc,
                                         bool IsIfExists,
@@ -5685,9 +5530,8 @@ public:
                                         DeclarationNameInfo NameInfo,
                                         Stmt *Nested);
   StmtResult ActOnMSDependentExistsStmt(SourceLocation KeywordLoc,
-                                        bool IsIfExists,
-                                        CXXScopeSpec &SS, UnqualifiedId &Name,
-                                        Stmt *Nested);
+                                        bool IsIfExists, CXXScopeSpec &SS,
+                                        UnqualifiedId &Name, Stmt *Nested);
 
   //===------------------------- "Block" Extension ------------------------===//
 
@@ -5800,12 +5644,9 @@ public:
 
   void PushUsingDirective(Scope *S, UsingDirectiveDecl *UDir);
 
-  Decl *ActOnNamespaceAliasDef(Scope *CurScope,
-                               SourceLocation NamespaceLoc,
-                               SourceLocation AliasLoc,
-                               IdentifierInfo *Alias,
-                               CXXScopeSpec &SS,
-                               SourceLocation IdentLoc,
+  Decl *ActOnNamespaceAliasDef(Scope *CurScope, SourceLocation NamespaceLoc,
+                               SourceLocation AliasLoc, IdentifierInfo *Alias,
+                               CXXScopeSpec &SS, SourceLocation IdentLoc,
                                IdentifierInfo *Ident);
 
   void FilterUsingLookup(Scope *S, LookupResult &lookup);
@@ -5829,12 +5670,14 @@ public:
                                const LookupResult *R = nullptr,
                                const UsingDecl *UD = nullptr);
 
-  NamedDecl *BuildUsingDeclaration(
-      Scope *S, AccessSpecifier AS, SourceLocation UsingLoc,
-      bool HasTypenameKeyword, SourceLocation TypenameLoc, CXXScopeSpec &SS,
-      DeclarationNameInfo NameInfo, SourceLocation EllipsisLoc,
-      const ParsedAttributesView &AttrList, bool IsInstantiation,
-      bool IsUsingIfExists);
+  NamedDecl *BuildUsingDeclaration(Scope *S, AccessSpecifier AS,
+                                   SourceLocation UsingLoc,
+                                   bool HasTypenameKeyword,
+                                   SourceLocation TypenameLoc, CXXScopeSpec &SS,
+                                   DeclarationNameInfo NameInfo,
+                                   SourceLocation EllipsisLoc,
+                                   const ParsedAttributesView &AttrList,
+                                   bool IsInstantiation, bool IsUsingIfExists);
   NamedDecl *BuildUsingEnumDeclaration(Scope *S, AccessSpecifier AS,
                                        SourceLocation UsingLoc,
                                        SourceLocation EnumLoc,
@@ -5871,38 +5714,34 @@ public:
   /// \param ConstructKind - a CXXConstructExpr::ConstructionKind
   ExprResult
   BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,
-                        NamedDecl *FoundDecl,
-                        CXXConstructorDecl *Constructor, MultiExprArg Exprs,
-                        bool HadMultipleCandidates, bool IsListInitialization,
-                        bool IsStdInitListInitialization,
-                        bool RequiresZeroInit, unsigned ConstructKind,
-                        SourceRange ParenRange);
+                        NamedDecl *FoundDecl, CXXConstructorDecl *Constructor,
+                        MultiExprArg Exprs, bool HadMultipleCandidates,
+                        bool IsListInitialization,
+                        bool IsStdInitListInitialization, bool RequiresZeroInit,
+                        unsigned ConstructKind, SourceRange ParenRange);
 
   /// Build a CXXConstructExpr whose constructor has already been resolved if
   /// it denotes an inherited constructor.
   ExprResult
   BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,
                         CXXConstructorDecl *Constructor, bool Elidable,
-                        MultiExprArg Exprs,
-                        bool HadMultipleCandidates, bool IsListInitialization,
-                        bool IsStdInitListInitialization,
-                        bool RequiresZeroInit, unsigned ConstructKind,
-                        SourceRange ParenRange);
+                        MultiExprArg Exprs, bool HadMultipleCandidates,
+                        bool IsListInitialization,
+                        bool IsStdInitListInitialization, bool RequiresZeroInit,
+                        unsigned ConstructKind, SourceRange ParenRange);
 
   // FIXME: Can we remove this and have the above BuildCXXConstructExpr check if
   // the constructor can be elidable?
   ExprResult
   BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,
-                        NamedDecl *FoundDecl,
-                        CXXConstructorDecl *Constructor, bool Elidable,
-                        MultiExprArg Exprs, bool HadMultipleCandidates,
-                        bool IsListInitialization,
+                        NamedDecl *FoundDecl, CXXConstructorDecl *Constructor,
+                        bool Elidable, MultiExprArg Exprs,
+                        bool HadMultipleCandidates, bool IsListInitialization,
                         bool IsStdInitListInitialization, bool RequiresZeroInit,
                         unsigned ConstructKind, SourceRange ParenRange);
 
   ExprResult BuildCXXDefaultInitExpr(SourceLocation Loc, FieldDecl *Field);
 
-
   /// Instantiate or parse a C++ default argument expression as necessary.
   /// Return true on error.
   bool CheckCXXDefaultArgExpr(SourceLocation CallLoc, FunctionDecl *FD,
@@ -5910,8 +5749,7 @@ public:
 
   /// BuildCXXDefaultArgExpr - Creates a CXXDefaultArgExpr, instantiating
   /// the default expr if needed.
-  ExprResult BuildCXXDefaultArgExpr(SourceLocation CallLoc,
-                                    FunctionDecl *FD,
+  ExprResult BuildCXXDefaultArgExpr(SourceLocation CallLoc, FunctionDecl *FD,
                                     ParmVarDecl *Param);
 
   /// FinalizeVarWithDestructor - Prepare for calling destructor on the
@@ -5940,7 +5778,7 @@ public:
 
   public:
     explicit ImplicitExceptionSpecification(Sema &Self)
-      : Self(&Self), ComputedEST(EST_BasicNoexcept) {
+        : Self(&Self), ComputedEST(EST_BasicNoexcept) {
       if (!Self.getLangOpts().CPlusPlus11)
         ComputedEST = EST_DynamicNone;
     }
@@ -5979,8 +5817,8 @@ public:
         ///   The exception-specification is noexcept(false) if the set of
         ///   potential exceptions of the special member function contains "any"
         ESI.Type = EST_NoexceptFalse;
-        ESI.NoexceptExpr = Self->ActOnCXXBoolLiteral(SourceLocation(),
-                                                     tok::kw_false).get();
+        ESI.NoexceptExpr =
+            Self->ActOnCXXBoolLiteral(SourceLocation(), tok::kw_false).get();
       }
       return ESI;
     }
@@ -6012,12 +5850,10 @@ public:
   /// Add an exception-specification to the given member function
   /// (or member function template). The exception-specification was parsed
   /// after the method itself was declared.
-  void actOnDelayedExceptionSpecification(Decl *Method,
-         ExceptionSpecificationType EST,
-         SourceRange SpecificationRange,
-         ArrayRef<ParsedType> DynamicExceptions,
-         ArrayRef<SourceRange> DynamicExceptionRanges,
-         Expr *NoexceptExpr);
+  void actOnDelayedExceptionSpecification(
+      Decl *Method, ExceptionSpecificationType EST,
+      SourceRange SpecificationRange, ArrayRef<ParsedType> DynamicExceptions,
+      ArrayRef<SourceRange> DynamicExceptionRanges, Expr *NoexceptExpr);
 
   class InheritedConstructorInfo;
 
@@ -6036,8 +5872,8 @@ public:
   /// default constructor will be added.
   ///
   /// \returns The implicitly-declared default constructor.
-  CXXConstructorDecl *DeclareImplicitDefaultConstructor(
-                                                     CXXRecordDecl *ClassDecl);
+  CXXConstructorDecl *
+  DeclareImplicitDefaultConstructor(CXXRecordDecl *ClassDecl);
 
   /// DefineImplicitDefaultConstructor - Checks for feasibility of
   /// defining this constructor as the default constructor.
@@ -6169,10 +6005,9 @@ public:
   ParsedType getConstructorName(IdentifierInfo &II, SourceLocation NameLoc,
                                 Scope *S, CXXScopeSpec &SS,
                                 bool EnteringContext);
-  ParsedType getDestructorName(SourceLocation TildeLoc,
-                               IdentifierInfo &II, SourceLocation NameLoc,
-                               Scope *S, CXXScopeSpec &SS,
-                               ParsedType ObjectType,
+  ParsedType getDestructorName(SourceLocation TildeLoc, IdentifierInfo &II,
+                               SourceLocation NameLoc, Scope *S,
+                               CXXScopeSpec &SS, ParsedType ObjectType,
                                bool EnteringContext);
 
   ParsedType getDestructorTypeForDecltype(const DeclSpec &DS,
@@ -6197,21 +6032,15 @@ public:
 
   /// ActOnCXXNamedCast - Parse
   /// {dynamic,static,reinterpret,const,addrspace}_cast's.
-  ExprResult ActOnCXXNamedCast(SourceLocation OpLoc,
-                               tok::TokenKind Kind,
-                               SourceLocation LAngleBracketLoc,
-                               Declarator &D,
+  ExprResult ActOnCXXNamedCast(SourceLocation OpLoc, tok::TokenKind Kind,
+                               SourceLocation LAngleBracketLoc, Declarator &D,
                                SourceLocation RAngleBracketLoc,
-                               SourceLocation LParenLoc,
-                               Expr *E,
+                               SourceLocation LParenLoc, Expr *E,
                                SourceLocation RParenLoc);
 
-  ExprResult BuildCXXNamedCast(SourceLocation OpLoc,
-                               tok::TokenKind Kind,
-                               TypeSourceInfo *Ty,
-                               Expr *E,
-                               SourceRange AngleBrackets,
-                               SourceRange Parens);
+  ExprResult BuildCXXNamedCast(SourceLocation OpLoc, tok::TokenKind Kind,
+                               TypeSourceInfo *Ty, Expr *E,
+                               SourceRange AngleBrackets, SourceRange Parens);
 
   ExprResult ActOnBuiltinBitCastExpr(SourceLocation KWLoc, Declarator &Dcl,
                                      ExprResult Operand,
@@ -6220,34 +6049,24 @@ public:
   ExprResult BuildBuiltinBitCastExpr(SourceLocation KWLoc, TypeSourceInfo *TSI,
                                      Expr *Operand, SourceLocation RParenLoc);
 
-  ExprResult BuildCXXTypeId(QualType TypeInfoType,
-                            SourceLocation TypeidLoc,
-                            TypeSourceInfo *Operand,
-                            SourceLocation RParenLoc);
-  ExprResult BuildCXXTypeId(QualType TypeInfoType,
-                            SourceLocation TypeidLoc,
-                            Expr *Operand,
-                            SourceLocation RParenLoc);
+  ExprResult BuildCXXTypeId(QualType TypeInfoType, SourceLocation TypeidLoc,
+                            TypeSourceInfo *Operand, SourceLocation RParenLoc);
+  ExprResult BuildCXXTypeId(QualType TypeInfoType, SourceLocation TypeidLoc,
+                            Expr *Operand, SourceLocation RParenLoc);
 
   /// ActOnCXXTypeid - Parse typeid( something ).
-  ExprResult ActOnCXXTypeid(SourceLocation OpLoc,
-                            SourceLocation LParenLoc, bool isType,
-                            void *TyOrExpr,
+  ExprResult ActOnCXXTypeid(SourceLocation OpLoc, SourceLocation LParenLoc,
+                            bool isType, void *TyOrExpr,
                             SourceLocation RParenLoc);
 
-  ExprResult BuildCXXUuidof(QualType TypeInfoType,
-                            SourceLocation TypeidLoc,
-                            TypeSourceInfo *Operand,
-                            SourceLocation RParenLoc);
-  ExprResult BuildCXXUuidof(QualType TypeInfoType,
-                            SourceLocation TypeidLoc,
-                            Expr *Operand,
-                            SourceLocation RParenLoc);
+  ExprResult BuildCXXUuidof(QualType TypeInfoType, SourceLocation TypeidLoc,
+                            TypeSourceInfo *Operand, SourceLocation RParenLoc);
+  ExprResult BuildCXXUuidof(QualType TypeInfoType, SourceLocation TypeidLoc,
+                            Expr *Operand, SourceLocation RParenLoc);
 
   /// ActOnCXXUuidof - Parse __uuidof( something ).
-  ExprResult ActOnCXXUuidof(SourceLocation OpLoc,
-                            SourceLocation LParenLoc, bool isType,
-                            void *TyOrExpr,
+  ExprResult ActOnCXXUuidof(SourceLocation OpLoc, SourceLocation LParenLoc,
+                            bool isType, void *TyOrExpr,
                             SourceLocation RParenLoc);
 
   /// Handle a C++1z fold-expression: ( expr op ... op expr ).
@@ -6314,8 +6133,8 @@ public:
   /// a nested generic lambda (depending on whether the name resolves to
   /// a non-static member function or a static function).
   /// \return returns 'true' if failed, 'false' if success.
-  bool CheckCXXThisCapture(SourceLocation Loc, bool Explicit = false,
-      bool BuildAndDiagnose = true,
+  bool CheckCXXThisCapture(
+      SourceLocation Loc, bool Explicit = false, bool BuildAndDiagnose = true,
       const unsigned *const FunctionScopeIndexToStopAt = nullptr,
       bool ByCopy = false);
 
@@ -6327,7 +6146,6 @@ public:
   /// ActOnCXXBoolLiteral - Parse {true,false} literals.
   ExprResult ActOnCXXBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind);
 
-
   /// ActOnObjCBoolLiteral - Parse {__objc_yes,__objc_no} literals.
   ExprResult ActOnObjCBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind);
 
@@ -6367,16 +6185,12 @@ public:
                          SourceLocation PlacementRParen,
                          SourceRange TypeIdParens, Declarator &D,
                          Expr *Initializer);
-  ExprResult BuildCXXNew(SourceRange Range, bool UseGlobal,
-                         SourceLocation PlacementLParen,
-                         MultiExprArg PlacementArgs,
-                         SourceLocation PlacementRParen,
-                         SourceRange TypeIdParens,
-                         QualType AllocType,
-                         TypeSourceInfo *AllocTypeInfo,
-                         Optional<Expr *> ArraySize,
-                         SourceRange DirectInitRange,
-                         Expr *Initializer);
+  ExprResult
+  BuildCXXNew(SourceRange Range, bool UseGlobal, SourceLocation PlacementLParen,
+              MultiExprArg PlacementArgs, SourceLocation PlacementRParen,
+              SourceRange TypeIdParens, QualType AllocType,
+              TypeSourceInfo *AllocTypeInfo, Optional<Expr *> ArraySize,
+              SourceRange DirectInitRange, Expr *Initializer);
 
   /// Determine whether \p FD is an aligned allocation or deallocation
   /// function that is unavailable.
@@ -6417,7 +6231,7 @@ public:
                                        ArrayRef<QualType> Params);
 
   bool FindDeallocationFunction(SourceLocation StartLoc, CXXRecordDecl *RD,
-                                DeclarationName Name, FunctionDecl* &Operator,
+                                DeclarationName Name, FunctionDecl *&Operator,
                                 bool Diagnose = true);
   FunctionDecl *FindUsualDeallocationFunction(SourceLocation StartLoc,
                                               bool CanProvideSize,
@@ -6427,9 +6241,8 @@ public:
                                                       CXXRecordDecl *RD);
 
   /// ActOnCXXDelete - Parsed a C++ 'delete' expression
-  ExprResult ActOnCXXDelete(SourceLocation StartLoc,
-                            bool UseGlobal, bool ArrayForm,
-                            Expr *Operand);
+  ExprResult ActOnCXXDelete(SourceLocation StartLoc, bool UseGlobal,
+                            bool ArrayForm, Expr *Operand);
   void CheckVirtualDtorCall(CXXDestructorDecl *dtor, SourceLocation Loc,
                             bool IsDelete, bool CallCanBeVirtual,
                             bool WarnOnNonAbstractTypes,
@@ -6450,60 +6263,43 @@ public:
 
   /// ActOnArrayTypeTrait - Parsed one of the binary type trait support
   /// pseudo-functions.
-  ExprResult ActOnArrayTypeTrait(ArrayTypeTrait ATT,
-                                 SourceLocation KWLoc,
-                                 ParsedType LhsTy,
-                                 Expr *DimExpr,
+  ExprResult ActOnArrayTypeTrait(ArrayTypeTrait ATT, SourceLocation KWLoc,
+                                 ParsedType LhsTy, Expr *DimExpr,
                                  SourceLocation RParen);
 
-  ExprResult BuildArrayTypeTrait(ArrayTypeTrait ATT,
-                                 SourceLocation KWLoc,
-                                 TypeSourceInfo *TSInfo,
-                                 Expr *DimExpr,
+  ExprResult BuildArrayTypeTrait(ArrayTypeTrait ATT, SourceLocation KWLoc,
+                                 TypeSourceInfo *TSInfo, Expr *DimExpr,
                                  SourceLocation RParen);
 
   /// ActOnExpressionTrait - Parsed one of the unary type trait support
   /// pseudo-functions.
-  ExprResult ActOnExpressionTrait(ExpressionTrait OET,
-                                  SourceLocation KWLoc,
-                                  Expr *Queried,
-                                  SourceLocation RParen);
+  ExprResult ActOnExpressionTrait(ExpressionTrait OET, SourceLocation KWLoc,
+                                  Expr *Queried, SourceLocation RParen);
 
-  ExprResult BuildExpressionTrait(ExpressionTrait OET,
-                                  SourceLocation KWLoc,
-                                  Expr *Queried,
-                                  SourceLocation RParen);
+  ExprResult BuildExpressionTrait(ExpressionTrait OET, SourceLocation KWLoc,
+                                  Expr *Queried, SourceLocation RParen);
 
-  ExprResult ActOnStartCXXMemberReference(Scope *S,
-                                          Expr *Base,
+  ExprResult ActOnStartCXXMemberReference(Scope *S, Expr *Base,
                                           SourceLocation OpLoc,
                                           tok::TokenKind OpKind,
                                           ParsedType &ObjectType,
                                           bool &MayBePseudoDestructor);
 
-  ExprResult BuildPseudoDestructorExpr(Expr *Base,
-                                       SourceLocation OpLoc,
-                                       tok::TokenKind OpKind,
-                                       const CXXScopeSpec &SS,
-                                       TypeSourceInfo *ScopeType,
-                                       SourceLocation CCLoc,
-                                       SourceLocation TildeLoc,
-                                     PseudoDestructorTypeStorage DestroyedType);
-
-  ExprResult ActOnPseudoDestructorExpr(Scope *S, Expr *Base,
-                                       SourceLocation OpLoc,
-                                       tok::TokenKind OpKind,
-                                       CXXScopeSpec &SS,
-                                       UnqualifiedId &FirstTypeName,
-                                       SourceLocation CCLoc,
-                                       SourceLocation TildeLoc,
-                                       UnqualifiedId &SecondTypeName);
+  ExprResult BuildPseudoDestructorExpr(
+      Expr *Base, SourceLocation OpLoc, tok::TokenKind OpKind,
+      const CXXScopeSpec &SS, TypeSourceInfo *ScopeType, SourceLocation CCLoc,
+      SourceLocation TildeLoc, PseudoDestructorTypeStorage DestroyedType);
+
+  ExprResult ActOnPseudoDestructorExpr(
+      Scope *S, Expr *Base, SourceLocation OpLoc, tok::TokenKind OpKind,
+      CXXScopeSpec &SS, UnqualifiedId &FirstTypeName, SourceLocation CCLoc,
+      SourceLocation TildeLoc, UnqualifiedId &SecondTypeName);
 
   ExprResult ActOnPseudoDestructorExpr(Scope *S, Expr *Base,
                                        SourceLocation OpLoc,
                                        tok::TokenKind OpKind,
                                        SourceLocation TildeLoc,
-                                       const DeclSpec& DS);
+                                       const DeclSpec &DS);
 
   /// MaybeCreateExprWithCleanups - If the current full-expression
   /// requires any cleanups, surround it with a ExprWithCleanups node.
@@ -6581,25 +6377,22 @@ public:
 
     /// Creates info object for the most typical case.
     NestedNameSpecInfo(IdentifierInfo *II, SourceLocation IdLoc,
-             SourceLocation ColonColonLoc, ParsedType ObjectType = ParsedType())
-      : ObjectType(ObjectType), Identifier(II), IdentifierLoc(IdLoc),
-        CCLoc(ColonColonLoc) {
-    }
+                       SourceLocation ColonColonLoc,
+                       ParsedType ObjectType = ParsedType())
+        : ObjectType(ObjectType), Identifier(II), IdentifierLoc(IdLoc),
+          CCLoc(ColonColonLoc) {}
 
     NestedNameSpecInfo(IdentifierInfo *II, SourceLocation IdLoc,
                        SourceLocation ColonColonLoc, QualType ObjectType)
-      : ObjectType(ParsedType::make(ObjectType)), Identifier(II),
-        IdentifierLoc(IdLoc), CCLoc(ColonColonLoc) {
-    }
+        : ObjectType(ParsedType::make(ObjectType)), Identifier(II),
+          IdentifierLoc(IdLoc), CCLoc(ColonColonLoc) {}
   };
 
   bool isNonTypeNestedNameSpecifier(Scope *S, CXXScopeSpec &SS,
                                     NestedNameSpecInfo &IdInfo);
 
-  bool BuildCXXNestedNameSpecifier(Scope *S,
-                                   NestedNameSpecInfo &IdInfo,
-                                   bool EnteringContext,
-                                   CXXScopeSpec &SS,
+  bool BuildCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
+                                   bool EnteringContext, CXXScopeSpec &SS,
                                    NamedDecl *ScopeLookupResult,
                                    bool ErrorRecoveryLookup,
                                    bool *IsCorrectedToColon = nullptr,
@@ -6630,18 +6423,15 @@ public:
   /// \param OnlyNamespace If true, only considers namespaces in lookup.
   ///
   /// \returns true if an error occurred, false otherwise.
-  bool ActOnCXXNestedNameSpecifier(Scope *S,
-                                   NestedNameSpecInfo &IdInfo,
-                                   bool EnteringContext,
-                                   CXXScopeSpec &SS,
+  bool ActOnCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
+                                   bool EnteringContext, CXXScopeSpec &SS,
                                    bool ErrorRecoveryLookup = false,
                                    bool *IsCorrectedToColon = nullptr,
                                    bool OnlyNamespace = false);
 
   ExprResult ActOnDecltypeExpression(Expr *E);
 
-  bool ActOnCXXNestedNameSpecifierDecltype(CXXScopeSpec &SS,
-                                           const DeclSpec &DS,
+  bool ActOnCXXNestedNameSpecifierDecltype(CXXScopeSpec &SS, const DeclSpec &DS,
                                            SourceLocation ColonColonLoc);
 
   bool IsInvalidUnlessNestedName(Scope *S, CXXScopeSpec &SS,
@@ -6671,16 +6461,11 @@ public:
   ///
   ///
   /// \returns true if an error occurred, false otherwise.
-  bool ActOnCXXNestedNameSpecifier(Scope *S,
-                                   CXXScopeSpec &SS,
-                                   SourceLocation TemplateKWLoc,
-                                   TemplateTy TemplateName,
-                                   SourceLocation TemplateNameLoc,
-                                   SourceLocation LAngleLoc,
-                                   ASTTemplateArgsPtr TemplateArgs,
-                                   SourceLocation RAngleLoc,
-                                   SourceLocation CCLoc,
-                                   bool EnteringContext);
+  bool ActOnCXXNestedNameSpecifier(
+      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
+      TemplateTy TemplateName, SourceLocation TemplateNameLoc,
+      SourceLocation LAngleLoc, ASTTemplateArgsPtr TemplateArgs,
+      SourceLocation RAngleLoc, SourceLocation CCLoc, bool EnteringContext);
 
   /// Given a C++ nested-name-specifier, produce an annotation value
   /// that the parser can use later to reconstruct the given
@@ -6755,14 +6540,11 @@ public:
       Optional<std::tuple<bool, unsigned, unsigned, Decl *>> Mangling = None);
 
   /// Endow the lambda scope info with the relevant properties.
-  void buildLambdaScope(sema::LambdaScopeInfo *LSI,
-                        CXXMethodDecl *CallOperator,
+  void buildLambdaScope(sema::LambdaScopeInfo *LSI, CXXMethodDecl *CallOperator,
                         SourceRange IntroducerRange,
                         LambdaCaptureDefault CaptureDefault,
-                        SourceLocation CaptureDefaultLoc,
-                        bool ExplicitParams,
-                        bool ExplicitResultType,
-                        bool Mutable);
+                        SourceLocation CaptureDefaultLoc, bool ExplicitParams,
+                        bool ExplicitResultType, bool Mutable);
 
   /// Perform initialization analysis of the init-capture and perform
   /// any implicit conversions such as an lvalue-to-rvalue conversion if
@@ -6805,9 +6587,8 @@ public:
                                                 ExprResult RequiresClause);
 
   /// Introduce the lambda parameters into scope.
-  void addLambdaParameters(
-      ArrayRef<LambdaIntroducer::LambdaCapture> Captures,
-      CXXMethodDecl *CallOperator, Scope *CurScope);
+  void addLambdaParameters(ArrayRef<LambdaIntroducer::LambdaCapture> Captures,
+                           CXXMethodDecl *CallOperator, Scope *CurScope);
 
   /// Deduce a block or lambda's return type based on the return
   /// statements present in the body.
@@ -6864,8 +6645,9 @@ public:
   /// in the initialization expression needed to copy the lambda object into
   /// the block, and IR generation actually generates the real body of the
   /// block pointer conversion.
-  void DefineImplicitLambdaToFunctionPointerConversion(
-         SourceLocation CurrentLoc, CXXConversionDecl *Conv);
+  void
+  DefineImplicitLambdaToFunctionPointerConversion(SourceLocation CurrentLoc,
+                                                  CXXConversionDecl *Conv);
 
   /// Define the "body" of the conversion from a lambda object to a
   /// block pointer.
@@ -6879,8 +6661,7 @@ public:
 
   ExprResult BuildBlockForLambdaConversion(SourceLocation CurrentLocation,
                                            SourceLocation ConvLocation,
-                                           CXXConversionDecl *Conv,
-                                           Expr *Src);
+                                           CXXConversionDecl *Conv, Expr *Src);
 
   /// Check whether the given expression is a valid constraint expression.
   /// A diagnostic is emitted if it is not, false is returned, and
@@ -6899,15 +6680,13 @@ private:
   /// constrained declarations). If an error occurred while normalizing the
   /// associated constraints of the template or concept, nullptr will be cached
   /// here.
-  llvm::DenseMap<NamedDecl *, NormalizedConstraint *>
-      NormalizationCache;
+  llvm::DenseMap<NamedDecl *, NormalizedConstraint *> NormalizationCache;
 
   llvm::ContextualFoldingSet<ConstraintSatisfaction, const ASTContext &>
       SatisfactionCache;
 
 public:
-  const NormalizedConstraint *
-  getNormalizedAssociatedConstraints(
+  const NormalizedConstraint *getNormalizedAssociatedConstraints(
       NamedDecl *ConstrainedDecl, ArrayRef<const Expr *> AssociatedConstraints);
 
   /// \brief Check whether the given declaration's associated constraints are
@@ -6926,8 +6705,9 @@ public:
   /// of atomic constraints involved had been declared in a concept and not
   /// repeated in two separate places in code.
   /// \returns true if such a diagnostic was emitted, false otherwise.
-  bool MaybeEmitAmbiguousAtomicConstraintsDiagnostic(NamedDecl *D1,
-      ArrayRef<const Expr *> AC1, NamedDecl *D2, ArrayRef<const Expr *> AC2);
+  bool MaybeEmitAmbiguousAtomicConstraintsDiagnostic(
+      NamedDecl *D1, ArrayRef<const Expr *> AC1, NamedDecl *D2,
+      ArrayRef<const Expr *> AC2);
 
   /// \brief Check whether the given list of constraint expressions are
   /// satisfied (as if in a 'conjunction') given template arguments.
@@ -6944,10 +6724,11 @@ public:
   /// expression.
   /// \returns true if an error occurred and satisfaction could not be checked,
   /// false otherwise.
-  bool CheckConstraintSatisfaction(
-      const NamedDecl *Template, ArrayRef<const Expr *> ConstraintExprs,
-      ArrayRef<TemplateArgument> TemplateArgs,
-      SourceRange TemplateIDRange, ConstraintSatisfaction &Satisfaction);
+  bool CheckConstraintSatisfaction(const NamedDecl *Template,
+                                   ArrayRef<const Expr *> ConstraintExprs,
+                                   ArrayRef<TemplateArgument> TemplateArgs,
+                                   SourceRange TemplateIDRange,
+                                   ConstraintSatisfaction &Satisfaction);
 
   /// \brief Check whether the given non-dependent constraint expression is
   /// satisfied. Returns false and updates Satisfaction with the satisfaction
@@ -6968,7 +6749,6 @@ public:
                                 ConstraintSatisfaction &Satisfaction,
                                 SourceLocation UsageLoc = SourceLocation());
 
-
   /// \brief Ensure that the given template arguments satisfy the constraints
   /// associated with the given template, emitting a diagnostic if they do not.
   ///
@@ -6982,17 +6762,17 @@ public:
   ///
   /// \returns true if the constrains are not satisfied or could not be checked
   /// for satisfaction, false if the constraints are satisfied.
-  bool EnsureTemplateArgumentListConstraints(TemplateDecl *Template,
-                                       ArrayRef<TemplateArgument> TemplateArgs,
-                                             SourceRange TemplateIDRange);
+  bool
+  EnsureTemplateArgumentListConstraints(TemplateDecl *Template,
+                                        ArrayRef<TemplateArgument> TemplateArgs,
+                                        SourceRange TemplateIDRange);
 
   /// \brief Emit diagnostics explaining why a constraint expression was deemed
   /// unsatisfied.
   /// \param First whether this is the first time an unsatisfied constraint is
   /// diagnosed for this error.
-  void
-  DiagnoseUnsatisfiedConstraint(const ConstraintSatisfaction &Satisfaction,
-                                bool First = true);
+  void DiagnoseUnsatisfiedConstraint(const ConstraintSatisfaction &Satisfaction,
+                                     bool First = true);
 
   /// \brief Emit diagnostics explaining why a constraint expression was deemed
   /// unsatisfied.
@@ -7026,32 +6806,31 @@ public:
                                           ObjCMethodDecl *getterMethod,
                                           ObjCMethodDecl *setterMethod);
 
-  ExprResult BuildObjCDictionaryLiteral(SourceRange SR,
-                               MutableArrayRef<ObjCDictionaryElement> Elements);
+  ExprResult
+  BuildObjCDictionaryLiteral(SourceRange SR,
+                             MutableArrayRef<ObjCDictionaryElement> Elements);
 
   ExprResult BuildObjCEncodeExpression(SourceLocation AtLoc,
-                                  TypeSourceInfo *EncodedTypeInfo,
-                                  SourceLocation RParenLoc);
+                                       TypeSourceInfo *EncodedTypeInfo,
+                                       SourceLocation RParenLoc);
   ExprResult BuildCXXMemberCallExpr(Expr *Exp, NamedDecl *FoundDecl,
                                     CXXConversionDecl *Method,
                                     bool HadMultipleCandidates);
 
   ExprResult ParseObjCEncodeExpression(SourceLocation AtLoc,
                                        SourceLocation EncodeLoc,
-                                       SourceLocation LParenLoc,
-                                       ParsedType Ty,
+                                       SourceLocation LParenLoc, ParsedType Ty,
                                        SourceLocation RParenLoc);
 
   /// ParseObjCSelectorExpression - Build selector expression for \@selector
-  ExprResult ParseObjCSelectorExpression(Selector Sel,
-                                         SourceLocation AtLoc,
+  ExprResult ParseObjCSelectorExpression(Selector Sel, SourceLocation AtLoc,
                                          SourceLocation SelLoc,
                                          SourceLocation LParenLoc,
                                          SourceLocation RParenLoc,
                                          bool WarnMultipleSelectors);
 
   /// ParseObjCProtocolExpression - Build protocol expression for \@protocol
-  ExprResult ParseObjCProtocolExpression(IdentifierInfo * ProtocolName,
+  ExprResult ParseObjCProtocolExpression(IdentifierInfo *ProtocolName,
                                          SourceLocation AtLoc,
                                          SourceLocation ProtoLoc,
                                          SourceLocation LParenLoc,
@@ -7061,15 +6840,11 @@ public:
   //===--------------------------------------------------------------------===//
   // C++ Declarations
   //
-  Decl *ActOnStartLinkageSpecification(Scope *S,
-                                       SourceLocation ExternLoc,
-                                       Expr *LangStr,
-                                       SourceLocation LBraceLoc);
-  Decl *ActOnFinishLinkageSpecification(Scope *S,
-                                        Decl *LinkageSpec,
+  Decl *ActOnStartLinkageSpecification(Scope *S, SourceLocation ExternLoc,
+                                       Expr *LangStr, SourceLocation LBraceLoc);
+  Decl *ActOnFinishLinkageSpecification(Scope *S, Decl *LinkageSpec,
                                         SourceLocation RBraceLoc);
 
-
   //===--------------------------------------------------------------------===//
   // C++ Classes
   //
@@ -7082,61 +6857,47 @@ public:
                             SourceLocation ColonLoc,
                             const ParsedAttributesView &Attrs);
 
-  NamedDecl *ActOnCXXMemberDeclarator(Scope *S, AccessSpecifier AS,
-                                 Declarator &D,
-                                 MultiTemplateParamsArg TemplateParameterLists,
-                                 Expr *BitfieldWidth, const VirtSpecifiers &VS,
-                                 InClassInitStyle InitStyle);
+  NamedDecl *
+  ActOnCXXMemberDeclarator(Scope *S, AccessSpecifier AS, Declarator &D,
+                           MultiTemplateParamsArg TemplateParameterLists,
+                           Expr *BitfieldWidth, const VirtSpecifiers &VS,
+                           InClassInitStyle InitStyle);
 
   void ActOnStartCXXInClassMemberInitializer();
   void ActOnFinishCXXInClassMemberInitializer(Decl *VarDecl,
                                               SourceLocation EqualLoc,
                                               Expr *Init);
 
-  MemInitResult ActOnMemInitializer(Decl *ConstructorD,
-                                    Scope *S,
-                                    CXXScopeSpec &SS,
-                                    IdentifierInfo *MemberOrBase,
-                                    ParsedType TemplateTypeTy,
-                                    const DeclSpec &DS,
-                                    SourceLocation IdLoc,
-                                    SourceLocation LParenLoc,
-                                    ArrayRef<Expr *> Args,
-                                    SourceLocation RParenLoc,
-                                    SourceLocation EllipsisLoc);
+  MemInitResult
+  ActOnMemInitializer(Decl *ConstructorD, Scope *S, CXXScopeSpec &SS,
+                      IdentifierInfo *MemberOrBase, ParsedType TemplateTypeTy,
+                      const DeclSpec &DS, SourceLocation IdLoc,
+                      SourceLocation LParenLoc, ArrayRef<Expr *> Args,
+                      SourceLocation RParenLoc, SourceLocation EllipsisLoc);
 
-  MemInitResult ActOnMemInitializer(Decl *ConstructorD,
-                                    Scope *S,
+  MemInitResult ActOnMemInitializer(Decl *ConstructorD, Scope *S,
                                     CXXScopeSpec &SS,
                                     IdentifierInfo *MemberOrBase,
                                     ParsedType TemplateTypeTy,
-                                    const DeclSpec &DS,
-                                    SourceLocation IdLoc,
-                                    Expr *InitList,
-                                    SourceLocation EllipsisLoc);
+                                    const DeclSpec &DS, SourceLocation IdLoc,
+                                    Expr *InitList, SourceLocation EllipsisLoc);
 
-  MemInitResult BuildMemInitializer(Decl *ConstructorD,
-                                    Scope *S,
+  MemInitResult BuildMemInitializer(Decl *ConstructorD, Scope *S,
                                     CXXScopeSpec &SS,
                                     IdentifierInfo *MemberOrBase,
                                     ParsedType TemplateTypeTy,
-                                    const DeclSpec &DS,
-                                    SourceLocation IdLoc,
-                                    Expr *Init,
-                                    SourceLocation EllipsisLoc);
+                                    const DeclSpec &DS, SourceLocation IdLoc,
+                                    Expr *Init, SourceLocation EllipsisLoc);
 
-  MemInitResult BuildMemberInitializer(ValueDecl *Member,
-                                       Expr *Init,
+  MemInitResult BuildMemberInitializer(ValueDecl *Member, Expr *Init,
                                        SourceLocation IdLoc);
 
   MemInitResult BuildBaseInitializer(QualType BaseType,
-                                     TypeSourceInfo *BaseTInfo,
-                                     Expr *Init,
+                                     TypeSourceInfo *BaseTInfo, Expr *Init,
                                      CXXRecordDecl *ClassDecl,
                                      SourceLocation EllipsisLoc);
 
-  MemInitResult BuildDelegatingInitializer(TypeSourceInfo *TInfo,
-                                           Expr *Init,
+  MemInitResult BuildDelegatingInitializer(TypeSourceInfo *TInfo, Expr *Init,
                                            CXXRecordDecl *ClassDecl);
 
   bool SetDelegatingInitializer(CXXConstructorDecl *Constructor,
@@ -7147,7 +6908,6 @@ public:
 
   void SetIvarInitializers(ObjCImplementationDecl *ObjCImplementation);
 
-
   /// MarkBaseAndMemberDestructorsReferenced - Given a record decl,
   /// mark all the non-trivial destructors of its members and bases as
   /// referenced.
@@ -7173,7 +6933,7 @@ public:
   /// The list of classes whose vtables have been used within
   /// this translation unit, and the source locations at which the
   /// first use occurred.
-  typedef std::pair<CXXRecordDecl*, SourceLocation> VTableUse;
+  typedef std::pair<CXXRecordDecl *, SourceLocation> VTableUse;
 
   /// The list of vtables that are required but have not yet been
   /// materialized.
@@ -7212,9 +6972,8 @@ public:
 
   void AddImplicitlyDeclaredMembersToClass(CXXRecordDecl *ClassDecl);
 
-  void ActOnMemInitializers(Decl *ConstructorDecl,
-                            SourceLocation ColonLoc,
-                            ArrayRef<CXXCtorInitializer*> MemInits,
+  void ActOnMemInitializers(Decl *ConstructorDecl, SourceLocation ColonLoc,
+                            ArrayRef<CXXCtorInitializer *> MemInits,
                             bool AnyErrors);
 
   /// Check class-level dllimport/dllexport attribute. The caller must
@@ -7269,14 +7028,12 @@ public:
   bool IsInsideALocalClassWithinATemplateFunction();
 
   Decl *ActOnStaticAssertDeclaration(SourceLocation StaticAssertLoc,
-                                     Expr *AssertExpr,
-                                     Expr *AssertMessageExpr,
+                                     Expr *AssertExpr, Expr *AssertMessageExpr,
                                      SourceLocation RParenLoc);
   Decl *BuildStaticAssertDeclaration(SourceLocation StaticAssertLoc,
                                      Expr *AssertExpr,
                                      StringLiteral *AssertMessageExpr,
-                                     SourceLocation RParenLoc,
-                                     bool Failed);
+                                     SourceLocation RParenLoc, bool Failed);
 
   FriendDecl *CheckFriendTypeDecl(SourceLocation LocStart,
                                   SourceLocation FriendLoc,
@@ -7287,13 +7044,12 @@ public:
                                      MultiTemplateParamsArg TemplateParams);
 
   QualType CheckConstructorDeclarator(Declarator &D, QualType R,
-                                      StorageClass& SC);
+                                      StorageClass &SC);
   void CheckConstructor(CXXConstructorDecl *Constructor);
   QualType CheckDestructorDeclarator(Declarator &D, QualType R,
-                                     StorageClass& SC);
+                                     StorageClass &SC);
   bool CheckDestructor(CXXDestructorDecl *Destructor);
-  void CheckConversionDeclarator(Declarator &D, QualType &R,
-                                 StorageClass& SC);
+  void CheckConversionDeclarator(Declarator &D, QualType &R, StorageClass &SC);
   Decl *ActOnConversionDeclarator(CXXConversionDecl *Conversion);
   void CheckDeductionGuideDeclarator(Declarator &D, QualType &R,
                                      StorageClass &SC);
@@ -7318,16 +7074,14 @@ public:
 
   /// ActOnBaseSpecifier - Parsed a base specifier
   CXXBaseSpecifier *CheckBaseSpecifier(CXXRecordDecl *Class,
-                                       SourceRange SpecifierRange,
-                                       bool Virtual, AccessSpecifier Access,
+                                       SourceRange SpecifierRange, bool Virtual,
+                                       AccessSpecifier Access,
                                        TypeSourceInfo *TInfo,
                                        SourceLocation EllipsisLoc);
 
-  BaseResult ActOnBaseSpecifier(Decl *classdecl,
-                                SourceRange SpecifierRange,
-                                ParsedAttributes &Attrs,
-                                bool Virtual, AccessSpecifier Access,
-                                ParsedType basetype,
+  BaseResult ActOnBaseSpecifier(Decl *classdecl, SourceRange SpecifierRange,
+                                ParsedAttributes &Attrs, bool Virtual,
+                                AccessSpecifier Access, ParsedType basetype,
                                 SourceLocation BaseLoc,
                                 SourceLocation EllipsisLoc);
 
@@ -7351,8 +7105,7 @@ public:
                                     unsigned InaccessibleBaseID,
                                     unsigned AmbiguousBaseConvID,
                                     SourceLocation Loc, SourceRange Range,
-                                    DeclarationName Name,
-                                    CXXCastPath *BasePath,
+                                    DeclarationName Name, CXXCastPath *BasePath,
                                     bool IgnoreAccess = false);
 
   std::string getAmbiguousPathsDisplayString(CXXBasePaths &Paths);
@@ -7385,7 +7138,6 @@ public:
   bool CheckIfOverriddenFunctionIsMarkedFinal(const CXXMethodDecl *New,
                                               const CXXMethodDecl *Old);
 
-
   //===--------------------------------------------------------------------===//
   // C++ Access Control
   //
@@ -7410,13 +7162,11 @@ public:
                                      CXXRecordDecl *NamingClass,
                                      DeclAccessPair FoundDecl,
                                      bool Diagnose = true);
-  AccessResult CheckConstructorAccess(SourceLocation Loc,
-                                      CXXConstructorDecl *D,
+  AccessResult CheckConstructorAccess(SourceLocation Loc, CXXConstructorDecl *D,
                                       DeclAccessPair FoundDecl,
                                       const InitializedEntity &Entity,
                                       bool IsCopyBindingRefToTemp = false);
-  AccessResult CheckConstructorAccess(SourceLocation Loc,
-                                      CXXConstructorDecl *D,
+  AccessResult CheckConstructorAccess(SourceLocation Loc, CXXConstructorDecl *D,
                                       DeclAccessPair FoundDecl,
                                       const InitializedEntity &Entity,
                                       const PartialDiagnostic &PDiag);
@@ -7432,17 +7182,14 @@ public:
   CheckStructuredBindingMemberAccess(SourceLocation UseLoc,
                                      CXXRecordDecl *DecomposedClass,
                                      DeclAccessPair Field);
-  AccessResult CheckMemberOperatorAccess(SourceLocation Loc,
-                                         Expr *ObjectExpr,
+  AccessResult CheckMemberOperatorAccess(SourceLocation Loc, Expr *ObjectExpr,
                                          Expr *ArgExpr,
                                          DeclAccessPair FoundDecl);
   AccessResult CheckAddressOfMemberAccess(Expr *OvlExpr,
                                           DeclAccessPair FoundDecl);
-  AccessResult CheckBaseClassAccess(SourceLocation AccessLoc,
-                                    QualType Base, QualType Derived,
-                                    const CXXBasePath &Path,
-                                    unsigned DiagID,
-                                    bool ForceCheck = false,
+  AccessResult CheckBaseClassAccess(SourceLocation AccessLoc, QualType Base,
+                                    QualType Derived, const CXXBasePath &Path,
+                                    unsigned DiagID, bool ForceCheck = false,
                                     bool ForceUnprivileged = false);
   void CheckLookupAccess(const LookupResult &R);
   bool IsSimplyAccessible(NamedDecl *Decl, CXXRecordDecl *NamingClass,
@@ -7458,10 +7205,12 @@ public:
                                          SourceLocation(), PDiag());
   }
 
-  void HandleDependentAccessCheck(const DependentDiagnostic &DD,
-                         const MultiLevelTemplateArgumentList &TemplateArgs);
-  void PerformDependentDiagnostics(const DeclContext *Pattern,
-                        const MultiLevelTemplateArgumentList &TemplateArgs);
+  void HandleDependentAccessCheck(
+      const DependentDiagnostic &DD,
+      const MultiLevelTemplateArgumentList &TemplateArgs);
+  void PerformDependentDiagnostics(
+      const DeclContext *Pattern,
+      const MultiLevelTemplateArgumentList &TemplateArgs);
 
   void HandleDelayedAccessCheck(sema::DelayedDiagnostic &DD, Decl *Ctx);
 
@@ -7534,7 +7283,9 @@ public:
     SourceLocation getTemplateKeywordLoc() const {
       return TemplateKW.getValueOr(SourceLocation());
     }
-    bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }
+    bool hasTemplateKeyword() const {
+      return getTemplateKeywordLoc().isValid();
+    }
     bool isRequired() const { return TemplateKW != SourceLocation(); }
     explicit operator bool() const { return isRequired(); }
 
@@ -7557,12 +7308,10 @@ public:
       RequiredTemplateKind RequiredTemplate = SourceLocation(),
       AssumedTemplateKind *ATK = nullptr, bool AllowTypoCorrection = true);
 
-  TemplateNameKind isTemplateName(Scope *S,
-                                  CXXScopeSpec &SS,
+  TemplateNameKind isTemplateName(Scope *S, CXXScopeSpec &SS,
                                   bool hasTemplateKeyword,
                                   const UnqualifiedId &Name,
-                                  ParsedType ObjectType,
-                                  bool EnteringContext,
+                                  ParsedType ObjectType, bool EnteringContext,
                                   TemplateTy &Template,
                                   bool &MemberOfUnknownSpecialization,
                                   bool Disambiguation = false);
@@ -7588,8 +7337,7 @@ public:
                             ParsedTemplateTy *Template = nullptr);
 
   bool DiagnoseUnknownTemplateName(const IdentifierInfo &II,
-                                   SourceLocation IILoc,
-                                   Scope *S,
+                                   SourceLocation IILoc, Scope *S,
                                    const CXXScopeSpec *SS,
                                    TemplateTy &SuggestedTemplate,
                                    TemplateNameKind &SuggestedKind);
@@ -7609,9 +7357,8 @@ public:
                                 SourceLocation EllipsisLoc,
                                 SourceLocation KeyLoc,
                                 IdentifierInfo *ParamName,
-                                SourceLocation ParamNameLoc,
-                                unsigned Depth, unsigned Position,
-                                SourceLocation EqualLoc,
+                                SourceLocation ParamNameLoc, unsigned Depth,
+                                unsigned Position, SourceLocation EqualLoc,
                                 ParsedType DefaultArg, bool HasTypeConstraint);
 
   bool ActOnTypeConstraint(const CXXScopeSpec &SS,
@@ -7642,29 +7389,19 @@ public:
   QualType CheckNonTypeTemplateParameterType(QualType T, SourceLocation Loc);
 
   NamedDecl *ActOnNonTypeTemplateParameter(Scope *S, Declarator &D,
-                                      unsigned Depth,
-                                      unsigned Position,
-                                      SourceLocation EqualLoc,
-                                      Expr *DefaultArg);
-  NamedDecl *ActOnTemplateTemplateParameter(Scope *S,
-                                       SourceLocation TmpLoc,
-                                       TemplateParameterList *Params,
-                                       SourceLocation EllipsisLoc,
-                                       IdentifierInfo *ParamName,
-                                       SourceLocation ParamNameLoc,
-                                       unsigned Depth,
-                                       unsigned Position,
-                                       SourceLocation EqualLoc,
-                                       ParsedTemplateArgument DefaultArg);
-
-  TemplateParameterList *
-  ActOnTemplateParameterList(unsigned Depth,
-                             SourceLocation ExportLoc,
-                             SourceLocation TemplateLoc,
-                             SourceLocation LAngleLoc,
-                             ArrayRef<NamedDecl *> Params,
-                             SourceLocation RAngleLoc,
-                             Expr *RequiresClause);
+                                           unsigned Depth, unsigned Position,
+                                           SourceLocation EqualLoc,
+                                           Expr *DefaultArg);
+  NamedDecl *ActOnTemplateTemplateParameter(
+      Scope *S, SourceLocation TmpLoc, TemplateParameterList *Params,
+      SourceLocation EllipsisLoc, IdentifierInfo *ParamName,
+      SourceLocation ParamNameLoc, unsigned Depth, unsigned Position,
+      SourceLocation EqualLoc, ParsedTemplateArgument DefaultArg);
+
+  TemplateParameterList *ActOnTemplateParameterList(
+      unsigned Depth, SourceLocation ExportLoc, SourceLocation TemplateLoc,
+      SourceLocation LAngleLoc, ArrayRef<NamedDecl *> Params,
+      SourceLocation RAngleLoc, Expr *RequiresClause);
 
   /// The context in which we are checking a template parameter list.
   enum TemplateParamListContext {
@@ -7685,8 +7422,8 @@ public:
   TemplateParameterList *MatchTemplateParametersToScopeSpecifier(
       SourceLocation DeclStartLoc, SourceLocation DeclLoc,
       const CXXScopeSpec &SS, TemplateIdAnnotation *TemplateId,
-      ArrayRef<TemplateParameterList *> ParamLists,
-      bool IsFriend, bool &IsMemberSpecialization, bool &Invalid,
+      ArrayRef<TemplateParameterList *> ParamLists, bool IsFriend,
+      bool &IsMemberSpecialization, bool &Invalid,
       bool SuppressDiagnostic = false);
 
   DeclResult CheckClassTemplate(
@@ -7717,7 +7454,7 @@ public:
 
   QualType CheckTemplateIdType(TemplateName Template,
                                SourceLocation TemplateLoc,
-                              TemplateArgumentListInfo &TemplateArgs);
+                               TemplateArgumentListInfo &TemplateArgs);
 
   TypeResult
   ActOnTemplateIdType(Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
@@ -7728,21 +7465,17 @@ public:
 
   /// Parsed an elaborated-type-specifier that refers to a template-id,
   /// such as \c class T::template apply<U>.
-  TypeResult ActOnTagTemplateIdType(TagUseKind TUK,
-                                    TypeSpecifierType TagSpec,
-                                    SourceLocation TagLoc,
-                                    CXXScopeSpec &SS,
-                                    SourceLocation TemplateKWLoc,
-                                    TemplateTy TemplateD,
-                                    SourceLocation TemplateLoc,
-                                    SourceLocation LAngleLoc,
-                                    ASTTemplateArgsPtr TemplateArgsIn,
-                                    SourceLocation RAngleLoc);
-
-  DeclResult ActOnVarTemplateSpecialization(
-      Scope *S, Declarator &D, TypeSourceInfo *DI,
-      SourceLocation TemplateKWLoc, TemplateParameterList *TemplateParams,
-      StorageClass SC, bool IsPartialSpecialization);
+  TypeResult ActOnTagTemplateIdType(
+      TagUseKind TUK, TypeSpecifierType TagSpec, SourceLocation TagLoc,
+      CXXScopeSpec &SS, SourceLocation TemplateKWLoc, TemplateTy TemplateD,
+      SourceLocation TemplateLoc, SourceLocation LAngleLoc,
+      ASTTemplateArgsPtr TemplateArgsIn, SourceLocation RAngleLoc);
+
+  DeclResult
+  ActOnVarTemplateSpecialization(Scope *S, Declarator &D, TypeSourceInfo *DI,
+                                 SourceLocation TemplateKWLoc,
+                                 TemplateParameterList *TemplateParams,
+                                 StorageClass SC, bool IsPartialSpecialization);
 
   /// Get the specialization of the given variable template corresponding to
   /// the specified argument list, or a null-but-valid result if the arguments
@@ -7762,8 +7495,7 @@ public:
                                 const TemplateArgumentListInfo *TemplateArgs);
 
   ExprResult
-  CheckConceptTemplateId(const CXXScopeSpec &SS,
-                         SourceLocation TemplateKWLoc,
+  CheckConceptTemplateId(const CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
                          const DeclarationNameInfo &ConceptNameInfo,
                          NamedDecl *FoundDecl, ConceptDecl *NamedConcept,
                          const TemplateArgumentListInfo *TemplateArgs);
@@ -7771,20 +7503,21 @@ public:
   void diagnoseMissingTemplateArguments(TemplateName Name, SourceLocation Loc);
 
   ExprResult BuildTemplateIdExpr(const CXXScopeSpec &SS,
-                                 SourceLocation TemplateKWLoc,
-                                 LookupResult &R,
+                                 SourceLocation TemplateKWLoc, LookupResult &R,
                                  bool RequiresADL,
-                               const TemplateArgumentListInfo *TemplateArgs);
+                                 const TemplateArgumentListInfo *TemplateArgs);
 
-  ExprResult BuildQualifiedTemplateIdExpr(CXXScopeSpec &SS,
-                                          SourceLocation TemplateKWLoc,
+  ExprResult
+  BuildQualifiedTemplateIdExpr(CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
                                const DeclarationNameInfo &NameInfo,
                                const TemplateArgumentListInfo *TemplateArgs);
 
-  TemplateNameKind ActOnTemplateName(
-      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-      const UnqualifiedId &Name, ParsedType ObjectType, bool EnteringContext,
-      TemplateTy &Template, bool AllowInjectedClassName = false);
+  TemplateNameKind ActOnTemplateName(Scope *S, CXXScopeSpec &SS,
+                                     SourceLocation TemplateKWLoc,
+                                     const UnqualifiedId &Name,
+                                     ParsedType ObjectType,
+                                     bool EnteringContext, TemplateTy &Template,
+                                     bool AllowInjectedClassName = false);
 
   DeclResult ActOnClassTemplateSpecialization(
       Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,
@@ -7806,17 +7539,14 @@ public:
                                 MultiTemplateParamsArg TemplateParameterLists,
                                 Declarator &D);
 
-  bool
-  CheckSpecializationInstantiationRedecl(SourceLocation NewLoc,
-                                         TemplateSpecializationKind NewTSK,
-                                         NamedDecl *PrevDecl,
-                                         TemplateSpecializationKind PrevTSK,
-                                         SourceLocation PrevPtOfInstantiation,
-                                         bool &SuppressNew);
-
-  bool CheckDependentFunctionTemplateSpecialization(FunctionDecl *FD,
-                    const TemplateArgumentListInfo &ExplicitTemplateArgs,
-                                                    LookupResult &Previous);
+  bool CheckSpecializationInstantiationRedecl(
+      SourceLocation NewLoc, TemplateSpecializationKind NewTSK,
+      NamedDecl *PrevDecl, TemplateSpecializationKind PrevTSK,
+      SourceLocation PrevPtOfInstantiation, bool &SuppressNew);
+
+  bool CheckDependentFunctionTemplateSpecialization(
+      FunctionDecl *FD, const TemplateArgumentListInfo &ExplicitTemplateArgs,
+      LookupResult &Previous);
 
   bool CheckFunctionTemplateSpecialization(
       FunctionDecl *FD, TemplateArgumentListInfo *ExplicitTemplateArgs,
@@ -7838,19 +7568,14 @@ public:
                                         SourceLocation NameLoc,
                                         const ParsedAttributesView &Attr);
 
-  DeclResult ActOnExplicitInstantiation(Scope *S,
-                                        SourceLocation ExternLoc,
+  DeclResult ActOnExplicitInstantiation(Scope *S, SourceLocation ExternLoc,
                                         SourceLocation TemplateLoc,
                                         Declarator &D);
 
-  TemplateArgumentLoc
-  SubstDefaultTemplateArgumentIfAvailable(TemplateDecl *Template,
-                                          SourceLocation TemplateLoc,
-                                          SourceLocation RAngleLoc,
-                                          Decl *Param,
-                                          SmallVectorImpl<TemplateArgument>
-                                            &Converted,
-                                          bool &HasDefaultArg);
+  TemplateArgumentLoc SubstDefaultTemplateArgumentIfAvailable(
+      TemplateDecl *Template, SourceLocation TemplateLoc,
+      SourceLocation RAngleLoc, Decl *Param,
+      SmallVectorImpl<TemplateArgument> &Converted, bool &HasDefaultArg);
 
   /// Specifies the context in which a particular template
   /// argument is being checked.
@@ -7868,13 +7593,11 @@ public:
     CTAK_DeducedFromArrayBound
   };
 
-  bool CheckTemplateArgument(NamedDecl *Param,
-                             TemplateArgumentLoc &Arg,
-                             NamedDecl *Template,
-                             SourceLocation TemplateLoc,
+  bool CheckTemplateArgument(NamedDecl *Param, TemplateArgumentLoc &Arg,
+                             NamedDecl *Template, SourceLocation TemplateLoc,
                              SourceLocation RAngleLoc,
                              unsigned ArgumentPackIndex,
-                           SmallVectorImpl<TemplateArgument> &Converted,
+                             SmallVectorImpl<TemplateArgument> &Converted,
                              CheckTemplateArgumentKind CTAK = CTAK_Specified);
 
   /// Check that the given template arguments can be be provided to
@@ -7916,21 +7639,20 @@ public:
 
   bool CheckTemplateTypeArgument(TemplateTypeParmDecl *Param,
                                  TemplateArgumentLoc &Arg,
-                           SmallVectorImpl<TemplateArgument> &Converted);
+                                 SmallVectorImpl<TemplateArgument> &Converted);
 
   bool CheckTemplateArgument(TypeSourceInfo *Arg);
-  ExprResult CheckTemplateArgument(NonTypeTemplateParmDecl *Param,
-                                   QualType InstantiatedParamType, Expr *Arg,
-                                   TemplateArgument &Converted,
-                               CheckTemplateArgumentKind CTAK = CTAK_Specified);
+  ExprResult
+  CheckTemplateArgument(NonTypeTemplateParmDecl *Param,
+                        QualType InstantiatedParamType, Expr *Arg,
+                        TemplateArgument &Converted,
+                        CheckTemplateArgumentKind CTAK = CTAK_Specified);
   bool CheckTemplateTemplateArgument(TemplateTemplateParmDecl *Param,
                                      TemplateParameterList *Params,
                                      TemplateArgumentLoc &Arg);
 
-  ExprResult
-  BuildExpressionFromDeclTemplateArgument(const TemplateArgument &Arg,
-                                          QualType ParamType,
-                                          SourceLocation Loc);
+  ExprResult BuildExpressionFromDeclTemplateArgument(
+      const TemplateArgument &Arg, QualType ParamType, SourceLocation Loc);
   ExprResult
   BuildExpressionFromIntegralTemplateArgument(const TemplateArgument &Arg,
                                               SourceLocation Loc);
@@ -7969,12 +7691,10 @@ public:
     TPL_TemplateTemplateArgumentMatch
   };
 
-  bool TemplateParameterListsAreEqual(TemplateParameterList *New,
-                                      TemplateParameterList *Old,
-                                      bool Complain,
-                                      TemplateParameterListEqualKind Kind,
-                                      SourceLocation TemplateArgLoc
-                                        = SourceLocation());
+  bool TemplateParameterListsAreEqual(
+      TemplateParameterList *New, TemplateParameterList *Old, bool Complain,
+      TemplateParameterListEqualKind Kind,
+      SourceLocation TemplateArgLoc = SourceLocation());
 
   bool CheckTemplateDeclScope(Scope *S, TemplateParameterList *TemplateParams);
 
@@ -7986,10 +7706,9 @@ public:
   /// \param SS the nested-name-specifier following the typename (e.g., 'T::').
   /// \param II the identifier we're retrieving (e.g., 'type' in the example).
   /// \param IdLoc the location of the identifier.
-  TypeResult
-  ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,
-                    const CXXScopeSpec &SS, const IdentifierInfo &II,
-                    SourceLocation IdLoc);
+  TypeResult ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,
+                               const CXXScopeSpec &SS, const IdentifierInfo &II,
+                               SourceLocation IdLoc);
 
   /// Called when the parser has parsed a C++ typename
   /// specifier that ends in a template-id, e.g.,
@@ -8007,39 +7726,31 @@ public:
   /// \param RAngleLoc The location of the closing angle bracket  ('>').
   TypeResult
   ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,
-                    const CXXScopeSpec &SS,
-                    SourceLocation TemplateLoc,
-                    TemplateTy TemplateName,
-                    IdentifierInfo *TemplateII,
-                    SourceLocation TemplateIILoc,
-                    SourceLocation LAngleLoc,
-                    ASTTemplateArgsPtr TemplateArgs,
-                    SourceLocation RAngleLoc);
+                    const CXXScopeSpec &SS, SourceLocation TemplateLoc,
+                    TemplateTy TemplateName, IdentifierInfo *TemplateII,
+                    SourceLocation TemplateIILoc, SourceLocation LAngleLoc,
+                    ASTTemplateArgsPtr TemplateArgs, SourceLocation RAngleLoc);
 
   QualType CheckTypenameType(ElaboratedTypeKeyword Keyword,
                              SourceLocation KeywordLoc,
                              NestedNameSpecifierLoc QualifierLoc,
-                             const IdentifierInfo &II,
-                             SourceLocation IILoc,
-                             TypeSourceInfo **TSI,
-                             bool DeducedTSTContext);
+                             const IdentifierInfo &II, SourceLocation IILoc,
+                             TypeSourceInfo **TSI, bool DeducedTSTContext);
 
   QualType CheckTypenameType(ElaboratedTypeKeyword Keyword,
                              SourceLocation KeywordLoc,
                              NestedNameSpecifierLoc QualifierLoc,
-                             const IdentifierInfo &II,
-                             SourceLocation IILoc,
+                             const IdentifierInfo &II, SourceLocation IILoc,
                              bool DeducedTSTContext = true);
 
-
   TypeSourceInfo *RebuildTypeInCurrentInstantiation(TypeSourceInfo *T,
                                                     SourceLocation Loc,
                                                     DeclarationName Name);
   bool RebuildNestedNameSpecifierInCurrentInstantiation(CXXScopeSpec &SS);
 
   ExprResult RebuildExprInCurrentInstantiation(Expr *E);
-  bool RebuildTemplateParamsInCurrentInstantiation(
-                                                TemplateParameterList *Params);
+  bool
+  RebuildTemplateParamsInCurrentInstantiation(TemplateParameterList *Params);
 
   std::string
   getTemplateArgumentBindingsText(const TemplateParameterList *Params,
@@ -8053,9 +7764,10 @@ public:
   //===--------------------------------------------------------------------===//
   // C++ Concepts
   //===--------------------------------------------------------------------===//
-  Decl *ActOnConceptDefinition(
-      Scope *S, MultiTemplateParamsArg TemplateParameterLists,
-      IdentifierInfo *Name, SourceLocation NameLoc, Expr *ConstraintExpr);
+  Decl *ActOnConceptDefinition(Scope *S,
+                               MultiTemplateParamsArg TemplateParameterLists,
+                               IdentifierInfo *Name, SourceLocation NameLoc,
+                               Expr *ConstraintExpr);
 
   RequiresExprBodyDecl *
   ActOnStartRequiresExpr(SourceLocation RequiresKWLoc,
@@ -8063,32 +7775,29 @@ public:
                          Scope *BodyScope);
   void ActOnFinishRequiresExpr();
   concepts::Requirement *ActOnSimpleRequirement(Expr *E);
-  concepts::Requirement *ActOnTypeRequirement(
-      SourceLocation TypenameKWLoc, CXXScopeSpec &SS, SourceLocation NameLoc,
-      IdentifierInfo *TypeName, TemplateIdAnnotation *TemplateId);
+  concepts::Requirement *ActOnTypeRequirement(SourceLocation TypenameKWLoc,
+                                              CXXScopeSpec &SS,
+                                              SourceLocation NameLoc,
+                                              IdentifierInfo *TypeName,
+                                              TemplateIdAnnotation *TemplateId);
   concepts::Requirement *ActOnCompoundRequirement(Expr *E,
                                                   SourceLocation NoexceptLoc);
-  concepts::Requirement *
-  ActOnCompoundRequirement(
+  concepts::Requirement *ActOnCompoundRequirement(
       Expr *E, SourceLocation NoexceptLoc, CXXScopeSpec &SS,
       TemplateIdAnnotation *TypeConstraint, unsigned Depth);
   concepts::Requirement *ActOnNestedRequirement(Expr *Constraint);
-  concepts::ExprRequirement *
-  BuildExprRequirement(
+  concepts::ExprRequirement *BuildExprRequirement(
       Expr *E, bool IsSatisfied, SourceLocation NoexceptLoc,
       concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement);
-  concepts::ExprRequirement *
-  BuildExprRequirement(
+  concepts::ExprRequirement *BuildExprRequirement(
       concepts::Requirement::SubstitutionDiagnostic *ExprSubstDiag,
       bool IsSatisfied, SourceLocation NoexceptLoc,
       concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement);
   concepts::TypeRequirement *BuildTypeRequirement(TypeSourceInfo *Type);
-  concepts::TypeRequirement *
-  BuildTypeRequirement(
+  concepts::TypeRequirement *BuildTypeRequirement(
       concepts::Requirement::SubstitutionDiagnostic *SubstDiag);
   concepts::NestedRequirement *BuildNestedRequirement(Expr *E);
-  concepts::NestedRequirement *
-  BuildNestedRequirement(
+  concepts::NestedRequirement *BuildNestedRequirement(
       concepts::Requirement::SubstitutionDiagnostic *SubstDiag);
   ExprResult ActOnRequiresExpr(SourceLocation RequiresKWLoc,
                                RequiresExprBodyDecl *Body,
@@ -8190,9 +7899,9 @@ public:
   /// \param Unexpanded the set of unexpanded parameter packs.
   ///
   /// \returns true if an error occurred, false otherwise.
-  bool DiagnoseUnexpandedParameterPacks(SourceLocation Loc,
-                                        UnexpandedParameterPackContext UPPC,
-                                  ArrayRef<UnexpandedParameterPack> Unexpanded);
+  bool DiagnoseUnexpandedParameterPacks(
+      SourceLocation Loc, UnexpandedParameterPackContext UPPC,
+      ArrayRef<UnexpandedParameterPack> Unexpanded);
 
   /// If the given type contains an unexpanded parameter pack,
   /// diagnose the error.
@@ -8213,8 +7922,8 @@ public:
   /// parameter packs.
   ///
   /// \returns true if an error occurred, false otherwise.
-  bool DiagnoseUnexpandedParameterPack(Expr *E,
-                       UnexpandedParameterPackContext UPPC = UPPC_Expression);
+  bool DiagnoseUnexpandedParameterPack(
+      Expr *E, UnexpandedParameterPackContext UPPC = UPPC_Expression);
 
   /// If the given requirees-expression contains an unexpanded reference to one
   /// of its own parameter packs, diagnose the error.
@@ -8273,48 +7982,52 @@ public:
   ///
   /// \param Arg The template argument that will be traversed to find
   /// unexpanded parameter packs.
-  void collectUnexpandedParameterPacks(TemplateArgument Arg,
-                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
+  void collectUnexpandedParameterPacks(
+      TemplateArgument Arg,
+      SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
 
   /// Collect the set of unexpanded parameter packs within the given
   /// template argument.
   ///
   /// \param Arg The template argument that will be traversed to find
   /// unexpanded parameter packs.
-  void collectUnexpandedParameterPacks(TemplateArgumentLoc Arg,
-                    SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
+  void collectUnexpandedParameterPacks(
+      TemplateArgumentLoc Arg,
+      SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
 
   /// Collect the set of unexpanded parameter packs within the given
   /// type.
   ///
   /// \param T The type that will be traversed to find
   /// unexpanded parameter packs.
-  void collectUnexpandedParameterPacks(QualType T,
-                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
+  void collectUnexpandedParameterPacks(
+      QualType T, SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
 
   /// Collect the set of unexpanded parameter packs within the given
   /// type.
   ///
   /// \param TL The type that will be traversed to find
   /// unexpanded parameter packs.
-  void collectUnexpandedParameterPacks(TypeLoc TL,
-                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
+  void collectUnexpandedParameterPacks(
+      TypeLoc TL, SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
 
   /// Collect the set of unexpanded parameter packs within the given
   /// nested-name-specifier.
   ///
   /// \param NNS The nested-name-specifier that will be traversed to find
   /// unexpanded parameter packs.
-  void collectUnexpandedParameterPacks(NestedNameSpecifierLoc NNS,
-                         SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
+  void collectUnexpandedParameterPacks(
+      NestedNameSpecifierLoc NNS,
+      SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
 
   /// Collect the set of unexpanded parameter packs within the given
   /// name.
   ///
   /// \param NameInfo The name that will be traversed to find
   /// unexpanded parameter packs.
-  void collectUnexpandedParameterPacks(const DeclarationNameInfo &NameInfo,
-                         SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
+  void collectUnexpandedParameterPacks(
+      const DeclarationNameInfo &NameInfo,
+      SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);
 
   /// Invoked when parsing a template argument followed by an
   /// ellipsis, which creates a pack expansion.
@@ -8343,8 +8056,7 @@ public:
 
   /// Construct a pack expansion type from the pattern of the pack
   /// expansion.
-  QualType CheckPackExpansion(QualType Pattern,
-                              SourceRange PatternRange,
+  QualType CheckPackExpansion(QualType Pattern, SourceRange PatternRange,
                               SourceLocation EllipsisLoc,
                               Optional<unsigned> NumExpansions);
 
@@ -8401,13 +8113,11 @@ public:
   /// are to be instantiated with arguments of different lengths), false
   /// otherwise. If false, \c ShouldExpand (and possibly \c NumExpansions)
   /// must be set.
-  bool CheckParameterPacksForExpansion(SourceLocation EllipsisLoc,
-                                       SourceRange PatternRange,
-                             ArrayRef<UnexpandedParameterPack> Unexpanded,
-                             const MultiLevelTemplateArgumentList &TemplateArgs,
-                                       bool &ShouldExpand,
-                                       bool &RetainExpansion,
-                                       Optional<unsigned> &NumExpansions);
+  bool CheckParameterPacksForExpansion(
+      SourceLocation EllipsisLoc, SourceRange PatternRange,
+      ArrayRef<UnexpandedParameterPack> Unexpanded,
+      const MultiLevelTemplateArgumentList &TemplateArgs, bool &ShouldExpand,
+      bool &RetainExpansion, Optional<unsigned> &NumExpansions);
 
   /// Determine the number of arguments in the given pack expansion
   /// type.
@@ -8416,8 +8126,8 @@ public:
   /// consistent across all of the unexpanded parameter packs in its pattern.
   ///
   /// Returns an empty Optional if the type can't be expanded.
-  Optional<unsigned> getNumArgumentsInExpansion(QualType T,
-      const MultiLevelTemplateArgumentList &TemplateArgs);
+  Optional<unsigned> getNumArgumentsInExpansion(
+      QualType T, const MultiLevelTemplateArgumentList &TemplateArgs);
 
   /// Determine whether the given declarator contains any unexpanded
   /// parameter packs.
@@ -8445,8 +8155,7 @@ public:
   /// \param NumExpansions Will be set to the number of expansions that will
   /// be generated from this pack expansion, if known a priori.
   TemplateArgumentLoc getTemplateArgumentPackExpansionPattern(
-      TemplateArgumentLoc OrigLoc,
-      SourceLocation &Ellipsis,
+      TemplateArgumentLoc OrigLoc, SourceLocation &Ellipsis,
       Optional<unsigned> &NumExpansions) const;
 
   /// Given a template argument that contains an unexpanded parameter pack, but
@@ -8571,7 +8280,7 @@ public:
       sema::TemplateDeductionInfo &Info,
       SmallVectorImpl<OriginalCallArg> const *OriginalCallArgs = nullptr,
       bool PartialOverloading = false,
-      llvm::function_ref<bool()> CheckNonDependent = []{ return false; });
+      llvm::function_ref<bool()> CheckNonDependent = [] { return false; });
 
   TemplateDeductionResult DeduceTemplateArguments(
       FunctionTemplateDecl *FunctionTemplate,
@@ -8580,18 +8289,15 @@ public:
       bool PartialOverloading,
       llvm::function_ref<bool(ArrayRef<QualType>)> CheckNonDependent);
 
-  TemplateDeductionResult
-  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,
-                          TemplateArgumentListInfo *ExplicitTemplateArgs,
-                          QualType ArgFunctionType,
-                          FunctionDecl *&Specialization,
-                          sema::TemplateDeductionInfo &Info,
-                          bool IsAddressOfFunction = false);
+  TemplateDeductionResult DeduceTemplateArguments(
+      FunctionTemplateDecl *FunctionTemplate,
+      TemplateArgumentListInfo *ExplicitTemplateArgs, QualType ArgFunctionType,
+      FunctionDecl *&Specialization, sema::TemplateDeductionInfo &Info,
+      bool IsAddressOfFunction = false);
 
   TemplateDeductionResult
   DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,
-                          QualType ToType,
-                          CXXConversionDecl *&Specialization,
+                          QualType ToType, CXXConversionDecl *&Specialization,
                           sema::TemplateDeductionInfo &Info);
 
   TemplateDeductionResult
@@ -8604,7 +8310,7 @@ public:
   /// Substitute Replacement for \p auto in \p TypeWithAuto
   QualType SubstAutoType(QualType TypeWithAuto, QualType Replacement);
   /// Substitute Replacement for auto in TypeWithAuto
-  TypeSourceInfo* SubstAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,
+  TypeSourceInfo *SubstAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,
                                           QualType Replacement);
 
   // Substitute auto in TypeWithAuto for a Dependent auto type
@@ -8666,17 +8372,15 @@ public:
   UnresolvedSetIterator
   getMostSpecialized(UnresolvedSetIterator SBegin, UnresolvedSetIterator SEnd,
                      TemplateSpecCandidateSet &FailedCandidates,
-                     SourceLocation Loc,
-                     const PartialDiagnostic &NoneDiag,
+                     SourceLocation Loc, const PartialDiagnostic &NoneDiag,
                      const PartialDiagnostic &AmbigDiag,
                      const PartialDiagnostic &CandidateDiag,
                      bool Complain = true, QualType TargetType = QualType());
 
   ClassTemplatePartialSpecializationDecl *
   getMoreSpecializedPartialSpecialization(
-                                  ClassTemplatePartialSpecializationDecl *PS1,
-                                  ClassTemplatePartialSpecializationDecl *PS2,
-                                  SourceLocation Loc);
+      ClassTemplatePartialSpecializationDecl *PS1,
+      ClassTemplatePartialSpecializationDecl *PS2, SourceLocation Loc);
 
   bool isMoreSpecializedThanPrimary(ClassTemplatePartialSpecializationDecl *T,
                                     sema::TemplateDeductionInfo &Info);
@@ -8695,27 +8399,25 @@ public:
                                   unsigned Depth, llvm::SmallBitVector &Used);
 
   void MarkUsedTemplateParameters(const TemplateArgumentList &TemplateArgs,
-                                  bool OnlyDeduced,
-                                  unsigned Depth,
+                                  bool OnlyDeduced, unsigned Depth,
                                   llvm::SmallBitVector &Used);
-  void MarkDeducedTemplateParameters(
-                                  const FunctionTemplateDecl *FunctionTemplate,
-                                  llvm::SmallBitVector &Deduced) {
+  void
+  MarkDeducedTemplateParameters(const FunctionTemplateDecl *FunctionTemplate,
+                                llvm::SmallBitVector &Deduced) {
     return MarkDeducedTemplateParameters(Context, FunctionTemplate, Deduced);
   }
-  static void MarkDeducedTemplateParameters(ASTContext &Ctx,
-                                  const FunctionTemplateDecl *FunctionTemplate,
-                                  llvm::SmallBitVector &Deduced);
+  static void
+  MarkDeducedTemplateParameters(ASTContext &Ctx,
+                                const FunctionTemplateDecl *FunctionTemplate,
+                                llvm::SmallBitVector &Deduced);
 
   //===--------------------------------------------------------------------===//
   // C++ Template Instantiation
   //
 
-  MultiLevelTemplateArgumentList
-  getTemplateInstantiationArgs(NamedDecl *D,
-                               const TemplateArgumentList *Innermost = nullptr,
-                               bool RelativeToPrimary = false,
-                               const FunctionDecl *Pattern = nullptr);
+  MultiLevelTemplateArgumentList getTemplateInstantiationArgs(
+      NamedDecl *D, const TemplateArgumentList *Innermost = nullptr,
+      bool RelativeToPrimary = false, const FunctionDecl *Pattern = nullptr);
 
   /// A context in which code is being synthesized (where a source location
   /// alone is not sufficient to identify the context). This covers template
@@ -8885,21 +8587,21 @@ public:
 
   /// Extra modules inspected when performing a lookup during a template
   /// instantiation. Computed lazily.
-  SmallVector<Module*, 16> CodeSynthesisContextLookupModules;
+  SmallVector<Module *, 16> CodeSynthesisContextLookupModules;
 
   /// Cache of additional modules that should be used for name lookup
   /// within the current template instantiation. Computed lazily; use
   /// getLookupModules() to get a complete set.
-  llvm::DenseSet<Module*> LookupModulesCache;
+  llvm::DenseSet<Module *> LookupModulesCache;
 
   /// Get the set of additional modules that should be checked during
   /// name lookup. A module and its imports become visible when instanting a
   /// template defined within it.
-  llvm::DenseSet<Module*> &getLookupModules();
+  llvm::DenseSet<Module *> &getLookupModules();
 
   /// Map from the most recent declaration of a namespace to the most
   /// recent visible declaration of that namespace.
-  llvm::DenseMap<NamedDecl*, NamedDecl*> VisibleNamespaceCache;
+  llvm::DenseMap<NamedDecl *, NamedDecl *> VisibleNamespaceCache;
 
   /// Whether we are in a SFINAE context that is not associated with
   /// template instantiation.
@@ -8951,7 +8653,7 @@ public:
 
   public:
     ArgumentPackSubstitutionIndexRAII(Sema &Self, int NewSubstitutionIndex)
-      : Self(Self), OldSubstitutionIndex(Self.ArgumentPackSubstitutionIndex) {
+        : Self(Self), OldSubstitutionIndex(Self.ArgumentPackSubstitutionIndex) {
       Self.ArgumentPackSubstitutionIndex = NewSubstitutionIndex;
     }
 
@@ -8967,8 +8669,8 @@ public:
   /// deduction.
   ///
   /// FIXME: Serialize this structure to the AST file.
-  typedef llvm::DenseMap<Decl *, SmallVector<PartialDiagnosticAt, 1> >
-    SuppressedDiagnosticsMap;
+  typedef llvm::DenseMap<Decl *, SmallVector<PartialDiagnosticAt, 1>>
+      SuppressedDiagnosticsMap;
   SuppressedDiagnosticsMap SuppressedDiagnostics;
 
   /// A stack object to be created when performing template
@@ -9049,24 +8751,21 @@ public:
     /// Note that we are substituting prior template arguments into a
     /// non-type parameter.
     InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,
-                          NamedDecl *Template,
-                          NonTypeTemplateParmDecl *Param,
+                          NamedDecl *Template, NonTypeTemplateParmDecl *Param,
                           ArrayRef<TemplateArgument> TemplateArgs,
                           SourceRange InstantiationRange);
 
     /// Note that we are substituting prior template arguments into a
     /// template template parameter.
     InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,
-                          NamedDecl *Template,
-                          TemplateTemplateParmDecl *Param,
+                          NamedDecl *Template, TemplateTemplateParmDecl *Param,
                           ArrayRef<TemplateArgument> TemplateArgs,
                           SourceRange InstantiationRange);
 
     /// Note that we are checking the default template argument
     /// against the template parameter for a given template-id.
     InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,
-                          TemplateDecl *Template,
-                          NamedDecl *Param,
+                          TemplateDecl *Template, NamedDecl *Param,
                           ArrayRef<TemplateArgument> TemplateArgs,
                           SourceRange InstantiationRange);
 
@@ -9134,17 +8833,17 @@ public:
     bool CheckInstantiationDepth(SourceLocation PointOfInstantiation,
                                  SourceRange InstantiationRange);
 
-    InstantiatingTemplate(
-        Sema &SemaRef, CodeSynthesisContext::SynthesisKind Kind,
-        SourceLocation PointOfInstantiation, SourceRange InstantiationRange,
-        Decl *Entity, NamedDecl *Template = nullptr,
-        ArrayRef<TemplateArgument> TemplateArgs = None,
-        sema::TemplateDeductionInfo *DeductionInfo = nullptr);
+    InstantiatingTemplate(Sema &SemaRef,
+                          CodeSynthesisContext::SynthesisKind Kind,
+                          SourceLocation PointOfInstantiation,
+                          SourceRange InstantiationRange, Decl *Entity,
+                          NamedDecl *Template = nullptr,
+                          ArrayRef<TemplateArgument> TemplateArgs = None,
+                          sema::TemplateDeductionInfo *DeductionInfo = nullptr);
 
-    InstantiatingTemplate(const InstantiatingTemplate&) = delete;
+    InstantiatingTemplate(const InstantiatingTemplate &) = delete;
 
-    InstantiatingTemplate&
-    operator=(const InstantiatingTemplate&) = delete;
+    InstantiatingTemplate &operator=(const InstantiatingTemplate &) = delete;
   };
 
   void pushCodeSynthesisContext(CodeSynthesisContext Ctx);
@@ -9204,13 +8903,12 @@ public:
 
   public:
     explicit SFINAETrap(Sema &SemaRef, bool AccessCheckingSFINAE = false)
-      : SemaRef(SemaRef), PrevSFINAEErrors(SemaRef.NumSFINAEErrors),
-        PrevInNonInstantiationSFINAEContext(
-                                      SemaRef.InNonInstantiationSFINAEContext),
-        PrevAccessCheckingSFINAE(SemaRef.AccessCheckingSFINAE),
-        PrevLastDiagnosticIgnored(
-            SemaRef.getDiagnostics().isLastDiagnosticIgnored())
-    {
+        : SemaRef(SemaRef), PrevSFINAEErrors(SemaRef.NumSFINAEErrors),
+          PrevInNonInstantiationSFINAEContext(
+              SemaRef.InNonInstantiationSFINAEContext),
+          PrevAccessCheckingSFINAE(SemaRef.AccessCheckingSFINAE),
+          PrevLastDiagnosticIgnored(
+              SemaRef.getDiagnostics().isLastDiagnosticIgnored()) {
       if (!SemaRef.isSFINAEContext())
         SemaRef.InNonInstantiationSFINAEContext = true;
       SemaRef.AccessCheckingSFINAE = AccessCheckingSFINAE;
@@ -9218,8 +8916,8 @@ public:
 
     ~SFINAETrap() {
       SemaRef.NumSFINAEErrors = PrevSFINAEErrors;
-      SemaRef.InNonInstantiationSFINAEContext
-        = PrevInNonInstantiationSFINAEContext;
+      SemaRef.InNonInstantiationSFINAEContext =
+          PrevInNonInstantiationSFINAEContext;
       SemaRef.AccessCheckingSFINAE = PrevAccessCheckingSFINAE;
       SemaRef.getDiagnostics().setLastDiagnosticIgnored(
           PrevLastDiagnosticIgnored);
@@ -9240,6 +8938,7 @@ public:
     // FIXME: Using a SFINAETrap for this is a hack.
     SFINAETrap Trap;
     bool PrevDisableTypoCorrection;
+
   public:
     explicit TentativeAnalysisScope(Sema &SemaRef)
         : SemaRef(SemaRef), Trap(SemaRef, true),
@@ -9296,7 +8995,8 @@ public:
   public:
     GlobalEagerInstantiationScope(Sema &S, bool Enabled)
         : S(S), Enabled(Enabled) {
-      if (!Enabled) return;
+      if (!Enabled)
+        return;
 
       SavedPendingInstantiations.swap(S.PendingInstantiations);
       SavedVTableUses.swap(S.VTableUses);
@@ -9310,7 +9010,8 @@ public:
     }
 
     ~GlobalEagerInstantiationScope() {
-      if (!Enabled) return;
+      if (!Enabled)
+        return;
 
       // Restore the set of pending vtables.
       assert(S.VTableUses.empty() &&
@@ -9390,7 +9091,8 @@ public:
     /// ExtParameterInfo array we've built up.
     const FunctionProtoType::ExtParameterInfo *
     getPointerOrNull(unsigned numParams) {
-      if (!HasInteresting) return nullptr;
+      if (!HasInteresting)
+        return nullptr;
       Infos.resize(numParams);
       return Infos.data();
     }
@@ -9411,23 +9113,22 @@ public:
                             const MultiLevelTemplateArgumentList &TemplateArgs,
                             SourceLocation Loc, DeclarationName Entity);
 
-  TypeSourceInfo *SubstFunctionDeclType(TypeSourceInfo *T,
-                            const MultiLevelTemplateArgumentList &TemplateArgs,
-                                        SourceLocation Loc,
-                                        DeclarationName Entity,
-                                        CXXRecordDecl *ThisContext,
-                                        Qualifiers ThisTypeQuals);
+  TypeSourceInfo *
+  SubstFunctionDeclType(TypeSourceInfo *T,
+                        const MultiLevelTemplateArgumentList &TemplateArgs,
+                        SourceLocation Loc, DeclarationName Entity,
+                        CXXRecordDecl *ThisContext, Qualifiers ThisTypeQuals);
   void SubstExceptionSpec(FunctionDecl *New, const FunctionProtoType *Proto,
                           const MultiLevelTemplateArgumentList &Args);
   bool SubstExceptionSpec(SourceLocation Loc,
                           FunctionProtoType::ExceptionSpecInfo &ESI,
                           SmallVectorImpl<QualType> &ExceptionStorage,
                           const MultiLevelTemplateArgumentList &Args);
-  ParmVarDecl *SubstParmVarDecl(ParmVarDecl *D,
-                            const MultiLevelTemplateArgumentList &TemplateArgs,
-                                int indexAdjustment,
-                                Optional<unsigned> NumExpansions,
-                                bool ExpectParameterPack);
+  ParmVarDecl *
+  SubstParmVarDecl(ParmVarDecl *D,
+                   const MultiLevelTemplateArgumentList &TemplateArgs,
+                   int indexAdjustment, Optional<unsigned> NumExpansions,
+                   bool ExpectParameterPack);
   bool SubstParmTypes(SourceLocation Loc, ArrayRef<ParmVarDecl *> Params,
                       const FunctionProtoType::ExtParameterInfo *ExtParamInfos,
                       const MultiLevelTemplateArgumentList &TemplateArgs,
@@ -9466,7 +9167,6 @@ public:
                          const MultiLevelTemplateArgumentList &TemplateArgs,
                          TemplateArgumentListInfo &Outputs);
 
-
   Decl *SubstDecl(Decl *D, DeclContext *Owner,
                   const MultiLevelTemplateArgumentList &TemplateArgs);
 
@@ -9475,21 +9175,17 @@ public:
   FunctionDecl *SubstSpaceshipAsEqualEqual(CXXRecordDecl *RD,
                                            FunctionDecl *Spaceship);
 
-  ExprResult SubstInitializer(Expr *E,
-                       const MultiLevelTemplateArgumentList &TemplateArgs,
-                       bool CXXDirectInit);
+  ExprResult
+  SubstInitializer(Expr *E, const MultiLevelTemplateArgumentList &TemplateArgs,
+                   bool CXXDirectInit);
 
-  bool
-  SubstBaseSpecifiers(CXXRecordDecl *Instantiation,
-                      CXXRecordDecl *Pattern,
-                      const MultiLevelTemplateArgumentList &TemplateArgs);
+  bool SubstBaseSpecifiers(CXXRecordDecl *Instantiation, CXXRecordDecl *Pattern,
+                           const MultiLevelTemplateArgumentList &TemplateArgs);
 
-  bool
-  InstantiateClass(SourceLocation PointOfInstantiation,
-                   CXXRecordDecl *Instantiation, CXXRecordDecl *Pattern,
-                   const MultiLevelTemplateArgumentList &TemplateArgs,
-                   TemplateSpecializationKind TSK,
-                   bool Complain = true);
+  bool InstantiateClass(SourceLocation PointOfInstantiation,
+                        CXXRecordDecl *Instantiation, CXXRecordDecl *Pattern,
+                        const MultiLevelTemplateArgumentList &TemplateArgs,
+                        TemplateSpecializationKind TSK, bool Complain = true);
 
   bool InstantiateEnum(SourceLocation PointOfInstantiation,
                        EnumDecl *Instantiation, EnumDecl *Pattern,
@@ -9507,8 +9203,7 @@ public:
 
     LateInstantiatedAttribute(const Attr *A, LocalInstantiationScope *S,
                               Decl *D)
-      : TmplAttr(A), Scope(S), NewDecl(D)
-    { }
+        : TmplAttr(A), Scope(S), NewDecl(D) {}
   };
   typedef SmallVector<LateInstantiatedAttribute, 16> LateInstantiatedAttrVec;
 
@@ -9528,25 +9223,25 @@ public:
   bool usesPartialOrExplicitSpecialization(
       SourceLocation Loc, ClassTemplateSpecializationDecl *ClassTemplateSpec);
 
-  bool
-  InstantiateClassTemplateSpecialization(SourceLocation PointOfInstantiation,
-                           ClassTemplateSpecializationDecl *ClassTemplateSpec,
-                           TemplateSpecializationKind TSK,
-                           bool Complain = true);
+  bool InstantiateClassTemplateSpecialization(
+      SourceLocation PointOfInstantiation,
+      ClassTemplateSpecializationDecl *ClassTemplateSpec,
+      TemplateSpecializationKind TSK, bool Complain = true);
 
-  void InstantiateClassMembers(SourceLocation PointOfInstantiation,
-                               CXXRecordDecl *Instantiation,
-                            const MultiLevelTemplateArgumentList &TemplateArgs,
-                               TemplateSpecializationKind TSK);
+  void
+  InstantiateClassMembers(SourceLocation PointOfInstantiation,
+                          CXXRecordDecl *Instantiation,
+                          const MultiLevelTemplateArgumentList &TemplateArgs,
+                          TemplateSpecializationKind TSK);
 
   void InstantiateClassTemplateSpecializationMembers(
-                                          SourceLocation PointOfInstantiation,
-                           ClassTemplateSpecializationDecl *ClassTemplateSpec,
-                                                TemplateSpecializationKind TSK);
+      SourceLocation PointOfInstantiation,
+      ClassTemplateSpecializationDecl *ClassTemplateSpec,
+      TemplateSpecializationKind TSK);
 
-  NestedNameSpecifierLoc
-  SubstNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS,
-                           const MultiLevelTemplateArgumentList &TemplateArgs);
+  NestedNameSpecifierLoc SubstNestedNameSpecifierLoc(
+      NestedNameSpecifierLoc NNS,
+      const MultiLevelTemplateArgumentList &TemplateArgs);
 
   DeclarationNameInfo
   SubstDeclarationNameInfo(const DeclarationNameInfo &NameInfo,
@@ -9603,14 +9298,16 @@ public:
                                      bool DefinitionRequired = false,
                                      bool AtEndOfTU = false);
 
-  void InstantiateMemInitializers(CXXConstructorDecl *New,
-                                  const CXXConstructorDecl *Tmpl,
-                            const MultiLevelTemplateArgumentList &TemplateArgs);
+  void InstantiateMemInitializers(
+      CXXConstructorDecl *New, const CXXConstructorDecl *Tmpl,
+      const MultiLevelTemplateArgumentList &TemplateArgs);
 
-  NamedDecl *FindInstantiatedDecl(SourceLocation Loc, NamedDecl *D,
-                          const MultiLevelTemplateArgumentList &TemplateArgs,
-                          bool FindingInstantiatedContext = false);
-  DeclContext *FindInstantiatedContext(SourceLocation Loc, DeclContext *DC,
+  NamedDecl *
+  FindInstantiatedDecl(SourceLocation Loc, NamedDecl *D,
+                       const MultiLevelTemplateArgumentList &TemplateArgs,
+                       bool FindingInstantiatedContext = false);
+  DeclContext *
+  FindInstantiatedContext(SourceLocation Loc, DeclContext *DC,
                           const MultiLevelTemplateArgumentList &TemplateArgs);
 
   // Objective-C declarations.
@@ -9625,14 +9322,11 @@ public:
   };
   ObjCContainerKind getObjCContainerKind() const;
 
-  DeclResult actOnObjCTypeParam(Scope *S,
-                                ObjCTypeParamVariance variance,
-                                SourceLocation varianceLoc,
-                                unsigned index,
+  DeclResult actOnObjCTypeParam(Scope *S, ObjCTypeParamVariance variance,
+                                SourceLocation varianceLoc, unsigned index,
                                 IdentifierInfo *paramName,
                                 SourceLocation paramLoc,
-                                SourceLocation colonLoc,
-                                ParsedType typeBound);
+                                SourceLocation colonLoc, ParsedType typeBound);
 
   ObjCTypeParamList *actOnObjCTypeParamList(Scope *S, SourceLocation lAngleLoc,
                                             ArrayRef<Decl *> typeParams,
@@ -9648,30 +9342,26 @@ public:
       const SourceLocation *ProtoLocs, SourceLocation EndProtoLoc,
       const ParsedAttributesView &AttrList);
 
-  void ActOnSuperClassOfClassInterface(Scope *S,
-                                       SourceLocation AtInterfaceLoc,
-                                       ObjCInterfaceDecl *IDecl,
-                                       IdentifierInfo *ClassName,
-                                       SourceLocation ClassLoc,
-                                       IdentifierInfo *SuperName,
-                                       SourceLocation SuperLoc,
-                                       ArrayRef<ParsedType> SuperTypeArgs,
-                                       SourceRange SuperTypeArgsRange);
+  void ActOnSuperClassOfClassInterface(
+      Scope *S, SourceLocation AtInterfaceLoc, ObjCInterfaceDecl *IDecl,
+      IdentifierInfo *ClassName, SourceLocation ClassLoc,
+      IdentifierInfo *SuperName, SourceLocation SuperLoc,
+      ArrayRef<ParsedType> SuperTypeArgs, SourceRange SuperTypeArgsRange);
 
   void ActOnTypedefedProtocols(SmallVectorImpl<Decl *> &ProtocolRefs,
                                SmallVectorImpl<SourceLocation> &ProtocolLocs,
                                IdentifierInfo *SuperName,
                                SourceLocation SuperLoc);
 
-  Decl *ActOnCompatibilityAlias(
-                    SourceLocation AtCompatibilityAliasLoc,
-                    IdentifierInfo *AliasName,  SourceLocation AliasLocation,
-                    IdentifierInfo *ClassName, SourceLocation ClassLocation);
+  Decl *ActOnCompatibilityAlias(SourceLocation AtCompatibilityAliasLoc,
+                                IdentifierInfo *AliasName,
+                                SourceLocation AliasLocation,
+                                IdentifierInfo *ClassName,
+                                SourceLocation ClassLocation);
 
   bool CheckForwardProtocolDeclarationForCircularDependency(
-    IdentifierInfo *PName,
-    SourceLocation &PLoc, SourceLocation PrevLoc,
-    const ObjCList<ObjCProtocolDecl> &PList);
+      IdentifierInfo *PName, SourceLocation &PLoc, SourceLocation PrevLoc,
+      const ObjCList<ObjCProtocolDecl> &PList);
 
   Decl *ActOnStartProtocolInterface(
       SourceLocation AtProtoInterfaceLoc, IdentifierInfo *ProtocolName,
@@ -9704,11 +9394,9 @@ public:
   DeclGroupPtrTy ActOnFinishObjCImplementation(Decl *ObjCImpDecl,
                                                ArrayRef<Decl *> Decls);
 
-  DeclGroupPtrTy ActOnForwardClassDeclaration(SourceLocation Loc,
-                   IdentifierInfo **IdentList,
-                   SourceLocation *IdentLocs,
-                   ArrayRef<ObjCTypeParamList *> TypeParamLists,
-                   unsigned NumElts);
+  DeclGroupPtrTy ActOnForwardClassDeclaration(
+      SourceLocation Loc, IdentifierInfo **IdentList, SourceLocation *IdentLocs,
+      ArrayRef<ObjCTypeParamList *> TypeParamLists, unsigned NumElts);
 
   DeclGroupPtrTy
   ActOnForwardProtocolDeclaration(SourceLocation AtProtoclLoc,
@@ -9729,40 +9417,27 @@ public:
   /// names to either Objective-C protocol qualifiers or type
   /// arguments, as appropriate.
   void actOnObjCTypeArgsOrProtocolQualifiers(
-         Scope *S,
-         ParsedType baseType,
-         SourceLocation lAngleLoc,
-         ArrayRef<IdentifierInfo *> identifiers,
-         ArrayRef<SourceLocation> identifierLocs,
-         SourceLocation rAngleLoc,
-         SourceLocation &typeArgsLAngleLoc,
-         SmallVectorImpl<ParsedType> &typeArgs,
-         SourceLocation &typeArgsRAngleLoc,
-         SourceLocation &protocolLAngleLoc,
-         SmallVectorImpl<Decl *> &protocols,
-         SourceLocation &protocolRAngleLoc,
-         bool warnOnIncompleteProtocols);
+      Scope *S, ParsedType baseType, SourceLocation lAngleLoc,
+      ArrayRef<IdentifierInfo *> identifiers,
+      ArrayRef<SourceLocation> identifierLocs, SourceLocation rAngleLoc,
+      SourceLocation &typeArgsLAngleLoc, SmallVectorImpl<ParsedType> &typeArgs,
+      SourceLocation &typeArgsRAngleLoc, SourceLocation &protocolLAngleLoc,
+      SmallVectorImpl<Decl *> &protocols, SourceLocation &protocolRAngleLoc,
+      bool warnOnIncompleteProtocols);
 
   /// Build a an Objective-C protocol-qualified 'id' type where no
   /// base type was specified.
   TypeResult actOnObjCProtocolQualifierType(
-               SourceLocation lAngleLoc,
-               ArrayRef<Decl *> protocols,
-               ArrayRef<SourceLocation> protocolLocs,
-               SourceLocation rAngleLoc);
+      SourceLocation lAngleLoc, ArrayRef<Decl *> protocols,
+      ArrayRef<SourceLocation> protocolLocs, SourceLocation rAngleLoc);
 
   /// Build a specialized and/or protocol-qualified Objective-C type.
   TypeResult actOnObjCTypeArgsAndProtocolQualifiers(
-               Scope *S,
-               SourceLocation Loc,
-               ParsedType BaseType,
-               SourceLocation TypeArgsLAngleLoc,
-               ArrayRef<ParsedType> TypeArgs,
-               SourceLocation TypeArgsRAngleLoc,
-               SourceLocation ProtocolLAngleLoc,
-               ArrayRef<Decl *> Protocols,
-               ArrayRef<SourceLocation> ProtocolLocs,
-               SourceLocation ProtocolRAngleLoc);
+      Scope *S, SourceLocation Loc, ParsedType BaseType,
+      SourceLocation TypeArgsLAngleLoc, ArrayRef<ParsedType> TypeArgs,
+      SourceLocation TypeArgsRAngleLoc, SourceLocation ProtocolLAngleLoc,
+      ArrayRef<Decl *> Protocols, ArrayRef<SourceLocation> ProtocolLocs,
+      SourceLocation ProtocolRAngleLoc);
 
   /// Build an Objective-C type parameter type.
   QualType BuildObjCTypeParamType(const ObjCTypeParamDecl *Decl,
@@ -9773,22 +9448,17 @@ public:
                                   bool FailOnError = false);
 
   /// Build an Objective-C object pointer type.
-  QualType BuildObjCObjectType(QualType BaseType,
-                               SourceLocation Loc,
-                               SourceLocation TypeArgsLAngleLoc,
-                               ArrayRef<TypeSourceInfo *> TypeArgs,
-                               SourceLocation TypeArgsRAngleLoc,
-                               SourceLocation ProtocolLAngleLoc,
-                               ArrayRef<ObjCProtocolDecl *> Protocols,
-                               ArrayRef<SourceLocation> ProtocolLocs,
-                               SourceLocation ProtocolRAngleLoc,
-                               bool FailOnError = false);
+  QualType BuildObjCObjectType(
+      QualType BaseType, SourceLocation Loc, SourceLocation TypeArgsLAngleLoc,
+      ArrayRef<TypeSourceInfo *> TypeArgs, SourceLocation TypeArgsRAngleLoc,
+      SourceLocation ProtocolLAngleLoc, ArrayRef<ObjCProtocolDecl *> Protocols,
+      ArrayRef<SourceLocation> ProtocolLocs, SourceLocation ProtocolRAngleLoc,
+      bool FailOnError = false);
 
   /// Ensure attributes are consistent with type.
   /// \param [in, out] Attributes The attributes to check; they will
   /// be modified to be consistent with \p PropertyTy.
-  void CheckObjCPropertyAttributes(Decl *PropertyPtrTy,
-                                   SourceLocation Loc,
+  void CheckObjCPropertyAttributes(Decl *PropertyPtrTy, SourceLocation Loc,
                                    unsigned &Attributes,
                                    bool propertyInPrimaryClass);
 
@@ -9797,7 +9467,6 @@ public:
   /// \param property The property declaration being processed
   void ProcessPropertyDecl(ObjCPropertyDecl *property);
 
-
   void DiagnosePropertyMismatch(ObjCPropertyDecl *Property,
                                 ObjCPropertyDecl *SuperProperty,
                                 const IdentifierInfo *Name,
@@ -9810,17 +9479,14 @@ public:
                    ArrayRef<Decl *> allMethods = None,
                    ArrayRef<DeclGroupPtrTy> allTUVars = None);
 
-  Decl *ActOnProperty(Scope *S, SourceLocation AtLoc,
-                      SourceLocation LParenLoc,
+  Decl *ActOnProperty(Scope *S, SourceLocation AtLoc, SourceLocation LParenLoc,
                       FieldDeclarator &FD, ObjCDeclSpec &ODS,
                       Selector GetterSel, Selector SetterSel,
                       tok::ObjCKeywordKind MethodImplKind,
                       DeclContext *lexicalDC = nullptr);
 
-  Decl *ActOnPropertyImplDecl(Scope *S,
-                              SourceLocation AtLoc,
-                              SourceLocation PropertyLoc,
-                              bool ImplKind,
+  Decl *ActOnPropertyImplDecl(Scope *S, SourceLocation AtLoc,
+                              SourceLocation PropertyLoc, bool ImplKind,
                               IdentifierInfo *PropertyId,
                               IdentifierInfo *PropertyIvar,
                               SourceLocation PropertyIvarLoc,
@@ -9871,20 +9537,17 @@ public:
 
   void deduceOpenCLAddressSpace(ValueDecl *decl);
 
-  ExprResult
-  HandleExprPropertyRefExpr(const ObjCObjectPointerType *OPT,
-                            Expr *BaseExpr,
-                            SourceLocation OpLoc,
-                            DeclarationName MemberName,
-                            SourceLocation MemberLoc,
-                            SourceLocation SuperLoc, QualType SuperType,
-                            bool Super);
+  ExprResult HandleExprPropertyRefExpr(const ObjCObjectPointerType *OPT,
+                                       Expr *BaseExpr, SourceLocation OpLoc,
+                                       DeclarationName MemberName,
+                                       SourceLocation MemberLoc,
+                                       SourceLocation SuperLoc,
+                                       QualType SuperType, bool Super);
 
-  ExprResult
-  ActOnClassPropertyRefExpr(IdentifierInfo &receiverName,
-                            IdentifierInfo &propertyName,
-                            SourceLocation receiverNameLoc,
-                            SourceLocation propertyNameLoc);
+  ExprResult ActOnClassPropertyRefExpr(IdentifierInfo &receiverName,
+                                       IdentifierInfo &propertyName,
+                                       SourceLocation receiverNameLoc,
+                                       SourceLocation propertyNameLoc);
 
   ObjCMethodDecl *tryCaptureObjCSelf(SourceLocation Loc);
 
@@ -9900,84 +9563,61 @@ public:
     ObjCClassMessage
   };
 
-  ObjCMessageKind getObjCMessageKind(Scope *S,
-                                     IdentifierInfo *Name,
-                                     SourceLocation NameLoc,
-                                     bool IsSuper,
+  ObjCMessageKind getObjCMessageKind(Scope *S, IdentifierInfo *Name,
+                                     SourceLocation NameLoc, bool IsSuper,
                                      bool HasTrailingDot,
                                      ParsedType &ReceiverType);
 
-  ExprResult ActOnSuperMessage(Scope *S, SourceLocation SuperLoc,
-                               Selector Sel,
+  ExprResult ActOnSuperMessage(Scope *S, SourceLocation SuperLoc, Selector Sel,
                                SourceLocation LBracLoc,
                                ArrayRef<SourceLocation> SelectorLocs,
-                               SourceLocation RBracLoc,
-                               MultiExprArg Args);
+                               SourceLocation RBracLoc, MultiExprArg Args);
 
   ExprResult BuildClassMessage(TypeSourceInfo *ReceiverTypeInfo,
-                               QualType ReceiverType,
-                               SourceLocation SuperLoc,
-                               Selector Sel,
-                               ObjCMethodDecl *Method,
+                               QualType ReceiverType, SourceLocation SuperLoc,
+                               Selector Sel, ObjCMethodDecl *Method,
                                SourceLocation LBracLoc,
                                ArrayRef<SourceLocation> SelectorLocs,
-                               SourceLocation RBracLoc,
-                               MultiExprArg Args,
+                               SourceLocation RBracLoc, MultiExprArg Args,
                                bool isImplicit = false);
 
   ExprResult BuildClassMessageImplicit(QualType ReceiverType,
-                                       bool isSuperReceiver,
-                                       SourceLocation Loc,
-                                       Selector Sel,
-                                       ObjCMethodDecl *Method,
+                                       bool isSuperReceiver, SourceLocation Loc,
+                                       Selector Sel, ObjCMethodDecl *Method,
                                        MultiExprArg Args);
 
-  ExprResult ActOnClassMessage(Scope *S,
-                               ParsedType Receiver,
-                               Selector Sel,
+  ExprResult ActOnClassMessage(Scope *S, ParsedType Receiver, Selector Sel,
                                SourceLocation LBracLoc,
                                ArrayRef<SourceLocation> SelectorLocs,
-                               SourceLocation RBracLoc,
-                               MultiExprArg Args);
+                               SourceLocation RBracLoc, MultiExprArg Args);
 
-  ExprResult BuildInstanceMessage(Expr *Receiver,
-                                  QualType ReceiverType,
-                                  SourceLocation SuperLoc,
-                                  Selector Sel,
+  ExprResult BuildInstanceMessage(Expr *Receiver, QualType ReceiverType,
+                                  SourceLocation SuperLoc, Selector Sel,
                                   ObjCMethodDecl *Method,
                                   SourceLocation LBracLoc,
                                   ArrayRef<SourceLocation> SelectorLocs,
-                                  SourceLocation RBracLoc,
-                                  MultiExprArg Args,
+                                  SourceLocation RBracLoc, MultiExprArg Args,
                                   bool isImplicit = false);
 
-  ExprResult BuildInstanceMessageImplicit(Expr *Receiver,
-                                          QualType ReceiverType,
-                                          SourceLocation Loc,
-                                          Selector Sel,
+  ExprResult BuildInstanceMessageImplicit(Expr *Receiver, QualType ReceiverType,
+                                          SourceLocation Loc, Selector Sel,
                                           ObjCMethodDecl *Method,
                                           MultiExprArg Args);
 
-  ExprResult ActOnInstanceMessage(Scope *S,
-                                  Expr *Receiver,
-                                  Selector Sel,
+  ExprResult ActOnInstanceMessage(Scope *S, Expr *Receiver, Selector Sel,
                                   SourceLocation LBracLoc,
                                   ArrayRef<SourceLocation> SelectorLocs,
-                                  SourceLocation RBracLoc,
-                                  MultiExprArg Args);
+                                  SourceLocation RBracLoc, MultiExprArg Args);
 
   ExprResult BuildObjCBridgedCast(SourceLocation LParenLoc,
                                   ObjCBridgeCastKind Kind,
                                   SourceLocation BridgeKeywordLoc,
-                                  TypeSourceInfo *TSInfo,
-                                  Expr *SubExpr);
+                                  TypeSourceInfo *TSInfo, Expr *SubExpr);
 
-  ExprResult ActOnObjCBridgedCast(Scope *S,
-                                  SourceLocation LParenLoc,
+  ExprResult ActOnObjCBridgedCast(Scope *S, SourceLocation LParenLoc,
                                   ObjCBridgeCastKind Kind,
                                   SourceLocation BridgeKeywordLoc,
-                                  ParsedType Type,
-                                  SourceLocation RParenLoc,
+                                  ParsedType Type, SourceLocation RParenLoc,
                                   Expr *SubExpr);
 
   void CheckTollFreeBridgeCast(QualType castType, Expr *castExpr);
@@ -9987,17 +9627,17 @@ public:
   bool CheckTollFreeBridgeStaticCast(QualType castType, Expr *castExpr,
                                      CastKind &Kind);
 
-  bool checkObjCBridgeRelatedComponents(SourceLocation Loc,
-                                        QualType DestType, QualType SrcType,
+  bool checkObjCBridgeRelatedComponents(SourceLocation Loc, QualType DestType,
+                                        QualType SrcType,
                                         ObjCInterfaceDecl *&RelatedClass,
                                         ObjCMethodDecl *&ClassMethod,
                                         ObjCMethodDecl *&InstanceMethod,
-                                        TypedefNameDecl *&TDNDecl,
-                                        bool CfToNs, bool Diagnose = true);
+                                        TypedefNameDecl *&TDNDecl, bool CfToNs,
+                                        bool Diagnose = true);
 
-  bool CheckObjCBridgeRelatedConversions(SourceLocation Loc,
-                                         QualType DestType, QualType SrcType,
-                                         Expr *&SrcExpr, bool Diagnose = true);
+  bool CheckObjCBridgeRelatedConversions(SourceLocation Loc, QualType DestType,
+                                         QualType SrcType, Expr *&SrcExpr,
+                                         bool Diagnose = true);
 
   bool CheckConversionToObjCLiteral(QualType DstType, Expr *&SrcExpr,
                                     bool Diagnose = true);
@@ -10035,7 +9675,8 @@ public:
   /// ActOnPragmaClangSection - Called on well formed \#pragma clang section
   void ActOnPragmaClangSection(SourceLocation PragmaLoc,
                                PragmaClangSectionAction Action,
-                               PragmaClangSectionKind SecKind, StringRef SecName);
+                               PragmaClangSectionKind SecKind,
+                               StringRef SecName);
 
   /// ActOnPragmaOptionsAlign - Called on well formed \#pragma options align.
   void ActOnPragmaOptionsAlign(PragmaOptionsAlignKind Kind,
@@ -10071,8 +9712,7 @@ public:
 
   /// Called on well formed \#pragma vtordisp().
   void ActOnPragmaMSVtorDisp(PragmaMsStackAction Action,
-                             SourceLocation PragmaLoc,
-                             MSVtorDispMode Value);
+                             SourceLocation PragmaLoc, MSVtorDispMode Value);
 
   enum PragmaSectionKind {
     PSK_DataSeg,
@@ -10083,20 +9723,18 @@ public:
 
   bool UnifySection(StringRef SectionName, int SectionFlags,
                     NamedDecl *TheDecl);
-  bool UnifySection(StringRef SectionName,
-                    int SectionFlags,
+  bool UnifySection(StringRef SectionName, int SectionFlags,
                     SourceLocation PragmaSectionLocation);
 
   /// Called on well formed \#pragma bss_seg/data_seg/const_seg/code_seg.
   void ActOnPragmaMSSeg(SourceLocation PragmaLocation,
                         PragmaMsStackAction Action,
                         llvm::StringRef StackSlotLabel,
-                        StringLiteral *SegmentName,
-                        llvm::StringRef PragmaName);
+                        StringLiteral *SegmentName, llvm::StringRef PragmaName);
 
   /// Called on well formed \#pragma section().
-  void ActOnPragmaMSSection(SourceLocation PragmaLocation,
-                            int SectionFlags, StringLiteral *SegmentName);
+  void ActOnPragmaMSSection(SourceLocation PragmaLocation, int SectionFlags,
+                            StringLiteral *SegmentName);
 
   /// Called on well-formed \#pragma init_seg().
   void ActOnPragmaMSInitSeg(SourceLocation PragmaLocation,
@@ -10122,12 +9760,11 @@ public:
                                PragmaFloatControlKind Value);
 
   /// ActOnPragmaUnused - Called on well-formed '\#pragma unused'.
-  void ActOnPragmaUnused(const Token &Identifier,
-                         Scope *curScope,
+  void ActOnPragmaUnused(const Token &Identifier, Scope *curScope,
                          SourceLocation PragmaLoc);
 
   /// ActOnPragmaVisibility - Called on well formed \#pragma GCC visibility... .
-  void ActOnPragmaVisibility(const IdentifierInfo* VisType,
+  void ActOnPragmaVisibility(const IdentifierInfo *VisType,
                              SourceLocation PragmaLoc);
 
   NamedDecl *DeclClonePragmaWeak(NamedDecl *ND, IdentifierInfo *II,
@@ -10135,21 +9772,19 @@ public:
   void DeclApplyPragmaWeak(Scope *S, NamedDecl *ND, WeakInfo &W);
 
   /// ActOnPragmaWeakID - Called on well formed \#pragma weak ident.
-  void ActOnPragmaWeakID(IdentifierInfo* WeakName,
-                         SourceLocation PragmaLoc,
+  void ActOnPragmaWeakID(IdentifierInfo *WeakName, SourceLocation PragmaLoc,
                          SourceLocation WeakNameLoc);
 
   /// ActOnPragmaRedefineExtname - Called on well formed
   /// \#pragma redefine_extname oldname newname.
-  void ActOnPragmaRedefineExtname(IdentifierInfo* WeakName,
-                                  IdentifierInfo* AliasName,
+  void ActOnPragmaRedefineExtname(IdentifierInfo *WeakName,
+                                  IdentifierInfo *AliasName,
                                   SourceLocation PragmaLoc,
                                   SourceLocation WeakNameLoc,
                                   SourceLocation AliasNameLoc);
 
   /// ActOnPragmaWeakAlias - Called on well formed \#pragma weak ident = ident.
-  void ActOnPragmaWeakAlias(IdentifierInfo* WeakName,
-                            IdentifierInfo* AliasName,
+  void ActOnPragmaWeakAlias(IdentifierInfo *WeakName, IdentifierInfo *AliasName,
                             SourceLocation PragmaLoc,
                             SourceLocation WeakNameLoc,
                             SourceLocation AliasNameLoc);
@@ -10276,7 +9911,7 @@ public:
   void AddParameterABIAttr(Decl *D, const AttributeCommonInfo &CI,
                            ParameterABI ABI);
 
-  enum class RetainOwnershipKind {NS, CF, OS};
+  enum class RetainOwnershipKind { NS, CF, OS };
   void AddXConsumedAttr(Decl *D, const AttributeCommonInfo &CI,
                         RetainOwnershipKind K, bool IsTemplateInstantiation);
 
@@ -10304,7 +9939,7 @@ public:
   ExprResult BuildResolvedCoawaitExpr(SourceLocation KwLoc, Expr *E,
                                       bool IsImplicit = false);
   ExprResult BuildUnresolvedCoawaitExpr(SourceLocation KwLoc, Expr *E,
-                                        UnresolvedLookupExpr* Lookup);
+                                        UnresolvedLookupExpr *Lookup);
   ExprResult BuildCoyieldExpr(SourceLocation KwLoc, Expr *E);
   StmtResult BuildCoreturnStmt(SourceLocation KwLoc, Expr *E,
                                bool IsImplicit = false);
@@ -10553,9 +10188,8 @@ public:
                                      const DeclarationNameInfo &Id,
                                      OpenMPDirectiveKind Kind);
   /// Called on well-formed '#pragma omp threadprivate'.
-  DeclGroupPtrTy ActOnOpenMPThreadprivateDirective(
-                                     SourceLocation Loc,
-                                     ArrayRef<Expr *> VarList);
+  DeclGroupPtrTy ActOnOpenMPThreadprivateDirective(SourceLocation Loc,
+                                                   ArrayRef<Expr *> VarList);
   /// Builds a new OpenMPThreadPrivateDecl and checks its correctness.
   OMPThreadPrivateDecl *CheckOMPThreadPrivateDecl(SourceLocation Loc,
                                                   ArrayRef<Expr *> VarList);
@@ -10697,8 +10331,7 @@ public:
   /// Called on well-formed '\#pragma omp parallel' after parsing
   /// of the  associated statement.
   StmtResult ActOnOpenMPParallelDirective(ArrayRef<OMPClause *> Clauses,
-                                          Stmt *AStmt,
-                                          SourceLocation StartLoc,
+                                          Stmt *AStmt, SourceLocation StartLoc,
                                           SourceLocation EndLoc);
   using VarsWithInheritedDSAType =
       llvm::SmallDenseMap<const ValueDecl *, const Expr *, 4>;
@@ -10825,7 +10458,8 @@ public:
   /// Called on well-formed '\#pragma omp target data' after parsing of
   /// the associated statement.
   StmtResult ActOnOpenMPTargetDataDirective(ArrayRef<OMPClause *> Clauses,
-                                            Stmt *AStmt, SourceLocation StartLoc,
+                                            Stmt *AStmt,
+                                            SourceLocation StartLoc,
                                             SourceLocation EndLoc);
   /// Called on well-formed '\#pragma omp target enter data' after
   /// parsing of the associated statement.
@@ -11054,8 +10688,7 @@ public:
       SourceLocation AdjustArgsLoc, SourceLocation AppendArgsLoc,
       SourceRange SR);
 
-  OMPClause *ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind,
-                                         Expr *Expr,
+  OMPClause *ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind, Expr *Expr,
                                          SourceLocation StartLoc,
                                          SourceLocation LParenLoc,
                                          SourceLocation EndLoc);
@@ -11085,8 +10718,7 @@ public:
                                     SourceLocation LParenLoc,
                                     SourceLocation EndLoc);
   /// Called on well-formed 'safelen' clause.
-  OMPClause *ActOnOpenMPSafelenClause(Expr *Length,
-                                      SourceLocation StartLoc,
+  OMPClause *ActOnOpenMPSafelenClause(Expr *Length, SourceLocation StartLoc,
                                       SourceLocation LParenLoc,
                                       SourceLocation EndLoc);
   /// Called on well-formed 'simdlen' clause.
@@ -11132,8 +10764,7 @@ public:
                                      SourceLocation LParenLoc,
                                      SourceLocation EndLoc);
 
-  OMPClause *ActOnOpenMPSimpleClause(OpenMPClauseKind Kind,
-                                     unsigned Argument,
+  OMPClause *ActOnOpenMPSimpleClause(OpenMPClauseKind Kind, unsigned Argument,
                                      SourceLocation ArgumentLoc,
                                      SourceLocation StartLoc,
                                      SourceLocation LParenLoc,
@@ -11357,8 +10988,7 @@ public:
                           OpenMPLinearClauseKind LinKind, SourceLocation LinLoc,
                           SourceLocation ColonLoc, SourceLocation EndLoc);
   /// Called on well-formed 'aligned' clause.
-  OMPClause *ActOnOpenMPAlignedClause(ArrayRef<Expr *> VarList,
-                                      Expr *Alignment,
+  OMPClause *ActOnOpenMPAlignedClause(ArrayRef<Expr *> VarList, Expr *Alignment,
                                       SourceLocation StartLoc,
                                       SourceLocation LParenLoc,
                                       SourceLocation ColonLoc,
@@ -11722,8 +11352,7 @@ public:
   /// DiagnoseAssignmentResult - Emit a diagnostic, if required, for the
   /// assignment conversion type specified by ConvTy.  This returns true if the
   /// conversion was invalid or false if the conversion was accepted.
-  bool DiagnoseAssignmentResult(AssignConvertType ConvTy,
-                                SourceLocation Loc,
+  bool DiagnoseAssignmentResult(AssignConvertType ConvTy, SourceLocation Loc,
                                 QualType DstType, QualType SrcType,
                                 Expr *SrcExpr, AssignmentAction Action,
                                 bool *Complained = nullptr);
@@ -11750,8 +11379,7 @@ public:
   /// the RHS to the LHS type. The conversion is prepared for if ConvertRHS
   /// is true.
   AssignConvertType CheckAssignmentConstraints(QualType LHSType,
-                                               ExprResult &RHS,
-                                               CastKind &Kind,
+                                               ExprResult &RHS, CastKind &Kind,
                                                bool ConvertRHS = true);
 
   /// Check assignment constraints for an assignment of RHS to LHSType.
@@ -11784,13 +11412,13 @@ public:
   ExprResult PerformImplicitConversion(Expr *From, QualType ToType,
                                        AssignmentAction Action,
                                        bool AllowExplicit = false);
+  ExprResult
+  PerformImplicitConversion(Expr *From, QualType ToType,
+                            const ImplicitConversionSequence &ICS,
+                            AssignmentAction Action,
+                            CheckedConversionKind CCK = CCK_ImplicitConversion);
   ExprResult PerformImplicitConversion(Expr *From, QualType ToType,
-                                       const ImplicitConversionSequence& ICS,
-                                       AssignmentAction Action,
-                                       CheckedConversionKind CCK
-                                          = CCK_ImplicitConversion);
-  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,
-                                       const StandardConversionSequence& SCS,
+                                       const StandardConversionSequence &SCS,
                                        AssignmentAction Action,
                                        CheckedConversionKind CCK);
 
@@ -11805,25 +11433,25 @@ public:
   QualType InvalidOperands(SourceLocation Loc, ExprResult &LHS,
                            ExprResult &RHS);
   QualType InvalidLogicalVectorOperands(SourceLocation Loc, ExprResult &LHS,
-                                 ExprResult &RHS);
+                                        ExprResult &RHS);
   QualType CheckPointerToMemberOperands( // C++ 5.5
-    ExprResult &LHS, ExprResult &RHS, ExprValueKind &VK,
-    SourceLocation OpLoc, bool isIndirect);
+      ExprResult &LHS, ExprResult &RHS, ExprValueKind &VK, SourceLocation OpLoc,
+      bool isIndirect);
   QualType CheckMultiplyDivideOperands( // C99 6.5.5
-    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc, bool IsCompAssign,
-    bool IsDivide);
+      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc, bool IsCompAssign,
+      bool IsDivide);
   QualType CheckRemainderOperands( // C99 6.5.5
-    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
-    bool IsCompAssign = false);
+      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
+      bool IsCompAssign = false);
   QualType CheckAdditionOperands( // C99 6.5.6
-    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
-    BinaryOperatorKind Opc, QualType* CompLHSTy = nullptr);
+      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
+      BinaryOperatorKind Opc, QualType *CompLHSTy = nullptr);
   QualType CheckSubtractionOperands( // C99 6.5.6
-    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
-    QualType* CompLHSTy = nullptr);
+      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
+      QualType *CompLHSTy = nullptr);
   QualType CheckShiftOperands( // C99 6.5.7
-    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
-    BinaryOperatorKind Opc, bool IsCompAssign = false);
+      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
+      BinaryOperatorKind Opc, bool IsCompAssign = false);
   void CheckPtrComparisonWithNullChar(ExprResult &E, ExprResult &NullE);
   QualType CheckCompareOperands( // C99 6.5.8/9
       ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
@@ -11832,36 +11460,36 @@ public:
       ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
       BinaryOperatorKind Opc);
   QualType CheckLogicalOperands( // C99 6.5.[13,14]
-    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
-    BinaryOperatorKind Opc);
+      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,
+      BinaryOperatorKind Opc);
   // CheckAssignmentOperands is used for both simple and compound assignment.
   // For simple assignment, pass both expressions and a null converted type.
   // For compound assignment, pass both expressions and the converted type.
   QualType CheckAssignmentOperands( // C99 6.5.16.[1,2]
-    Expr *LHSExpr, ExprResult &RHS, SourceLocation Loc, QualType CompoundType);
+      Expr *LHSExpr, ExprResult &RHS, SourceLocation Loc,
+      QualType CompoundType);
 
   ExprResult checkPseudoObjectIncDec(Scope *S, SourceLocation OpLoc,
                                      UnaryOperatorKind Opcode, Expr *Op);
   ExprResult checkPseudoObjectAssignment(Scope *S, SourceLocation OpLoc,
-                                         BinaryOperatorKind Opcode,
-                                         Expr *LHS, Expr *RHS);
+                                         BinaryOperatorKind Opcode, Expr *LHS,
+                                         Expr *RHS);
   ExprResult checkPseudoObjectRValue(Expr *E);
   Expr *recreateSyntacticForm(PseudoObjectExpr *E);
 
   QualType CheckConditionalOperands( // C99 6.5.15
-    ExprResult &Cond, ExprResult &LHS, ExprResult &RHS,
-    ExprValueKind &VK, ExprObjectKind &OK, SourceLocation QuestionLoc);
+      ExprResult &Cond, ExprResult &LHS, ExprResult &RHS, ExprValueKind &VK,
+      ExprObjectKind &OK, SourceLocation QuestionLoc);
   QualType CXXCheckConditionalOperands( // C++ 5.16
-    ExprResult &cond, ExprResult &lhs, ExprResult &rhs,
-    ExprValueKind &VK, ExprObjectKind &OK, SourceLocation questionLoc);
+      ExprResult &cond, ExprResult &lhs, ExprResult &rhs, ExprValueKind &VK,
+      ExprObjectKind &OK, SourceLocation questionLoc);
   QualType CheckVectorConditionalTypes(ExprResult &Cond, ExprResult &LHS,
                                        ExprResult &RHS,
                                        SourceLocation QuestionLoc);
   QualType FindCompositePointerType(SourceLocation Loc, Expr *&E1, Expr *&E2,
                                     bool ConvertArgs = true);
-  QualType FindCompositePointerType(SourceLocation Loc,
-                                    ExprResult &E1, ExprResult &E2,
-                                    bool ConvertArgs = true) {
+  QualType FindCompositePointerType(SourceLocation Loc, ExprResult &E1,
+                                    ExprResult &E2, bool ConvertArgs = true) {
     Expr *E1Tmp = E1.get(), *E2Tmp = E2.get();
     QualType Composite =
         FindCompositePointerType(Loc, E1Tmp, E2Tmp, ConvertArgs);
@@ -11958,8 +11586,8 @@ public:
 
   /// Type-check an expression that's being passed to an
   /// __unknown_anytype parameter.
-  ExprResult checkUnknownAnyArg(SourceLocation callLoc,
-                                Expr *result, QualType &paramType);
+  ExprResult checkUnknownAnyArg(SourceLocation callLoc, Expr *result,
+                                QualType &paramType);
 
   // CheckMatrixCast - Check type constraints for matrix casts.
   // We allow casting between matrixes of the same dimensions i.e. when they
@@ -12001,8 +11629,7 @@ public:
                                           CheckedConversionKind CCK,
                                           bool Diagnose = true,
                                           bool DiagnoseCFAudited = false,
-                                          BinaryOperatorKind Opc = BO_PtrMemD
-                                          );
+                                          BinaryOperatorKind Opc = BO_PtrMemD);
 
   Expr *stripARCUnbridgedCast(Expr *e);
   void diagnoseARCUnbridgedCast(Expr *e);
@@ -12105,8 +11732,7 @@ public:
   DeclResult ActOnCXXConditionDeclaration(Scope *S, Declarator &D);
 
   ExprResult CheckConditionVariable(VarDecl *ConditionVar,
-                                    SourceLocation StmtLoc,
-                                    ConditionKind CK);
+                                    SourceLocation StmtLoc, ConditionKind CK);
   ExprResult CheckSwitchCondition(SourceLocation SwitchLoc, Expr *Cond);
 
   /// CheckBooleanCondition - Diagnose problems involving the use of
@@ -12157,7 +11783,7 @@ public:
   public:
     bool Suppress;
 
-    VerifyICEDiagnoser(bool Suppress = false) : Suppress(Suppress) { }
+    VerifyICEDiagnoser(bool Suppress = false) : Suppress(Suppress) {}
 
     virtual SemaDiagnosticBuilder
     diagnoseNotICEType(Sema &S, SourceLocation Loc, QualType T);
@@ -12194,8 +11820,8 @@ public:
   /// Returns false on success.
   /// Can optionally return whether the bit-field is of width 0
   ExprResult VerifyBitField(SourceLocation FieldLoc, IdentifierInfo *FieldName,
-                            QualType FieldTy, bool IsMsStruct,
-                            Expr *BitWidth, bool *ZeroWidth = nullptr);
+                            QualType FieldTy, bool IsMsStruct, Expr *BitWidth,
+                            bool *ZeroWidth = nullptr);
 
 private:
   unsigned ForceCUDAHostDeviceDepth = 0;
@@ -12433,8 +12059,7 @@ public:
   bool inferCUDATargetForImplicitSpecialMember(CXXRecordDecl *ClassDecl,
                                                CXXSpecialMember CSM,
                                                CXXMethodDecl *MemberDecl,
-                                               bool ConstRHS,
-                                               bool Diagnose);
+                                               bool ConstRHS, bool Diagnose);
 
   /// \return true if \p CD can be considered empty according to CUDA
   /// (E.2.3.1 in CUDA 7.5 Programming guide).
@@ -12514,13 +12139,11 @@ public:
   void CodeCompleteModuleImport(SourceLocation ImportLoc, ModuleIdPath Path);
   void CodeCompleteOrdinaryName(Scope *S,
                                 ParserCompletionContext CompletionContext);
-  void CodeCompleteDeclSpec(Scope *S, DeclSpec &DS,
-                            bool AllowNonIdentifiers,
+  void CodeCompleteDeclSpec(Scope *S, DeclSpec &DS, bool AllowNonIdentifiers,
                             bool AllowNestedNameSpecifiers);
 
   struct CodeCompleteExpressionData;
-  void CodeCompleteExpression(Scope *S,
-                              const CodeCompleteExpressionData &Data);
+  void CodeCompleteExpression(Scope *S, const CodeCompleteExpressionData &Data);
   void CodeCompleteExpression(Scope *S, QualType PreferredType,
                               bool IsParenthesized = false);
   void CodeCompleteMemberReferenceExpr(Scope *S, Expr *Base, Expr *OtherOpBase,
@@ -12582,8 +12205,7 @@ public:
   void CodeCompleteNamespaceAliasDecl(Scope *S);
   void CodeCompleteOperatorName(Scope *S);
   void CodeCompleteConstructorInitializer(
-                                Decl *Constructor,
-                                ArrayRef<CXXCtorInitializer *> Initializers);
+      Decl *Constructor, ArrayRef<CXXCtorInitializer *> Initializers);
 
   void CodeCompleteLambdaIntroducer(Scope *S, LambdaIntroducer &Intro,
                                     bool AfterAmpersand);
@@ -12610,20 +12232,16 @@ public:
                                        ArrayRef<IdentifierInfo *> SelIdents,
                                        bool AtArgumentExpression,
                                        ObjCInterfaceDecl *Super = nullptr);
-  void CodeCompleteObjCForCollection(Scope *S,
-                                     DeclGroupPtrTy IterationVar);
-  void CodeCompleteObjCSelector(Scope *S,
-                                ArrayRef<IdentifierInfo *> SelIdents);
-  void CodeCompleteObjCProtocolReferences(
-                                         ArrayRef<IdentifierLocPair> Protocols);
+  void CodeCompleteObjCForCollection(Scope *S, DeclGroupPtrTy IterationVar);
+  void CodeCompleteObjCSelector(Scope *S, ArrayRef<IdentifierInfo *> SelIdents);
+  void
+  CodeCompleteObjCProtocolReferences(ArrayRef<IdentifierLocPair> Protocols);
   void CodeCompleteObjCProtocolDecl(Scope *S);
   void CodeCompleteObjCInterfaceDecl(Scope *S);
-  void CodeCompleteObjCSuperclass(Scope *S,
-                                  IdentifierInfo *ClassName,
+  void CodeCompleteObjCSuperclass(Scope *S, IdentifierInfo *ClassName,
                                   SourceLocation ClassNameLoc);
   void CodeCompleteObjCImplementationDecl(Scope *S);
-  void CodeCompleteObjCInterfaceCategory(Scope *S,
-                                         IdentifierInfo *ClassName,
+  void CodeCompleteObjCInterfaceCategory(Scope *S, IdentifierInfo *ClassName,
                                          SourceLocation ClassNameLoc);
   void CodeCompleteObjCImplementationCategory(Scope *S,
                                               IdentifierInfo *ClassName,
@@ -12633,8 +12251,7 @@ public:
                                               IdentifierInfo *PropertyName);
   void CodeCompleteObjCMethodDecl(Scope *S, Optional<bool> IsInstanceMethod,
                                   ParsedType ReturnType);
-  void CodeCompleteObjCMethodDeclSelector(Scope *S,
-                                          bool IsInstanceMethod,
+  void CodeCompleteObjCMethodDeclSelector(Scope *S, bool IsInstanceMethod,
                                           bool AtParameterName,
                                           ParsedType ReturnType,
                                           ArrayRef<IdentifierInfo *> SelIdents);
@@ -12645,16 +12262,16 @@ public:
   void CodeCompleteInPreprocessorConditionalExclusion(Scope *S);
   void CodeCompletePreprocessorMacroName(bool IsDefinition);
   void CodeCompletePreprocessorExpression();
-  void CodeCompletePreprocessorMacroArgument(Scope *S,
-                                             IdentifierInfo *Macro,
+  void CodeCompletePreprocessorMacroArgument(Scope *S, IdentifierInfo *Macro,
                                              MacroInfo *MacroInfo,
                                              unsigned Argument);
   void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled);
   void CodeCompleteNaturalLanguage();
   void CodeCompleteAvailabilityPlatformName();
-  void GatherGlobalCodeCompletions(CodeCompletionAllocator &Allocator,
-                                   CodeCompletionTUInfo &CCTUInfo,
-                  SmallVectorImpl<CodeCompletionResult> &Results);
+  void
+  GatherGlobalCodeCompletions(CodeCompletionAllocator &Allocator,
+                              CodeCompletionTUInfo &CCTUInfo,
+                              SmallVectorImpl<CodeCompletionResult> &Results);
   //@}
 
   //===--------------------------------------------------------------------===//
@@ -12666,8 +12283,8 @@ public:
 
 private:
   void CheckArrayAccess(const Expr *BaseExpr, const Expr *IndexExpr,
-                        const ArraySubscriptExpr *ASE=nullptr,
-                        bool AllowOnePastEnd=true, bool IndexNegated=false);
+                        const ArraySubscriptExpr *ASE = nullptr,
+                        bool AllowOnePastEnd = true, bool IndexNegated = false);
   void CheckArrayAccess(const Expr *E);
   // Used to grab the relevant information from a FormatAttr and a
   // FunctionDeclaration.
@@ -12701,8 +12318,8 @@ private:
   bool CheckObjCString(Expr *Arg);
   ExprResult CheckOSLogFormatStringArg(Expr *Arg);
 
-  ExprResult CheckBuiltinFunctionCall(FunctionDecl *FDecl,
-                                      unsigned BuiltinID, CallExpr *TheCall);
+  ExprResult CheckBuiltinFunctionCall(FunctionDecl *FDecl, unsigned BuiltinID,
+                                      CallExpr *TheCall);
 
   bool CheckTSBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,
                                   CallExpr *TheCall);
@@ -12833,15 +12450,13 @@ public:
 
 private:
   bool CheckFormatArguments(const FormatAttr *Format,
-                            ArrayRef<const Expr *> Args,
-                            bool IsCXXMember,
-                            VariadicCallType CallType,
-                            SourceLocation Loc, SourceRange Range,
+                            ArrayRef<const Expr *> Args, bool IsCXXMember,
+                            VariadicCallType CallType, SourceLocation Loc,
+                            SourceRange Range,
                             llvm::SmallBitVector &CheckedVarArgs);
-  bool CheckFormatArguments(ArrayRef<const Expr *> Args,
-                            bool HasVAListArg, unsigned format_idx,
-                            unsigned firstDataArg, FormatStringType Type,
-                            VariadicCallType CallType,
+  bool CheckFormatArguments(ArrayRef<const Expr *> Args, bool HasVAListArg,
+                            unsigned format_idx, unsigned firstDataArg,
+                            FormatStringType Type, VariadicCallType CallType,
                             SourceLocation Loc, SourceRange range,
                             llvm::SmallBitVector &CheckedVarArgs);
 
@@ -12850,21 +12465,17 @@ private:
 
   void CheckMaxUnsignedZero(const CallExpr *Call, const FunctionDecl *FDecl);
 
-  void CheckMemaccessArguments(const CallExpr *Call,
-                               unsigned BId,
+  void CheckMemaccessArguments(const CallExpr *Call, unsigned BId,
                                IdentifierInfo *FnName);
 
-  void CheckStrlcpycatArguments(const CallExpr *Call,
-                                IdentifierInfo *FnName);
+  void CheckStrlcpycatArguments(const CallExpr *Call, IdentifierInfo *FnName);
 
-  void CheckStrncatArguments(const CallExpr *Call,
-                             IdentifierInfo *FnName);
+  void CheckStrncatArguments(const CallExpr *Call, IdentifierInfo *FnName);
 
   void CheckFreeArguments(const CallExpr *E);
 
   void CheckReturnValExpr(Expr *RetValExp, QualType lhsType,
-                          SourceLocation ReturnLoc,
-                          bool isObjCMethod = false,
+                          SourceLocation ReturnLoc, bool isObjCMethod = false,
                           const AttrVec *Attrs = nullptr,
                           const FunctionDecl *FD = nullptr);
 
@@ -12904,6 +12515,7 @@ private:
   void AnalyzeDeleteExprMismatch(const CXXDeleteExpr *DE);
   void AnalyzeDeleteExprMismatch(FieldDecl *Field, SourceLocation DeleteLoc,
                                  bool DeleteWasArrayForm);
+
 public:
   /// Register a magic integral constant to be used as a type tag.
   void RegisterTypeTagForDatatype(const IdentifierInfo *ArgumentKind,
@@ -12913,10 +12525,9 @@ public:
   struct TypeTagData {
     TypeTagData() {}
 
-    TypeTagData(QualType Type, bool LayoutCompatible, bool MustBeNull) :
-        Type(Type), LayoutCompatible(LayoutCompatible),
-        MustBeNull(MustBeNull)
-    {}
+    TypeTagData(QualType Type, bool LayoutCompatible, bool MustBeNull)
+        : Type(Type), LayoutCompatible(LayoutCompatible),
+          MustBeNull(MustBeNull) {}
 
     QualType Type;
 
@@ -13035,8 +12646,8 @@ public:
 
   // Emitting members of dllexported classes is delayed until the class
   // (including field initializers) is fully parsed.
-  SmallVector<CXXRecordDecl*, 4> DelayedDllExportClasses;
-  SmallVector<CXXMethodDecl*, 4> DelayedDllExportMemberFunctions;
+  SmallVector<CXXRecordDecl *, 4> DelayedDllExportClasses;
+  SmallVector<CXXMethodDecl *, 4> DelayedDllExportMemberFunctions;
 
 private:
   int ParsingClassDepth = 0;
@@ -13160,6 +12771,11 @@ public:
   void deepTypeCheckForSYCLDevice(SourceLocation UsedAt,
                                   llvm::DenseSet<QualType> Visited,
                                   ValueDecl *DeclToCheck);
+
+  // Modified By Zeng-WCh
+  // StmtResult ActOnPragmaLoopBound(uint64_t lower, uint64_t upper,
+  //                                 SourceLocation Loc);
+  // End Modification
 };
 
 /// RAII object that enters a new expression evaluation context.
diff --color -uprN clang-14.0.6.src/lib/AST/Stmt.cpp clang-14.0.6.src.patched/lib/AST/Stmt.cpp
--- clang-14.0.6.src/lib/AST/Stmt.cpp	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/lib/AST/Stmt.cpp	2024-11-12 13:24:23.346651843 +0800
@@ -51,7 +51,7 @@ static struct StmtClassNameTable {
   const char *Name;
   unsigned Counter;
   unsigned Size;
-} StmtClassInfo[Stmt::lastStmtConstant+1];
+} StmtClassInfo[Stmt::lastStmtConstant + 1];
 
 static StmtClassNameTable &getStmtInfoTableEntry(Stmt::StmtClass E) {
   static bool Initialized = false;
@@ -61,28 +61,28 @@ static StmtClassNameTable &getStmtInfoTa
   // Initialize the table on the first use.
   Initialized = true;
 #define ABSTRACT_STMT(STMT)
-#define STMT(CLASS, PARENT) \
-  StmtClassInfo[(unsigned)Stmt::CLASS##Class].Name = #CLASS;    \
+#define STMT(CLASS, PARENT)                                                    \
+  StmtClassInfo[(unsigned)Stmt::CLASS##Class].Name = #CLASS;                   \
   StmtClassInfo[(unsigned)Stmt::CLASS##Class].Size = sizeof(CLASS);
 #include "clang/AST/StmtNodes.inc"
 
   return StmtClassInfo[E];
 }
 
-void *Stmt::operator new(size_t bytes, const ASTContext& C,
+void *Stmt::operator new(size_t bytes, const ASTContext &C,
                          unsigned alignment) {
   return ::operator new(bytes, C, alignment);
 }
 
 const char *Stmt::getStmtClassName() const {
-  return getStmtInfoTableEntry((StmtClass) StmtBits.sClass).Name;
+  return getStmtInfoTableEntry((StmtClass)StmtBits.sClass).Name;
 }
 
 // Check that no statement / expression class is polymorphic. LLVM style RTTI
 // should be used instead. If absolutely needed an exception can still be added
 // here by defining the appropriate macro (but please don't do this).
-#define STMT(CLASS, PARENT) \
-  static_assert(!std::is_polymorphic<CLASS>::value, \
+#define STMT(CLASS, PARENT)                                                    \
+  static_assert(!std::is_polymorphic<CLASS>::value,                            \
                 #CLASS " should not be polymorphic!");
 #include "clang/AST/StmtNodes.inc"
 
@@ -102,33 +102,33 @@ void Stmt::PrintStats() {
 
   unsigned sum = 0;
   llvm::errs() << "\n*** Stmt/Expr Stats:\n";
-  for (int i = 0; i != Stmt::lastStmtConstant+1; i++) {
-    if (StmtClassInfo[i].Name == nullptr) continue;
+  for (int i = 0; i != Stmt::lastStmtConstant + 1; i++) {
+    if (StmtClassInfo[i].Name == nullptr)
+      continue;
     sum += StmtClassInfo[i].Counter;
   }
   llvm::errs() << "  " << sum << " stmts/exprs total.\n";
   sum = 0;
-  for (int i = 0; i != Stmt::lastStmtConstant+1; i++) {
-    if (StmtClassInfo[i].Name == nullptr) continue;
-    if (StmtClassInfo[i].Counter == 0) continue;
+  for (int i = 0; i != Stmt::lastStmtConstant + 1; i++) {
+    if (StmtClassInfo[i].Name == nullptr)
+      continue;
+    if (StmtClassInfo[i].Counter == 0)
+      continue;
     llvm::errs() << "    " << StmtClassInfo[i].Counter << " "
                  << StmtClassInfo[i].Name << ", " << StmtClassInfo[i].Size
-                 << " each (" << StmtClassInfo[i].Counter*StmtClassInfo[i].Size
+                 << " each ("
+                 << StmtClassInfo[i].Counter * StmtClassInfo[i].Size
                  << " bytes)\n";
-    sum += StmtClassInfo[i].Counter*StmtClassInfo[i].Size;
+    sum += StmtClassInfo[i].Counter * StmtClassInfo[i].Size;
   }
 
   llvm::errs() << "Total bytes = " << sum << "\n";
 }
 
-void Stmt::addStmtClass(StmtClass s) {
-  ++getStmtInfoTableEntry(s).Counter;
-}
+void Stmt::addStmtClass(StmtClass s) { ++getStmtInfoTableEntry(s).Counter; }
 
 bool Stmt::StatisticsEnabled = false;
-void Stmt::EnableStatistics() {
-  StatisticsEnabled = true;
-}
+void Stmt::EnableStatistics() { StatisticsEnabled = true; }
 
 static std::pair<Stmt::Likelihood, const Attr *>
 getLikelihood(ArrayRef<const Attr *> Attrs) {
@@ -230,39 +230,35 @@ const Stmt *Stmt::stripLabelLikeStatemen
 
 namespace {
 
-  struct good {};
-  struct bad {};
+struct good {};
+struct bad {};
 
-  // These silly little functions have to be static inline to suppress
-  // unused warnings, and they have to be defined to suppress other
-  // warnings.
-  static good is_good(good) { return good(); }
-
-  typedef Stmt::child_range children_t();
-  template <class T> good implements_children(children_t T::*) {
-    return good();
-  }
-  LLVM_ATTRIBUTE_UNUSED
-  static bad implements_children(children_t Stmt::*) {
-    return bad();
-  }
+// These silly little functions have to be static inline to suppress
+// unused warnings, and they have to be defined to suppress other
+// warnings.
+static good is_good(good) { return good(); }
 
-  typedef SourceLocation getBeginLoc_t() const;
-  template <class T> good implements_getBeginLoc(getBeginLoc_t T::*) {
-    return good();
-  }
-  LLVM_ATTRIBUTE_UNUSED
-  static bad implements_getBeginLoc(getBeginLoc_t Stmt::*) { return bad(); }
+typedef Stmt::child_range children_t();
+template <class T> good implements_children(children_t T::*) { return good(); }
+LLVM_ATTRIBUTE_UNUSED
+static bad implements_children(children_t Stmt::*) { return bad(); }
 
-  typedef SourceLocation getLocEnd_t() const;
-  template <class T> good implements_getEndLoc(getLocEnd_t T::*) {
-    return good();
-  }
-  LLVM_ATTRIBUTE_UNUSED
-  static bad implements_getEndLoc(getLocEnd_t Stmt::*) { return bad(); }
+typedef SourceLocation getBeginLoc_t() const;
+template <class T> good implements_getBeginLoc(getBeginLoc_t T::*) {
+  return good();
+}
+LLVM_ATTRIBUTE_UNUSED
+static bad implements_getBeginLoc(getBeginLoc_t Stmt::*) { return bad(); }
+
+typedef SourceLocation getLocEnd_t() const;
+template <class T> good implements_getEndLoc(getLocEnd_t T::*) {
+  return good();
+}
+LLVM_ATTRIBUTE_UNUSED
+static bad implements_getEndLoc(getLocEnd_t Stmt::*) { return bad(); }
 
-#define ASSERT_IMPLEMENTS_children(type) \
-  (void) is_good(implements_children(&type::children))
+#define ASSERT_IMPLEMENTS_children(type)                                       \
+  (void)is_good(implements_children(&type::children))
 #define ASSERT_IMPLEMENTS_getBeginLoc(type)                                    \
   (void)is_good(implements_getBeginLoc(&type::getBeginLoc))
 #define ASSERT_IMPLEMENTS_getEndLoc(type)                                      \
@@ -284,11 +280,12 @@ static inline void check_implementations
 
 Stmt::child_range Stmt::children() {
   switch (getStmtClass()) {
-  case Stmt::NoStmtClass: llvm_unreachable("statement without class");
+  case Stmt::NoStmtClass:
+    llvm_unreachable("statement without class");
 #define ABSTRACT_STMT(type)
-#define STMT(type, base) \
-  case Stmt::type##Class: \
-    return static_cast<type*>(this)->children();
+#define STMT(type, base)                                                       \
+  case Stmt::type##Class:                                                      \
+    return static_cast<type *>(this)->children();
 #include "clang/AST/StmtNodes.inc"
   }
   llvm_unreachable("unknown statement kind!");
@@ -300,33 +297,33 @@ Stmt::child_range Stmt::children() {
 // See also Expr.cpp:getExprLoc().
 namespace {
 
-  /// This implementation is used when a class provides a custom
-  /// implementation of getSourceRange.
-  template <class S, class T>
-  SourceRange getSourceRangeImpl(const Stmt *stmt,
-                                 SourceRange (T::*v)() const) {
-    return static_cast<const S*>(stmt)->getSourceRange();
-  }
-
-  /// This implementation is used when a class doesn't provide a custom
-  /// implementation of getSourceRange.  Overload resolution should pick it over
-  /// the implementation above because it's more specialized according to
-  /// function template partial ordering.
-  template <class S>
-  SourceRange getSourceRangeImpl(const Stmt *stmt,
-                                 SourceRange (Stmt::*v)() const) {
-    return SourceRange(static_cast<const S *>(stmt)->getBeginLoc(),
-                       static_cast<const S *>(stmt)->getEndLoc());
-  }
+/// This implementation is used when a class provides a custom
+/// implementation of getSourceRange.
+template <class S, class T>
+SourceRange getSourceRangeImpl(const Stmt *stmt, SourceRange (T::*v)() const) {
+  return static_cast<const S *>(stmt)->getSourceRange();
+}
+
+/// This implementation is used when a class doesn't provide a custom
+/// implementation of getSourceRange.  Overload resolution should pick it over
+/// the implementation above because it's more specialized according to
+/// function template partial ordering.
+template <class S>
+SourceRange getSourceRangeImpl(const Stmt *stmt,
+                               SourceRange (Stmt::*v)() const) {
+  return SourceRange(static_cast<const S *>(stmt)->getBeginLoc(),
+                     static_cast<const S *>(stmt)->getEndLoc());
+}
 
 } // namespace
 
 SourceRange Stmt::getSourceRange() const {
   switch (getStmtClass()) {
-  case Stmt::NoStmtClass: llvm_unreachable("statement without class");
+  case Stmt::NoStmtClass:
+    llvm_unreachable("statement without class");
 #define ABSTRACT_STMT(type)
-#define STMT(type, base) \
-  case Stmt::type##Class: \
+#define STMT(type, base)                                                       \
+  case Stmt::type##Class:                                                      \
     return getSourceRangeImpl<type>(this, &type::getSourceRange);
 #include "clang/AST/StmtNodes.inc"
   }
@@ -335,7 +332,8 @@ SourceRange Stmt::getSourceRange() const
 
 SourceLocation Stmt::getBeginLoc() const {
   switch (getStmtClass()) {
-  case Stmt::NoStmtClass: llvm_unreachable("statement without class");
+  case Stmt::NoStmtClass:
+    llvm_unreachable("statement without class");
 #define ABSTRACT_STMT(type)
 #define STMT(type, base)                                                       \
   case Stmt::type##Class:                                                      \
@@ -347,7 +345,8 @@ SourceLocation Stmt::getBeginLoc() const
 
 SourceLocation Stmt::getEndLoc() const {
   switch (getStmtClass()) {
-  case Stmt::NoStmtClass: llvm_unreachable("statement without class");
+  case Stmt::NoStmtClass:
+    llvm_unreachable("statement without class");
 #define ABSTRACT_STMT(type)
 #define STMT(type, base)                                                       \
   case Stmt::type##Class:                                                      \
@@ -414,7 +413,7 @@ const char *LabelStmt::getName() const {
 }
 
 AttributedStmt *AttributedStmt::Create(const ASTContext &C, SourceLocation Loc,
-                                       ArrayRef<const Attr*> Attrs,
+                                       ArrayRef<const Attr *> Attrs,
                                        Stmt *SubStmt) {
   assert(!Attrs.empty() && "Attrs should not be empty");
   void *Mem = C.Allocate(totalSizeToAlloc<const Attr *>(Attrs.size()),
@@ -497,9 +496,7 @@ StringRef GCCAsmStmt::getClobber(unsigne
   return getClobberStringLiteral(i)->getString();
 }
 
-Expr *GCCAsmStmt::getOutputExpr(unsigned i) {
-  return cast<Expr>(Exprs[i]);
-}
+Expr *GCCAsmStmt::getOutputExpr(unsigned i) { return cast<Expr>(Exprs[i]); }
 
 /// getOutputConstraint - Return the constraint string for the specified
 /// output operand.  All output constraints are known to be non-empty (either
@@ -530,15 +527,10 @@ StringRef GCCAsmStmt::getInputConstraint
   return getInputConstraintLiteral(i)->getString();
 }
 
-void GCCAsmStmt::setOutputsAndInputsAndClobbers(const ASTContext &C,
-                                                IdentifierInfo **Names,
-                                                StringLiteral **Constraints,
-                                                Stmt **Exprs,
-                                                unsigned NumOutputs,
-                                                unsigned NumInputs,
-                                                unsigned NumLabels,
-                                                StringLiteral **Clobbers,
-                                                unsigned NumClobbers) {
+void GCCAsmStmt::setOutputsAndInputsAndClobbers(
+    const ASTContext &C, IdentifierInfo **Names, StringLiteral **Constraints,
+    Stmt **Exprs, unsigned NumOutputs, unsigned NumInputs, unsigned NumLabels,
+    StringLiteral **Clobbers, unsigned NumClobbers) {
   this->NumOutputs = NumOutputs;
   this->NumInputs = NumInputs;
   this->NumClobbers = NumClobbers;
@@ -547,20 +539,20 @@ void GCCAsmStmt::setOutputsAndInputsAndC
   unsigned NumExprs = NumOutputs + NumInputs + NumLabels;
 
   C.Deallocate(this->Names);
-  this->Names = new (C) IdentifierInfo*[NumExprs];
+  this->Names = new (C) IdentifierInfo *[NumExprs];
   std::copy(Names, Names + NumExprs, this->Names);
 
   C.Deallocate(this->Exprs);
-  this->Exprs = new (C) Stmt*[NumExprs];
+  this->Exprs = new (C) Stmt *[NumExprs];
   std::copy(Exprs, Exprs + NumExprs, this->Exprs);
 
   unsigned NumConstraints = NumOutputs + NumInputs;
   C.Deallocate(this->Constraints);
-  this->Constraints = new (C) StringLiteral*[NumConstraints];
+  this->Constraints = new (C) StringLiteral *[NumConstraints];
   std::copy(Constraints, Constraints + NumConstraints, this->Constraints);
 
   C.Deallocate(this->Clobbers);
-  this->Clobbers = new (C) StringLiteral*[NumClobbers];
+  this->Clobbers = new (C) StringLiteral *[NumClobbers];
   std::copy(Clobbers, Clobbers + NumClobbers, this->Clobbers);
 }
 
@@ -590,8 +582,9 @@ int GCCAsmStmt::getNamedOperand(StringRe
 /// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing
 /// it into pieces.  If the asm string is erroneous, emit errors and return
 /// true, otherwise return false.
-unsigned GCCAsmStmt::AnalyzeAsmString(SmallVectorImpl<AsmStringPiece>&Pieces,
-                                const ASTContext &C, unsigned &DiagOffs) const {
+unsigned GCCAsmStmt::AnalyzeAsmString(SmallVectorImpl<AsmStringPiece> &Pieces,
+                                      const ASTContext &C,
+                                      unsigned &DiagOffs) const {
   StringRef Str = getAsmString()->getString();
   const char *StrStart = Str.begin();
   const char *StrEnd = Str.end();
@@ -634,10 +627,18 @@ unsigned GCCAsmStmt::AnalyzeAsmString(Sm
 
     char CurChar = *CurPtr++;
     switch (CurChar) {
-    case '$': CurStringPiece += "$$"; continue;
-    case '{': CurStringPiece += (HasVariants ? "$(" : "{"); continue;
-    case '|': CurStringPiece += (HasVariants ? "$|" : "|"); continue;
-    case '}': CurStringPiece += (HasVariants ? "$)" : "}"); continue;
+    case '$':
+      CurStringPiece += "$$";
+      continue;
+    case '{':
+      CurStringPiece += (HasVariants ? "$(" : "{");
+      continue;
+    case '|':
+      CurStringPiece += (HasVariants ? "$|" : "|");
+      continue;
+    case '}':
+      CurStringPiece += (HasVariants ? "$)" : "}");
+      continue;
     case '%':
       break;
     default:
@@ -650,7 +651,7 @@ unsigned GCCAsmStmt::AnalyzeAsmString(Sm
     // Escaped "%" character in asm string.
     if (CurPtr == StrEnd) {
       // % at end of string is invalid (no escape).
-      DiagOffs = CurPtr-StrStart-1;
+      DiagOffs = CurPtr - StrStart - 1;
       return diag::err_asm_invalid_escape;
     }
     // Handle escaped char and continue looping over the asm string.
@@ -683,12 +684,12 @@ unsigned GCCAsmStmt::AnalyzeAsmString(Sm
     // Handle operands that have asmSymbolicName (e.g., %x[foo]) and those that
     // don't (e.g., %x4). 'x' following the '%' is the constraint modifier.
 
-    const char *Begin = CurPtr - 1; // Points to the character following '%'.
+    const char *Begin = CurPtr - 1;  // Points to the character following '%'.
     const char *Percent = Begin - 1; // Points to '%'.
 
     if (isLetter(EscapedChar)) {
       if (CurPtr == StrEnd) { // Premature end.
-        DiagOffs = CurPtr-StrStart-1;
+        DiagOffs = CurPtr - StrStart - 1;
         return diag::err_asm_invalid_escape;
       }
       EscapedChar = *CurPtr++;
@@ -704,12 +705,12 @@ unsigned GCCAsmStmt::AnalyzeAsmString(Sm
 
       --CurPtr;
       while (CurPtr != StrEnd && isDigit(*CurPtr))
-        N = N*10 + ((*CurPtr++)-'0');
+        N = N * 10 + ((*CurPtr++) - '0');
 
       unsigned NumOperands = getNumOutputs() + getNumPlusOperands() +
                              getNumInputs() + getNumLabels();
       if (N >= NumOperands) {
-        DiagOffs = CurPtr-StrStart-1;
+        DiagOffs = CurPtr - StrStart - 1;
         return diag::err_asm_invalid_operand_number;
       }
 
@@ -731,10 +732,10 @@ unsigned GCCAsmStmt::AnalyzeAsmString(Sm
 
     // Handle operands that have asmSymbolicName (e.g., %x[foo]).
     if (EscapedChar == '[') {
-      DiagOffs = CurPtr-StrStart-1;
+      DiagOffs = CurPtr - StrStart - 1;
 
       // Find the ']'.
-      const char *NameEnd = (const char*)memchr(CurPtr, ']', StrEnd-CurPtr);
+      const char *NameEnd = (const char *)memchr(CurPtr, ']', StrEnd - CurPtr);
       if (NameEnd == nullptr)
         return diag::err_asm_unterminated_symbolic_operand_name;
       if (NameEnd == CurPtr)
@@ -745,7 +746,7 @@ unsigned GCCAsmStmt::AnalyzeAsmString(Sm
       int N = getNamedOperand(SymbolicName);
       if (N == -1) {
         // Verify that an operand with that name exists.
-        DiagOffs = CurPtr-StrStart;
+        DiagOffs = CurPtr - StrStart;
         return diag::err_asm_unknown_symbolic_operand_name;
       }
 
@@ -763,11 +764,11 @@ unsigned GCCAsmStmt::AnalyzeAsmString(Sm
 
       Pieces.emplace_back(N, std::move(Str), BeginLoc, EndLoc);
 
-      CurPtr = NameEnd+1;
+      CurPtr = NameEnd + 1;
       continue;
     }
 
-    DiagOffs = CurPtr-StrStart-1;
+    DiagOffs = CurPtr - StrStart - 1;
     return diag::err_asm_invalid_escape;
   }
 }
@@ -819,17 +820,13 @@ std::string MSAsmStmt::generateAsmString
   return MSAsmString;
 }
 
-Expr *MSAsmStmt::getOutputExpr(unsigned i) {
-  return cast<Expr>(Exprs[i]);
-}
+Expr *MSAsmStmt::getOutputExpr(unsigned i) { return cast<Expr>(Exprs[i]); }
 
 Expr *MSAsmStmt::getInputExpr(unsigned i) {
   return cast<Expr>(Exprs[i + NumOutputs]);
 }
 
-void MSAsmStmt::setInputExpr(unsigned i, Expr *E) {
-  Exprs[i + NumOutputs] = E;
-}
+void MSAsmStmt::setInputExpr(unsigned i, Expr *E) { Exprs[i + NumOutputs] = E; }
 
 //===----------------------------------------------------------------------===//
 // Constructors
@@ -844,33 +841,32 @@ GCCAsmStmt::GCCAsmStmt(const ASTContext
                        SourceLocation rparenloc)
     : AsmStmt(GCCAsmStmtClass, asmloc, issimple, isvolatile, numoutputs,
               numinputs, numclobbers),
-              RParenLoc(rparenloc), AsmStr(asmstr), NumLabels(numlabels) {
+      RParenLoc(rparenloc), AsmStr(asmstr), NumLabels(numlabels) {
   unsigned NumExprs = NumOutputs + NumInputs + NumLabels;
 
-  Names = new (C) IdentifierInfo*[NumExprs];
+  Names = new (C) IdentifierInfo *[NumExprs];
   std::copy(names, names + NumExprs, Names);
 
-  Exprs = new (C) Stmt*[NumExprs];
+  Exprs = new (C) Stmt *[NumExprs];
   std::copy(exprs, exprs + NumExprs, Exprs);
 
   unsigned NumConstraints = NumOutputs + NumInputs;
-  Constraints = new (C) StringLiteral*[NumConstraints];
+  Constraints = new (C) StringLiteral *[NumConstraints];
   std::copy(constraints, constraints + NumConstraints, Constraints);
 
-  Clobbers = new (C) StringLiteral*[NumClobbers];
+  Clobbers = new (C) StringLiteral *[NumClobbers];
   std::copy(clobbers, clobbers + NumClobbers, Clobbers);
 }
 
 MSAsmStmt::MSAsmStmt(const ASTContext &C, SourceLocation asmloc,
                      SourceLocation lbraceloc, bool issimple, bool isvolatile,
                      ArrayRef<Token> asmtoks, unsigned numoutputs,
-                     unsigned numinputs,
-                     ArrayRef<StringRef> constraints, ArrayRef<Expr*> exprs,
-                     StringRef asmstr, ArrayRef<StringRef> clobbers,
-                     SourceLocation endloc)
+                     unsigned numinputs, ArrayRef<StringRef> constraints,
+                     ArrayRef<Expr *> exprs, StringRef asmstr,
+                     ArrayRef<StringRef> clobbers, SourceLocation endloc)
     : AsmStmt(MSAsmStmtClass, asmloc, issimple, isvolatile, numoutputs,
-              numinputs, clobbers.size()), LBraceLoc(lbraceloc),
-              EndLoc(endloc), NumAsmToks(asmtoks.size()) {
+              numinputs, clobbers.size()),
+      LBraceLoc(lbraceloc), EndLoc(endloc), NumAsmToks(asmtoks.size()) {
   initialize(C, asmstr, asmtoks, constraints, exprs, clobbers);
 }
 
@@ -881,7 +877,7 @@ static StringRef copyIntoContext(const A
 void MSAsmStmt::initialize(const ASTContext &C, StringRef asmstr,
                            ArrayRef<Token> asmtoks,
                            ArrayRef<StringRef> constraints,
-                           ArrayRef<Expr*> exprs,
+                           ArrayRef<Expr *> exprs,
                            ArrayRef<StringRef> clobbers) {
   assert(NumAsmToks == asmtoks.size());
   assert(NumClobbers == clobbers.size());
@@ -891,24 +887,22 @@ void MSAsmStmt::initialize(const ASTCont
 
   AsmStr = copyIntoContext(C, asmstr);
 
-  Exprs = new (C) Stmt*[exprs.size()];
+  Exprs = new (C) Stmt *[exprs.size()];
   std::copy(exprs.begin(), exprs.end(), Exprs);
 
   AsmToks = new (C) Token[asmtoks.size()];
   std::copy(asmtoks.begin(), asmtoks.end(), AsmToks);
 
   Constraints = new (C) StringRef[exprs.size()];
-  std::transform(constraints.begin(), constraints.end(), Constraints,
-                 [&](StringRef Constraint) {
-                   return copyIntoContext(C, Constraint);
-                 });
+  std::transform(
+      constraints.begin(), constraints.end(), Constraints,
+      [&](StringRef Constraint) { return copyIntoContext(C, Constraint); });
 
   Clobbers = new (C) StringRef[NumClobbers];
   // FIXME: Avoid the allocation/copy if at all possible.
-  std::transform(clobbers.begin(), clobbers.end(), Clobbers,
-                 [&](StringRef Clobber) {
-                   return copyIntoContext(C, Clobber);
-                 });
+  std::transform(
+      clobbers.begin(), clobbers.end(), Clobbers,
+      [&](StringRef Clobber) { return copyIntoContext(C, Clobber); });
 }
 
 IfStmt::IfStmt(const ASTContext &Ctx, SourceLocation IL, IfStatementKind Kind,
@@ -1011,8 +1005,7 @@ IfStmt::getNondiscardedCase(const ASTCon
 ForStmt::ForStmt(const ASTContext &C, Stmt *Init, Expr *Cond, VarDecl *condVar,
                  Expr *Inc, Stmt *Body, SourceLocation FL, SourceLocation LP,
                  SourceLocation RP)
-  : Stmt(ForStmtClass), LParenLoc(LP), RParenLoc(RP)
-{
+    : Stmt(ForStmtClass), LParenLoc(LP), RParenLoc(RP), Bound(nullptr) {
   SubExprs[INIT] = Init;
   setConditionVariable(C, condVar);
   SubExprs[COND] = Cond;
@@ -1036,8 +1029,8 @@ void ForStmt::setConditionVariable(const
   }
 
   SourceRange VarRange = V->getSourceRange();
-  SubExprs[CONDVAR] = new (C) DeclStmt(DeclGroupRef(V), VarRange.getBegin(),
-                                       VarRange.getEnd());
+  SubExprs[CONDVAR] =
+      new (C) DeclStmt(DeclGroupRef(V), VarRange.getBegin(), VarRange.getEnd());
 }
 
 SwitchStmt::SwitchStmt(const ASTContext &Ctx, Stmt *Init, VarDecl *Var,
@@ -1111,7 +1104,7 @@ void SwitchStmt::setConditionVariable(co
 WhileStmt::WhileStmt(const ASTContext &Ctx, VarDecl *Var, Expr *Cond,
                      Stmt *Body, SourceLocation WL, SourceLocation LParenLoc,
                      SourceLocation RParenLoc)
-    : Stmt(WhileStmtClass) {
+    : Stmt(WhileStmtClass), Bound(nullptr) {
   bool HasVar = Var != nullptr;
   WhileStmtBits.HasVar = HasVar;
 
@@ -1126,7 +1119,7 @@ WhileStmt::WhileStmt(const ASTContext &C
 }
 
 WhileStmt::WhileStmt(EmptyShell Empty, bool HasVar)
-    : Stmt(WhileStmtClass, Empty) {
+    : Stmt(WhileStmtClass, Empty), Bound(nullptr) {
   WhileStmtBits.HasVar = HasVar;
 }
 
@@ -1230,41 +1223,41 @@ CaseStmt *CaseStmt::CreateEmpty(const AS
 SEHTryStmt::SEHTryStmt(bool IsCXXTry, SourceLocation TryLoc, Stmt *TryBlock,
                        Stmt *Handler)
     : Stmt(SEHTryStmtClass), IsCXXTry(IsCXXTry), TryLoc(TryLoc) {
-  Children[TRY]     = TryBlock;
+  Children[TRY] = TryBlock;
   Children[HANDLER] = Handler;
 }
 
-SEHTryStmt* SEHTryStmt::Create(const ASTContext &C, bool IsCXXTry,
+SEHTryStmt *SEHTryStmt::Create(const ASTContext &C, bool IsCXXTry,
                                SourceLocation TryLoc, Stmt *TryBlock,
                                Stmt *Handler) {
-  return new(C) SEHTryStmt(IsCXXTry,TryLoc,TryBlock,Handler);
+  return new (C) SEHTryStmt(IsCXXTry, TryLoc, TryBlock, Handler);
 }
 
-SEHExceptStmt* SEHTryStmt::getExceptHandler() const {
+SEHExceptStmt *SEHTryStmt::getExceptHandler() const {
   return dyn_cast<SEHExceptStmt>(getHandler());
 }
 
-SEHFinallyStmt* SEHTryStmt::getFinallyHandler() const {
+SEHFinallyStmt *SEHTryStmt::getFinallyHandler() const {
   return dyn_cast<SEHFinallyStmt>(getHandler());
 }
 
 SEHExceptStmt::SEHExceptStmt(SourceLocation Loc, Expr *FilterExpr, Stmt *Block)
     : Stmt(SEHExceptStmtClass), Loc(Loc) {
   Children[FILTER_EXPR] = FilterExpr;
-  Children[BLOCK]       = Block;
+  Children[BLOCK] = Block;
 }
 
-SEHExceptStmt* SEHExceptStmt::Create(const ASTContext &C, SourceLocation Loc,
+SEHExceptStmt *SEHExceptStmt::Create(const ASTContext &C, SourceLocation Loc,
                                      Expr *FilterExpr, Stmt *Block) {
-  return new(C) SEHExceptStmt(Loc,FilterExpr,Block);
+  return new (C) SEHExceptStmt(Loc, FilterExpr, Block);
 }
 
 SEHFinallyStmt::SEHFinallyStmt(SourceLocation Loc, Stmt *Block)
     : Stmt(SEHFinallyStmtClass), Loc(Loc), Block(Block) {}
 
-SEHFinallyStmt* SEHFinallyStmt::Create(const ASTContext &C, SourceLocation Loc,
+SEHFinallyStmt *SEHFinallyStmt::Create(const ASTContext &C, SourceLocation Loc,
                                        Stmt *Block) {
-  return new(C)SEHFinallyStmt(Loc,Block);
+  return new (C) SEHFinallyStmt(Loc, Block);
 }
 
 CapturedStmt::Capture::Capture(SourceLocation Loc, VariableCaptureKind Kind,
@@ -1305,18 +1298,17 @@ CapturedStmt::Capture *CapturedStmt::get
   unsigned FirstCaptureOffset = llvm::alignTo(Size, alignof(Capture));
 
   return reinterpret_cast<Capture *>(
-      reinterpret_cast<char *>(const_cast<CapturedStmt *>(this))
-      + FirstCaptureOffset);
+      reinterpret_cast<char *>(const_cast<CapturedStmt *>(this)) +
+      FirstCaptureOffset);
 }
 
 CapturedStmt::CapturedStmt(Stmt *S, CapturedRegionKind Kind,
                            ArrayRef<Capture> Captures,
-                           ArrayRef<Expr *> CaptureInits,
-                           CapturedDecl *CD,
+                           ArrayRef<Expr *> CaptureInits, CapturedDecl *CD,
                            RecordDecl *RD)
-  : Stmt(CapturedStmtClass), NumCaptures(Captures.size()),
-    CapDeclAndKind(CD, Kind), TheRecordDecl(RD) {
-  assert( S && "null captured statement");
+    : Stmt(CapturedStmtClass), NumCaptures(Captures.size()),
+      CapDeclAndKind(CD, Kind), TheRecordDecl(RD) {
+  assert(S && "null captured statement");
   assert(CD && "null captured declaration for captured statement");
   assert(RD && "null record declaration for captured statement");
 
@@ -1334,8 +1326,8 @@ CapturedStmt::CapturedStmt(Stmt *S, Capt
 }
 
 CapturedStmt::CapturedStmt(EmptyShell Empty, unsigned NumCaptures)
-  : Stmt(CapturedStmtClass, Empty), NumCaptures(NumCaptures),
-    CapDeclAndKind(nullptr, CR_Default) {
+    : Stmt(CapturedStmtClass, Empty), NumCaptures(NumCaptures),
+      CapDeclAndKind(nullptr, CR_Default) {
   getStoredStmts()[NumCaptures] = nullptr;
 }
 
@@ -1343,8 +1335,7 @@ CapturedStmt *CapturedStmt::Create(const
                                    CapturedRegionKind Kind,
                                    ArrayRef<Capture> Captures,
                                    ArrayRef<Expr *> CaptureInits,
-                                   CapturedDecl *CD,
-                                   RecordDecl *RD) {
+                                   CapturedDecl *CD, RecordDecl *RD) {
   // The layout is
   //
   // -----------------------------------------------------------
diff --color -uprN clang-14.0.6.src/lib/CodeGen/CGStmt.cpp clang-14.0.6.src.patched/lib/CodeGen/CGStmt.cpp
--- clang-14.0.6.src/lib/CodeGen/CGStmt.cpp	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/lib/CodeGen/CGStmt.cpp	2024-11-12 13:29:22.971029954 +0800
@@ -24,6 +24,7 @@
 #include "clang/Basic/PrettyStackTrace.h"
 #include "clang/Basic/SourceManager.h"
 #include "clang/Basic/TargetInfo.h"
+#include "clang/Lex/Preprocessor.h"
 #include "llvm/ADT/SmallSet.h"
 #include "llvm/ADT/StringExtras.h"
 #include "llvm/IR/Assumptions.h"
@@ -31,8 +32,13 @@
 #include "llvm/IR/InlineAsm.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/MDBuilder.h"
+#include "llvm/IR/Metadata.h"
 #include "llvm/Support/SaveAndRestore.h"
 
+// Modified By Zeng-WCh
+#include <sstream>
+// End Modification
+
 using namespace clang;
 using namespace CodeGen;
 
@@ -110,51 +116,65 @@ void CodeGenFunction::EmitStmt(const Stm
 
 #define STMT(Type, Base)
 #define ABSTRACT_STMT(Op)
-#define EXPR(Type, Base) \
-  case Stmt::Type##Class:
+#define EXPR(Type, Base) case Stmt::Type##Class:
 #include "clang/AST/StmtNodes.inc"
-  {
-    // Remember the block we came in on.
-    llvm::BasicBlock *incoming = Builder.GetInsertBlock();
-    assert(incoming && "expression emission must have an insertion point");
-
-    EmitIgnoredExpr(cast<Expr>(S));
-
-    llvm::BasicBlock *outgoing = Builder.GetInsertBlock();
-    assert(outgoing && "expression emission cleared block!");
-
-    // The expression emitters assume (reasonably!) that the insertion
-    // point is always set.  To maintain that, the call-emission code
-    // for noreturn functions has to enter a new block with no
-    // predecessors.  We want to kill that block and mark the current
-    // insertion point unreachable in the common case of a call like
-    // "exit();".  Since expression emission doesn't otherwise create
-    // blocks with no predecessors, we can just test for that.
-    // However, we must be careful not to do this to our incoming
-    // block, because *statement* emission does sometimes create
-    // reachable blocks which will have no predecessors until later in
-    // the function.  This occurs with, e.g., labels that are not
-    // reachable by fallthrough.
-    if (incoming != outgoing && outgoing->use_empty()) {
-      outgoing->eraseFromParent();
-      Builder.ClearInsertionPoint();
+    {
+      // Remember the block we came in on.
+      llvm::BasicBlock *incoming = Builder.GetInsertBlock();
+      assert(incoming && "expression emission must have an insertion point");
+
+      EmitIgnoredExpr(cast<Expr>(S));
+
+      llvm::BasicBlock *outgoing = Builder.GetInsertBlock();
+      assert(outgoing && "expression emission cleared block!");
+
+      // The expression emitters assume (reasonably!) that the insertion
+      // point is always set.  To maintain that, the call-emission code
+      // for noreturn functions has to enter a new block with no
+      // predecessors.  We want to kill that block and mark the current
+      // insertion point unreachable in the common case of a call like
+      // "exit();".  Since expression emission doesn't otherwise create
+      // blocks with no predecessors, we can just test for that.
+      // However, we must be careful not to do this to our incoming
+      // block, because *statement* emission does sometimes create
+      // reachable blocks which will have no predecessors until later in
+      // the function.  This occurs with, e.g., labels that are not
+      // reachable by fallthrough.
+      if (incoming != outgoing && outgoing->use_empty()) {
+        outgoing->eraseFromParent();
+        Builder.ClearInsertionPoint();
+      }
+      break;
     }
-    break;
-  }
 
   case Stmt::IndirectGotoStmtClass:
-    EmitIndirectGotoStmt(cast<IndirectGotoStmt>(*S)); break;
+    EmitIndirectGotoStmt(cast<IndirectGotoStmt>(*S));
+    break;
 
-  case Stmt::IfStmtClass:      EmitIfStmt(cast<IfStmt>(*S));              break;
-  case Stmt::WhileStmtClass:   EmitWhileStmt(cast<WhileStmt>(*S), Attrs); break;
-  case Stmt::DoStmtClass:      EmitDoStmt(cast<DoStmt>(*S), Attrs);       break;
-  case Stmt::ForStmtClass:     EmitForStmt(cast<ForStmt>(*S), Attrs);     break;
-
-  case Stmt::ReturnStmtClass:  EmitReturnStmt(cast<ReturnStmt>(*S));      break;
-
-  case Stmt::SwitchStmtClass:  EmitSwitchStmt(cast<SwitchStmt>(*S));      break;
-  case Stmt::GCCAsmStmtClass:  // Intentional fall-through.
-  case Stmt::MSAsmStmtClass:   EmitAsmStmt(cast<AsmStmt>(*S));            break;
+  case Stmt::IfStmtClass:
+    EmitIfStmt(cast<IfStmt>(*S));
+    break;
+  case Stmt::WhileStmtClass:
+    EmitWhileStmt(cast<WhileStmt>(*S), Attrs);
+    break;
+  case Stmt::DoStmtClass:
+    EmitDoStmt(cast<DoStmt>(*S), Attrs);
+    break;
+  case Stmt::ForStmtClass:
+    EmitForStmt(cast<ForStmt>(*S), Attrs);
+    break;
+
+  case Stmt::ReturnStmtClass:
+    EmitReturnStmt(cast<ReturnStmt>(*S));
+    break;
+
+  case Stmt::SwitchStmtClass:
+    EmitSwitchStmt(cast<SwitchStmt>(*S));
+    break;
+  case Stmt::GCCAsmStmtClass: // Intentional fall-through.
+  case Stmt::MSAsmStmtClass:
+    EmitAsmStmt(cast<AsmStmt>(*S));
+    break;
   case Stmt::CoroutineBodyStmtClass:
     EmitCoroutineBody(cast<CoroutineBodyStmt>(*S));
     break;
@@ -164,17 +184,16 @@ void CodeGenFunction::EmitStmt(const Stm
   case Stmt::CapturedStmtClass: {
     const CapturedStmt *CS = cast<CapturedStmt>(S);
     EmitCapturedStmt(*CS, CS->getCapturedRegionKind());
-    }
-    break;
+  } break;
   case Stmt::ObjCAtTryStmtClass:
     EmitObjCAtTryStmt(cast<ObjCAtTryStmt>(*S));
     break;
   case Stmt::ObjCAtCatchStmtClass:
     llvm_unreachable(
-                    "@catch statements should be handled by EmitObjCAtTryStmt");
+        "@catch statements should be handled by EmitObjCAtTryStmt");
   case Stmt::ObjCAtFinallyStmtClass:
     llvm_unreachable(
-                  "@finally statements should be handled by EmitObjCAtTryStmt");
+        "@finally statements should be handled by EmitObjCAtTryStmt");
   case Stmt::ObjCAtThrowStmtClass:
     EmitObjCAtThrowStmt(cast<ObjCAtThrowStmt>(*S));
     break;
@@ -445,8 +464,9 @@ bool CodeGenFunction::EmitSimpleStmt(con
 /// (for use by the statement expression extension).
 Address CodeGenFunction::EmitCompoundStmt(const CompoundStmt &S, bool GetLast,
                                           AggValueSlot AggSlot) {
-  PrettyStackTraceLoc CrashInfo(getContext().getSourceManager(),S.getLBracLoc(),
-                             "LLVM IR generation of compound statement ('{}')");
+  PrettyStackTraceLoc CrashInfo(
+      getContext().getSourceManager(), S.getLBracLoc(),
+      "LLVM IR generation of compound statement ('{}')");
 
   // Keep track of the current cleanup stack depth, including debug scopes.
   LexicalScope Scope(*this, S.getSourceRange());
@@ -454,10 +474,9 @@ Address CodeGenFunction::EmitCompoundStm
   return EmitCompoundStmtWithoutScope(S, GetLast, AggSlot);
 }
 
-Address
-CodeGenFunction::EmitCompoundStmtWithoutScope(const CompoundStmt &S,
-                                              bool GetLast,
-                                              AggValueSlot AggSlot) {
+Address CodeGenFunction::EmitCompoundStmtWithoutScope(const CompoundStmt &S,
+                                                      bool GetLast,
+                                                      AggValueSlot AggSlot) {
 
   const Stmt *ExprResult = S.getStmtExprResult();
   assert((!GetLast || (GetLast && ExprResult)) &&
@@ -586,7 +605,8 @@ void CodeGenFunction::EmitBlockAfterUses
 CodeGenFunction::JumpDest
 CodeGenFunction::getJumpDestForLabel(const LabelDecl *D) {
   JumpDest &Dest = LabelMap[D];
-  if (Dest.isValid()) return Dest;
+  if (Dest.isValid())
+    return Dest;
 
   // Create, but don't insert, the new block.
   Dest = JumpDest(createBasicBlock(D->getName()),
@@ -609,8 +629,8 @@ void CodeGenFunction::EmitLabel(const La
   if (!Dest.isValid()) {
     Dest = getJumpDestInCurrentScope(D->getName());
 
-  // Otherwise, we need to give this label a target depth and remove
-  // it from the branch-fixups list.
+    // Otherwise, we need to give this label a target depth and remove
+    // it from the branch-fixups list.
   } else {
     assert(!Dest.getScopeDepth().isValid() && "already emitted label!");
     Dest.setScopeDepth(EHStack.stable_begin());
@@ -634,12 +654,13 @@ void CodeGenFunction::EmitLabel(const La
 /// match the scope of the enclosing context.
 void CodeGenFunction::LexicalScope::rescopeLabels() {
   assert(!Labels.empty());
-  EHScopeStack::stable_iterator innermostScope
-    = CGF.EHStack.getInnermostNormalCleanup();
+  EHScopeStack::stable_iterator innermostScope =
+      CGF.EHStack.getInnermostNormalCleanup();
 
   // Change the scope depth of all the labels.
-  for (SmallVectorImpl<const LabelDecl*>::const_iterator
-         i = Labels.begin(), e = Labels.end(); i != e; ++i) {
+  for (SmallVectorImpl<const LabelDecl *>::const_iterator i = Labels.begin(),
+                                                          e = Labels.end();
+       i != e; ++i) {
     assert(CGF.LabelMap.count(*i));
     JumpDest &dest = CGF.LabelMap.find(*i)->second;
     assert(dest.getScopeDepth().isValid());
@@ -653,7 +674,6 @@ void CodeGenFunction::LexicalScope::resc
   }
 }
 
-
 void CodeGenFunction::EmitLabelStmt(const LabelStmt &S) {
   EmitLabel(S.getDecl());
 
@@ -693,7 +713,6 @@ void CodeGenFunction::EmitGotoStmt(const
   EmitBranchThroughCleanup(getJumpDestForLabel(S.getLabel()));
 }
 
-
 void CodeGenFunction::EmitIndirectGotoStmt(const IndirectGotoStmt &S) {
   if (const LabelDecl *Target = S.getConstantTarget()) {
     EmitBranchThroughCleanup(getJumpDestForLabel(Target));
@@ -701,8 +720,8 @@ void CodeGenFunction::EmitIndirectGotoSt
   }
 
   // Ensure that we have an i8* for our PHI node.
-  llvm::Value *V = Builder.CreateBitCast(EmitScalarExpr(S.getTarget()),
-                                         Int8PtrTy, "addr");
+  llvm::Value *V =
+      Builder.CreateBitCast(EmitScalarExpr(S.getTarget()), Int8PtrTy, "addr");
   llvm::BasicBlock *CurBB = Builder.GetInsertBlock();
 
   // Get the basic block for the indirect goto.
@@ -744,8 +763,8 @@ void CodeGenFunction::EmitIfStmt(const I
                                    S.isConstexpr())) {
     // Figure out which block (then or else) is executed.
     const Stmt *Executed = S.getThen();
-    const Stmt *Skipped  = S.getElse();
-    if (!CondConstant)  // Condition false?
+    const Stmt *Skipped = S.getElse();
+    if (!CondConstant) // Condition false?
       std::swap(Executed, Skipped);
 
     // If the skipped block has no labels in it, just emit the executed block.
@@ -905,10 +924,119 @@ void CodeGenFunction::EmitWhileStmt(cons
   // a branch, try to erase it.
   if (!EmitBoolCondBranch)
     SimplifyForwardingBlocks(LoopHeader.getBlock());
+
+  // Modified By Zeng-WCh
+  // Check if loop header is valid
+  // If it is valid, add metadata to the loop header
+  // The metadata is used to mark the loop header
+  auto *LPHeader = LoopHeader.getBlock();
+  if (LPHeader) {
+    // So here is a bit of dark magic
+    // insert the metadata in the last instruction of the loop header
+    // as most of the time the last instruction is a branch
+    // mostly it will not be emmitted when doing
+    // optimization
+    auto &LastInstr = LPHeader->back();
+    // Add Metadata info
+    auto LineNo =
+        getContext().getSourceManager().getExpansionLineNumber(S.getBeginLoc());
+    auto &Module = CGM.getModule();
+    auto SrcFileL = getContext()
+                        .getSourceManager()
+                        .getFilename(S.getBeginLoc())
+                        .rsplit('.');
+    auto SrcFileWithoutExtL = SrcFileL.first.rsplit('/');
+    std::string SrcFileWithoutExt;
+
+    if (SrcFileWithoutExtL.second.empty()) {
+      SrcFileWithoutExt = SrcFileWithoutExtL.first.str();
+    } else {
+      SrcFileWithoutExt = SrcFileWithoutExtL.second.str();
+    }
+
+    auto SrcFile = SrcFileWithoutExt + SrcFileL.second.str();
+
+    // LastInstr.addAnnotationMetadata(ss.str());
+    LastInstr.setMetadata(
+        "loop.src.loc",
+        llvm::MDNode::get(
+            Module.getContext(),
+            {llvm::ConstantAsMetadata::get(Builder.getInt64(LineNo)),
+             llvm::MDString::get(Builder.getContext(), SrcFile)}));
+  }
+
+  auto *Bound = S.getBound();
+  S.setBound(nullptr);
+  if (Bound) {
+    // Add Metadata to the loop header
+    auto functionName = CurFn->getName();
+    // Line as line
+    auto Line =
+        getContext().getSourceManager().getExpansionLineNumber(S.getBeginLoc());
+    auto SrcFileL = getContext()
+                        .getSourceManager()
+                        .getFilename(S.getBeginLoc())
+                        .rsplit('.');
+    auto SrcFileWithoutExtL = SrcFileL.first.rsplit('/');
+
+    std::string SrcFileWithoutExt;
+    if (SrcFileWithoutExtL.second.empty()) {
+      SrcFileWithoutExt = SrcFileWithoutExtL.first.str();
+    } else {
+      SrcFileWithoutExt = SrcFileWithoutExtL.second.str();
+    }
+
+    // Use std string stream to get the fmt
+    std::stringstream ss;
+
+    ss << functionName.str() << "."
+       << "loop.near.line." << Line; //<< "|";
+
+    // llvm::outs() << ss.str() << '\n';
+
+    auto &Module = CGM.getModule();
+    auto *MD = Module.getOrInsertNamedMetadata(ss.str());
+    auto *BoundMD = llvm::MDNode::get(
+        Module.getContext(),
+        {llvm::ConstantAsMetadata::get(Builder.getInt64(Bound[0])),
+         llvm::ConstantAsMetadata::get(Builder.getInt64(Bound[1]))});
+#if 0
+    BoundMD->dump();
+    llvm::outs() << BoundMD->getNumOperands() << "\n";
+    llvm::outs() << "Bound: "
+                 << cast<llvm::ConstantAsMetadata>(BoundMD->getOperand(0).get())
+                        ->getValue()
+                        ->getUniqueInteger()
+                        .getZExtValue()
+                 << "\t"
+                 << cast<llvm::ConstantAsMetadata>(BoundMD->getOperand(1).get())
+                        ->getValue()
+                        ->getUniqueInteger()
+                        .getZExtValue()
+                 << "\n";
+#endif
+    MD->addOperand(BoundMD);
+    if (LPHeader) {
+      LPHeader->back().setMetadata("loop.bound.annotation", BoundMD);
+    }
+    delete[] Bound;
+  }
+  // End Modification
 }
 
 void CodeGenFunction::EmitDoStmt(const DoStmt &S,
                                  ArrayRef<const Attr *> DoAttrs) {
+  // Modified By Zeng-WCh
+  // Add an annotation to the loop header
+  // The annotation is used to mark the loop header
+  // llvm::outs() << "DO STMT: "
+  //              <<
+  //              S.getBeginLoc().printToString(getContext().getSourceManager())
+  //              << '\n';
+  // llvm::outs() << "DO (BEGIN)STMT: "
+  //              << S.getDoLoc().printToString(getContext().getSourceManager())
+  //              << '\n';
+  // End Modification
   JumpDest LoopExit = getJumpDestInCurrentScope("do.end");
   JumpDest LoopCond = getJumpDestInCurrentScope("do.cond");
 
@@ -967,6 +1095,104 @@ void CodeGenFunction::EmitDoStmt(const D
   // emitting a branch, try to erase it.
   if (!EmitBoolCondBranch)
     SimplifyForwardingBlocks(LoopCond.getBlock());
+
+  // Modified By Zeng-WCh
+  // Check if loop header is valid
+  // If it is valid, add metadata to the loop header
+  // The metadata is used to mark the loop header
+  auto *LPHeader = LoopBody;
+  if (LPHeader) {
+    // So here is a bit of dark magic
+    // insert the metadata in the last instruction of the loop header
+    // as most of the time the last instruction is a branch
+    // mostly it will not be emmitted when doing
+    // optimization
+    auto &LastInstr = LPHeader->back();
+    // Add Metadata info
+    auto LineNo =
+        getContext().getSourceManager().getExpansionLineNumber(S.getBeginLoc());
+    auto &Module = CGM.getModule();
+    auto SrcFileL = getContext()
+                        .getSourceManager()
+                        .getFilename(S.getBeginLoc())
+                        .rsplit('.');
+    auto SrcFileWithoutExtL = SrcFileL.first.rsplit('/');
+    std::string SrcFileWithoutExt;
+
+    if (SrcFileWithoutExtL.second.empty()) {
+      SrcFileWithoutExt = SrcFileWithoutExtL.first.str();
+    } else {
+      SrcFileWithoutExt = SrcFileWithoutExtL.second.str();
+    }
+
+    auto SrcFile = SrcFileWithoutExt + SrcFileL.second.str();
+
+    // LastInstr.addAnnotationMetadata(ss.str());
+    LastInstr.setMetadata(
+        "loop.src.loc",
+        llvm::MDNode::get(
+            Module.getContext(),
+            {llvm::ConstantAsMetadata::get(Builder.getInt64(LineNo)),
+             llvm::MDString::get(Builder.getContext(), SrcFile)}));
+  }
+
+  auto *Bound = S.getBound();
+  S.setBound(nullptr);
+  if (Bound) {
+    // Add Metadata to the loop header
+    auto functionName = CurFn->getName();
+    // Line as line
+    auto Line =
+        getContext().getSourceManager().getExpansionLineNumber(S.getBeginLoc());
+    auto SrcFileL = getContext()
+                        .getSourceManager()
+                        .getFilename(S.getBeginLoc())
+                        .rsplit('.');
+    auto SrcFileWithoutExtL = SrcFileL.first.rsplit('/');
+
+    std::string SrcFileWithoutExt;
+    if (SrcFileWithoutExtL.second.empty()) {
+      SrcFileWithoutExt = SrcFileWithoutExtL.first.str();
+    } else {
+      SrcFileWithoutExt = SrcFileWithoutExtL.second.str();
+    }
+
+    // Use std string stream to get the fmt
+    std::stringstream ss;
+
+    ss << functionName.str() << "."
+       << "loop.near.line." << Line; //<< "|";
+
+    // llvm::outs() << ss.str() << '\n';
+
+    auto &Module = CGM.getModule();
+    auto *MD = Module.getOrInsertNamedMetadata(ss.str());
+    auto *BoundMD = llvm::MDNode::get(
+        Module.getContext(),
+        {llvm::ConstantAsMetadata::get(Builder.getInt64(Bound[0])),
+         llvm::ConstantAsMetadata::get(Builder.getInt64(Bound[1]))});
+#if 0
+    BoundMD->dump();
+    llvm::outs() << BoundMD->getNumOperands() << "\n";
+    llvm::outs() << "Bound: "
+                 << cast<llvm::ConstantAsMetadata>(BoundMD->getOperand(0).get())
+                        ->getValue()
+                        ->getUniqueInteger()
+                        .getZExtValue()
+                 << "\t"
+                 << cast<llvm::ConstantAsMetadata>(BoundMD->getOperand(1).get())
+                        ->getValue()
+                        ->getUniqueInteger()
+                        .getZExtValue()
+                 << "\n";
+#endif
+    MD->addOperand(BoundMD);
+    if (LPHeader) {
+      LPHeader->back().setMetadata("loop.bound.annotation", BoundMD);
+    }
+    delete[] Bound;
+  }
+  // End Modification
 }
 
 void CodeGenFunction::EmitForStmt(const ForStmt &S,
@@ -1083,11 +1309,93 @@ void CodeGenFunction::EmitForStmt(const
 
   // Emit the fall-through block.
   EmitBlock(LoopExit.getBlock(), true);
+
+  // Modified By Zeng-WCh
+  // Check if loop header is valid
+  // If it is valid, add metadata to the loop header
+  // The metadata is used to mark the loop header
+  auto *LPHeader = CondDest.getBlock();
+  if (LPHeader) {
+    // So here is a bit of dark magic
+    // insert the metadata in the last instruction of the loop header
+    // as most of the time the last instruction is a branch
+    // mostly it will not be emmitted when doing
+    // optimization
+    auto &LastInstr = LPHeader->back();
+    // Add Metadata info
+    auto LineNo =
+        getContext().getSourceManager().getExpansionLineNumber(S.getBeginLoc());
+    auto &Module = CGM.getModule();
+    auto SrcFileL = getContext()
+                        .getSourceManager()
+                        .getFilename(S.getBeginLoc())
+                        .rsplit('.');
+    auto SrcFileWithoutExtL = SrcFileL.first.rsplit('/');
+    std::string SrcFileWithoutExt;
+
+    if (SrcFileWithoutExtL.second.empty()) {
+      SrcFileWithoutExt = SrcFileWithoutExtL.first.str();
+    } else {
+      SrcFileWithoutExt = SrcFileWithoutExtL.second.str();
+    }
+
+    auto SrcFile = SrcFileWithoutExt + SrcFileL.second.str();
+
+    // LastInstr.addAnnotationMetadata(ss.str());
+    LastInstr.setMetadata(
+        "loop.src.loc",
+        llvm::MDNode::get(
+            Module.getContext(),
+            {llvm::ConstantAsMetadata::get(Builder.getInt64(LineNo)),
+             llvm::MDString::get(Builder.getContext(), SrcFile)}));
+  }
+
+  auto *Bound = S.getBound();
+  S.setBound(nullptr);
+  if (Bound) {
+    // Add Metadata to the loop header
+    auto functionName = CurFn->getName();
+    // Line as line
+    auto Line =
+        getContext().getSourceManager().getExpansionLineNumber(S.getBeginLoc());
+    auto SrcFileL = getContext()
+                        .getSourceManager()
+                        .getFilename(S.getBeginLoc())
+                        .rsplit('.');
+    auto SrcFileWithoutExtL = SrcFileL.first.rsplit('/');
+
+    std::string SrcFileWithoutExt;
+    if (SrcFileWithoutExtL.second.empty()) {
+      SrcFileWithoutExt = SrcFileWithoutExtL.first.str();
+    } else {
+      SrcFileWithoutExt = SrcFileWithoutExtL.second.str();
+    }
+
+    // Use std string stream to get the fmt
+    std::stringstream ss;
+
+    ss << functionName.str() << "."
+       << "loop.near.line." << Line; //<< "|";
+
+    // llvm::outs() << ss.str() << '\n';
+
+    auto &Module = CGM.getModule();
+    auto *MD = Module.getOrInsertNamedMetadata(ss.str());
+    auto *BoundMD = llvm::MDNode::get(
+        Module.getContext(),
+        {llvm::ConstantAsMetadata::get(Builder.getInt64(Bound[0])),
+         llvm::ConstantAsMetadata::get(Builder.getInt64(Bound[1]))});
+    MD->addOperand(BoundMD);
+    if (LPHeader) {
+      LPHeader->back().setMetadata("loop.bound.annotation", BoundMD);
+    }
+    delete[] Bound;
+  }
+  // End Modification
 }
 
-void
-CodeGenFunction::EmitCXXForRangeStmt(const CXXForRangeStmt &S,
-                                     ArrayRef<const Attr *> ForAttrs) {
+void CodeGenFunction::EmitCXXForRangeStmt(const CXXForRangeStmt &S,
+                                          ArrayRef<const Attr *> ForAttrs) {
   JumpDest LoopExit = getJumpDestInCurrentScope("for.end");
 
   LexicalScope ForScope(*this, S.getSourceRange());
@@ -1306,12 +1614,11 @@ void CodeGenFunction::EmitReturnStmt(con
                                 /*isInit*/ true);
       break;
     case TEK_Aggregate:
-      EmitAggExpr(RV, AggValueSlot::forAddr(
-                          ReturnValue, Qualifiers(),
-                          AggValueSlot::IsDestructed,
-                          AggValueSlot::DoesNotNeedGCBarriers,
-                          AggValueSlot::IsNotAliased,
-                          getOverlapForReturnValue()));
+      EmitAggExpr(RV, AggValueSlot::forAddr(ReturnValue, Qualifiers(),
+                                            AggValueSlot::IsDestructed,
+                                            AggValueSlot::DoesNotNeedGCBarriers,
+                                            AggValueSlot::IsNotAliased,
+                                            getOverlapForReturnValue()));
       break;
     }
   }
@@ -1420,9 +1727,9 @@ void CodeGenFunction::EmitCaseStmtRange(
 
   // Emit range check.
   llvm::Value *Diff =
-    Builder.CreateSub(SwitchInsn->getCondition(), Builder.getInt(LHS));
+      Builder.CreateSub(SwitchInsn->getCondition(), Builder.getInt(LHS));
   llvm::Value *Cond =
-    Builder.CreateICmpULE(Diff, Builder.getInt(Range), "inbounds");
+      Builder.CreateICmpULE(Diff, Builder.getInt(Range), "inbounds");
 
   llvm::MDNode *Weights = nullptr;
   if (SwitchWeights) {
@@ -1465,7 +1772,7 @@ void CodeGenFunction::EmitCaseStmt(const
   }
 
   llvm::ConstantInt *CaseVal =
-    Builder.getInt(S.getLHS()->EvaluateKnownConstInt(getContext()));
+      Builder.getInt(S.getLHS()->EvaluateKnownConstInt(getContext()));
   if (SwitchLikelihood)
     SwitchLikelihood->push_back(Stmt::getLikelihood(Attrs));
 
@@ -1519,7 +1826,7 @@ void CodeGenFunction::EmitCaseStmt(const
   while (NextCase && NextCase->getRHS() == nullptr) {
     CurCase = NextCase;
     llvm::ConstantInt *CaseVal =
-      Builder.getInt(CurCase->getLHS()->EvaluateKnownConstInt(getContext()));
+        Builder.getInt(CurCase->getLHS()->EvaluateKnownConstInt(getContext()));
 
     if (SwitchWeights)
       SwitchWeights->push_back(getProfileCount(NextCase));
@@ -1592,10 +1899,9 @@ void CodeGenFunction::EmitDefaultStmt(co
 /// true.
 ///
 enum CSFC_Result { CSFC_Failure, CSFC_FallThrough, CSFC_Success };
-static CSFC_Result CollectStatementsForCase(const Stmt *S,
-                                            const SwitchCase *Case,
-                                            bool &FoundCase,
-                              SmallVectorImpl<const Stmt*> &ResultStmts) {
+static CSFC_Result
+CollectStatementsForCase(const Stmt *S, const SwitchCase *Case, bool &FoundCase,
+                         SmallVectorImpl<const Stmt *> &ResultStmts) {
   // If this is a null statement, just succeed.
   if (!S)
     return Case ? CSFC_Success : CSFC_FallThrough;
@@ -1641,7 +1947,8 @@ static CSFC_Result CollectStatementsForC
         HadSkippedDecl |= CodeGenFunction::mightAddDeclToScope(*I);
 
         switch (CollectStatementsForCase(*I, Case, FoundCase, ResultStmts)) {
-        case CSFC_Failure: return CSFC_Failure;
+        case CSFC_Failure:
+          return CSFC_Failure;
         case CSFC_Success:
           // A successful result means that either 1) that the statement doesn't
           // have the case and is skippable, or 2) does contain the case value
@@ -1688,7 +1995,8 @@ static CSFC_Result CollectStatementsForC
       AnyDecls |= CodeGenFunction::mightAddDeclToScope(*I);
 
       switch (CollectStatementsForCase(*I, nullptr, FoundCase, ResultStmts)) {
-      case CSFC_Failure: return CSFC_Failure;
+      case CSFC_Failure:
+        return CSFC_Failure;
       case CSFC_FallThrough:
         // A fallthrough result means that the statement was simple and just
         // included in ResultStmt, keep adding them afterwards.
@@ -1735,7 +2043,8 @@ static CSFC_Result CollectStatementsForC
 
   // Otherwise, we want to include this statement.  Everything is cool with that
   // so long as it doesn't contain a break out of the switch we're in.
-  if (CodeGenFunction::containsBreak(S)) return CSFC_Failure;
+  if (CodeGenFunction::containsBreak(S))
+    return CSFC_Failure;
 
   // Otherwise, everything is great.  Include the statement and tell the caller
   // that we fall through and include the next statement as well.
@@ -1747,11 +2056,11 @@ static CSFC_Result CollectStatementsForC
 /// then invoke CollectStatementsForCase to find the list of statements to emit
 /// for a switch on constant.  See the comment above CollectStatementsForCase
 /// for more details.
-static bool FindCaseStatementsForValue(const SwitchStmt &S,
-                                       const llvm::APSInt &ConstantCondValue,
-                                SmallVectorImpl<const Stmt*> &ResultStmts,
-                                       ASTContext &C,
-                                       const SwitchCase *&ResultCase) {
+static bool
+FindCaseStatementsForValue(const SwitchStmt &S,
+                           const llvm::APSInt &ConstantCondValue,
+                           SmallVectorImpl<const Stmt *> &ResultStmts,
+                           ASTContext &C, const SwitchCase *&ResultCase) {
   // First step, find the switch case that is being branched to.  We can do this
   // efficiently by scanning the SwitchCase list.
   const SwitchCase *Case = S.getSwitchCaseList();
@@ -1768,7 +2077,8 @@ static bool FindCaseStatementsForValue(c
     // Check to see if this case is the one we're looking for.
     const CaseStmt *CS = cast<CaseStmt>(Case);
     // Don't handle case ranges yet.
-    if (CS->getRHS()) return false;
+    if (CS->getRHS())
+      return false;
 
     // If we found our case, remember it as 'case'.
     if (CS->getLHS()->EvaluateKnownConstInt(C) == ConstantCondValue)
@@ -1795,8 +2105,8 @@ static bool FindCaseStatementsForValue(c
   //     case 4: ...
   bool FoundCase = false;
   ResultCase = Case;
-  return CollectStatementsForCase(S.getBody(), Case, FoundCase,
-                                  ResultStmts) != CSFC_Failure &&
+  return CollectStatementsForCase(S.getBody(), Case, FoundCase, ResultStmts) !=
+             CSFC_Failure &&
          FoundCase;
 }
 
@@ -1867,7 +2177,7 @@ void CodeGenFunction::EmitSwitchStmt(con
   // emit the live case statement (if any) of the switch.
   llvm::APSInt ConstantCondValue;
   if (ConstantFoldsToSimpleInteger(S.getCond(), ConstantCondValue)) {
-    SmallVector<const Stmt*, 4> CaseStmts;
+    SmallVector<const Stmt *, 4> CaseStmts;
     const SwitchCase *Case = nullptr;
     if (FindCaseStatementsForValue(S, ConstantCondValue, CaseStmts,
                                    getContext(), Case)) {
@@ -1923,8 +2233,7 @@ void CodeGenFunction::EmitSwitchStmt(con
     // Walk the SwitchCase list to find how many there are.
     uint64_t DefaultCount = 0;
     unsigned NumCases = 0;
-    for (const SwitchCase *Case = S.getSwitchCaseList();
-         Case;
+    for (const SwitchCase *Case = S.getSwitchCaseList(); Case;
          Case = Case->getNextSwitchCase()) {
       if (isa<DefaultStmt>(Case))
         DefaultCount = getProfileCount(Case);
@@ -1970,7 +2279,7 @@ void CodeGenFunction::EmitSwitchStmt(con
     if (ConditionScope.requiresCleanups()) {
       EmitBlock(DefaultBlock);
 
-    // Otherwise, just forward the default block to the switch end.
+      // Otherwise, just forward the default block to the switch end.
     } else {
       DefaultBlock->replaceAllUsesWith(SwitchExit.getBlock());
       delete DefaultBlock;
@@ -2022,9 +2331,9 @@ void CodeGenFunction::EmitSwitchStmt(con
   CaseRangeBlock = SavedCRBlock;
 }
 
-static std::string
-SimplifyConstraint(const char *Constraint, const TargetInfo &Target,
-                 SmallVectorImpl<TargetInfo::ConstraintInfo> *OutCons=nullptr) {
+static std::string SimplifyConstraint(
+    const char *Constraint, const TargetInfo &Target,
+    SmallVectorImpl<TargetInfo::ConstraintInfo> *OutCons = nullptr) {
   std::string Result;
 
   while (*Constraint) {
@@ -2060,7 +2369,8 @@ SimplifyConstraint(const char *Constrain
              "Must pass output names to constraints with a symbolic name");
       unsigned Index;
       bool result = Target.resolveSymbolicName(Constraint, *OutCons, Index);
-      assert(result && "Could not resolve symbolic name"); (void)result;
+      assert(result && "Could not resolve symbolic name");
+      (void)result;
       Result += llvm::utostr(Index);
       break;
     }
@@ -2097,8 +2407,7 @@ AddVariableConstraints(const std::string
   // We're using validateOutputConstraint here because we only care if
   // this is a register constraint.
   TargetInfo::ConstraintInfo Info(Constraint, "");
-  if (Target.validateOutputConstraint(Info) &&
-      !Info.allowsRegister()) {
+  if (Target.validateOutputConstraint(Info) && !Info.allowsRegister()) {
     CGM.ErrorUnsupported(&Stmt, "__asm__");
     return Constraint;
   }
@@ -2109,7 +2418,7 @@ AddVariableConstraints(const std::string
   return (EarlyClobber ? "&{" : "{") + Register.str() + "}";
 }
 
-std::pair<llvm::Value*, llvm::Type *> CodeGenFunction::EmitAsmInputLValue(
+std::pair<llvm::Value *, llvm::Type *> CodeGenFunction::EmitAsmInputLValue(
     const TargetInfo::ConstraintInfo &Info, LValue InputValue,
     QualType InputType, std::string &ConstraintStr, SourceLocation Loc) {
   if (Info.allowsRegister() || !Info.allowsMemory()) {
@@ -2188,7 +2497,8 @@ static llvm::MDNode *getAsmSrcLocInfo(co
     // Add the location of the start of each subsequent line of the asm to the
     // MDNode.
     for (unsigned i = 0, e = StrVal.size() - 1; i != e; ++i) {
-      if (StrVal[i] != '\n') continue;
+      if (StrVal[i] != '\n')
+        continue;
       SourceLocation LineLoc = Str->getLocationOfByte(
           i + 1, SM, LangOpts, CGF.getTarget(), &StartToken, &ByteOffset);
       Locs.push_back(llvm::ConstantAsMetadata::get(
@@ -2253,7 +2563,8 @@ static void UpdateAsmCallInst(llvm::Call
     RegResults.push_back(&Result);
   } else {
     for (unsigned i = 0, e = ResultRegTypes.size(); i != e; ++i) {
-      llvm::Value *Tmp = CGF.Builder.CreateExtractValue(&Result, i, "asmresult");
+      llvm::Value *Tmp =
+          CGF.Builder.CreateExtractValue(&Result, i, "asmresult");
       RegResults.push_back(Tmp);
     }
   }
@@ -2272,7 +2583,8 @@ void CodeGenFunction::EmitAsmStmt(const
     if (const GCCAsmStmt *GAS = dyn_cast<GCCAsmStmt>(&S))
       Name = GAS->getOutputName(i);
     TargetInfo::ConstraintInfo Info(S.getOutputConstraint(i), Name);
-    bool IsValid = getTarget().validateOutputConstraint(Info); (void)IsValid;
+    bool IsValid = getTarget().validateOutputConstraint(Info);
+    (void)IsValid;
     assert(IsValid && "Failed to parse output constraint");
     OutputConstraintInfos.push_back(Info);
   }
@@ -2283,8 +2595,9 @@ void CodeGenFunction::EmitAsmStmt(const
       Name = GAS->getInputName(i);
     TargetInfo::ConstraintInfo Info(S.getInputConstraint(i), Name);
     bool IsValid =
-      getTarget().validateInputConstraint(OutputConstraintInfos, Info);
-    assert(IsValid && "Failed to parse input constraint"); (void)IsValid;
+        getTarget().validateInputConstraint(OutputConstraintInfos, Info);
+    assert(IsValid && "Failed to parse input constraint");
+    (void)IsValid;
     InputConstraintInfos.push_back(Info);
   }
 
@@ -2296,14 +2609,14 @@ void CodeGenFunction::EmitAsmStmt(const
   std::vector<llvm::Type *> ResultTruncRegTypes;
   std::vector<llvm::Type *> ArgTypes;
   std::vector<llvm::Type *> ArgElemTypes;
-  std::vector<llvm::Value*> Args;
+  std::vector<llvm::Value *> Args;
   llvm::BitVector ResultTypeRequiresCast;
 
   // Keep track of inout constraints.
   std::string InOutConstraints;
-  std::vector<llvm::Value*> InOutArgs;
-  std::vector<llvm::Type*> InOutArgTypes;
-  std::vector<llvm::Type*> InOutArgElemTypes;
+  std::vector<llvm::Value *> InOutArgs;
+  std::vector<llvm::Type *> InOutArgTypes;
+  std::vector<llvm::Type *> InOutArgElemTypes;
 
   // Keep track of out constraints for tied input operand.
   std::vector<std::string> OutputConstraints;
@@ -2331,10 +2644,9 @@ void CodeGenFunction::EmitAsmStmt(const
     OutExpr = OutExpr->IgnoreParenNoopCasts(getContext());
 
     std::string GCCReg;
-    OutputConstraint = AddVariableConstraints(OutputConstraint, *OutExpr,
-                                              getTarget(), CGM, S,
-                                              Info.earlyClobber(),
-                                              &GCCReg);
+    OutputConstraint =
+        AddVariableConstraints(OutputConstraint, *OutExpr, getTarget(), CGM, S,
+                               Info.earlyClobber(), &GCCReg);
     // Give an error on multiple outputs to same physreg.
     if (!GCCReg.empty() && !PhysRegOutputs.insert(GCCReg).second)
       CGM.Error(S.getAsmLoc(), "multiple outputs to hard register: " + GCCReg);
@@ -2347,8 +2659,8 @@ void CodeGenFunction::EmitAsmStmt(const
     // If this is a register output, then make the inline asm return it
     // by-value.  If this is a memory result, return the value by-reference.
     QualType QTy = OutExpr->getType();
-    const bool IsScalarOrAggregate = hasScalarEvaluationKind(QTy) ||
-                                     hasAggregateEvaluationKind(QTy);
+    const bool IsScalarOrAggregate =
+        hasScalarEvaluationKind(QTy) || hasAggregateEvaluationKind(QTy);
     if (!Info.allowsMemory() && IsScalarOrAggregate) {
 
       Constraints += "=" + OutputConstraint;
@@ -2356,7 +2668,8 @@ void CodeGenFunction::EmitAsmStmt(const
       ResultRegDests.push_back(Dest);
 
       llvm::Type *Ty = ConvertTypeForMem(QTy);
-      const bool RequiresCast = Info.allowsRegister() &&
+      const bool RequiresCast =
+          Info.allowsRegister() &&
           (getTargetHooks().isScalarizableAsmOperand(*this, Ty) ||
            Ty->isAggregateType());
 
@@ -2389,9 +2702,8 @@ void CodeGenFunction::EmitAsmStmt(const
           ResultRegTypes.back() = ConvertType(InputTy);
         }
       }
-      if (llvm::Type* AdjTy =
-            getTargetHooks().adjustInlineAsmType(*this, OutputConstraint,
-                                                 ResultRegTypes.back()))
+      if (llvm::Type *AdjTy = getTargetHooks().adjustInlineAsmType(
+              *this, OutputConstraint, ResultRegTypes.back()))
         ResultRegTypes.back() = AdjTy;
       else {
         CGM.getDiags().Report(S.getAsmLoc(),
@@ -2429,13 +2741,12 @@ void CodeGenFunction::EmitAsmStmt(const
       const Expr *InputExpr = S.getOutputExpr(i);
       llvm::Value *Arg;
       llvm::Type *ArgElemType;
-      std::tie(Arg, ArgElemType) = EmitAsmInputLValue(
-          Info, Dest, InputExpr->getType(), InOutConstraints,
-          InputExpr->getExprLoc());
-
-      if (llvm::Type* AdjTy =
-          getTargetHooks().adjustInlineAsmType(*this, OutputConstraint,
-                                               Arg->getType()))
+      std::tie(Arg, ArgElemType) =
+          EmitAsmInputLValue(Info, Dest, InputExpr->getType(), InOutConstraints,
+                             InputExpr->getExprLoc());
+
+      if (llvm::Type *AdjTy = getTargetHooks().adjustInlineAsmType(
+              *this, OutputConstraint, Arg->getType()))
         Arg = Builder.CreateBitCast(Arg, AdjTy);
 
       // Update largest vector width for any vector types.
@@ -2489,7 +2800,7 @@ void CodeGenFunction::EmitAsmStmt(const
         InputConstraint, *InputExpr->IgnoreParenNoopCasts(getContext()),
         getTarget(), CGM, S, false /* No EarlyClobber */);
 
-    std::string ReplaceConstraint (InputConstraint);
+    std::string ReplaceConstraint(InputConstraint);
     llvm::Value *Arg;
     llvm::Type *ArgElemType;
     std::tie(Arg, ArgElemType) = EmitAsmInput(Info, InputExpr, Constraints);
@@ -2522,9 +2833,8 @@ void CodeGenFunction::EmitAsmStmt(const
       // Deal with the tied operands' constraint code in adjustInlineAsmType.
       ReplaceConstraint = OutputConstraints[Output];
     }
-    if (llvm::Type* AdjTy =
-          getTargetHooks().adjustInlineAsmType(*this, ReplaceConstraint,
-                                                   Arg->getType()))
+    if (llvm::Type *AdjTy = getTargetHooks().adjustInlineAsmType(
+            *this, ReplaceConstraint, Arg->getType()))
       Arg = Builder.CreateBitCast(Arg, AdjTy);
     else
       CGM.getDiags().Report(S.getAsmLoc(), diag::err_asm_invalid_type_in_input)
@@ -2554,7 +2864,7 @@ void CodeGenFunction::EmitAsmStmt(const
   SmallVector<llvm::BasicBlock *, 16> Transfer;
   llvm::BasicBlock *Fallthrough = nullptr;
   bool IsGCCAsmGoto = false;
-  if (const auto *GS =  dyn_cast<GCCAsmStmt>(&S)) {
+  if (const auto *GS = dyn_cast<GCCAsmStmt>(&S)) {
     IsGCCAsmGoto = GS->isAsmGoto();
     if (IsGCCAsmGoto) {
       for (const auto *E : GS->labels()) {
@@ -2638,7 +2948,7 @@ void CodeGenFunction::EmitAsmStmt(const
     ResultType = llvm::StructType::get(getLLVMContext(), ResultRegTypes);
 
   llvm::FunctionType *FTy =
-    llvm::FunctionType::get(ResultType, ArgTypes, false);
+      llvm::FunctionType::get(ResultType, ArgTypes, false);
 
   bool HasSideEffect = S.isVolatile() || S.getNumOutputs() == 0;
 
@@ -2646,13 +2956,13 @@ void CodeGenFunction::EmitAsmStmt(const
       CGM.getCodeGenOpts().getInlineAsmDialect() == CodeGenOptions::IAD_ATT
           ? llvm::InlineAsm::AD_ATT
           : llvm::InlineAsm::AD_Intel;
-  llvm::InlineAsm::AsmDialect AsmDialect = isa<MSAsmStmt>(&S) ?
-    llvm::InlineAsm::AD_Intel : GnuAsmDialect;
+  llvm::InlineAsm::AsmDialect AsmDialect =
+      isa<MSAsmStmt>(&S) ? llvm::InlineAsm::AD_Intel : GnuAsmDialect;
 
   llvm::InlineAsm *IA = llvm::InlineAsm::get(
       FTy, AsmString, Constraints, HasSideEffect,
       /* IsAlignStack */ false, AsmDialect, HasUnwindClobber);
-  std::vector<llvm::Value*> RegResults;
+  std::vector<llvm::Value *> RegResults;
   if (IsGCCAsmGoto) {
     llvm::CallBrInst *Result =
         Builder.CreateCallBr(IA, Fallthrough, Transfer, Args);
@@ -2693,13 +3003,14 @@ void CodeGenFunction::EmitAsmStmt(const
         Tmp = Builder.CreateFPTrunc(Tmp, TruncTy);
       else if (TruncTy->isPointerTy() && Tmp->getType()->isIntegerTy()) {
         uint64_t ResSize = CGM.getDataLayout().getTypeSizeInBits(TruncTy);
-        Tmp = Builder.CreateTrunc(Tmp,
-                   llvm::IntegerType::get(getLLVMContext(), (unsigned)ResSize));
+        Tmp = Builder.CreateTrunc(
+            Tmp, llvm::IntegerType::get(getLLVMContext(), (unsigned)ResSize));
         Tmp = Builder.CreateIntToPtr(Tmp, TruncTy);
       } else if (Tmp->getType()->isPointerTy() && TruncTy->isIntegerTy()) {
-        uint64_t TmpSize =CGM.getDataLayout().getTypeSizeInBits(Tmp->getType());
-        Tmp = Builder.CreatePtrToInt(Tmp,
-                   llvm::IntegerType::get(getLLVMContext(), (unsigned)TmpSize));
+        uint64_t TmpSize =
+            CGM.getDataLayout().getTypeSizeInBits(Tmp->getType());
+        Tmp = Builder.CreatePtrToInt(
+            Tmp, llvm::IntegerType::get(getLLVMContext(), (unsigned)TmpSize));
         Tmp = Builder.CreateTrunc(Tmp, TruncTy);
       } else if (TruncTy->isIntegerTy()) {
         Tmp = Builder.CreateZExtOrTrunc(Tmp, TruncTy);
@@ -2740,7 +3051,7 @@ LValue CodeGenFunction::InitCapturedStru
 
   // Initialize the captured struct.
   LValue SlotLV =
-    MakeAddrLValue(CreateMemTemp(RecordTy, "agg.captured"), RecordTy);
+      MakeAddrLValue(CreateMemTemp(RecordTy, "agg.captured"), RecordTy);
 
   RecordDecl::field_iterator CurField = RD->field_begin();
   for (CapturedStmt::const_capture_init_iterator I = S.capture_init_begin(),
@@ -2759,8 +3070,8 @@ LValue CodeGenFunction::InitCapturedStru
 
 /// Generate an outlined function for the body of a CapturedStmt, store any
 /// captured variables into the captured struct, and call the outlined function.
-llvm::Function *
-CodeGenFunction::EmitCapturedStmt(const CapturedStmt &S, CapturedRegionKind K) {
+llvm::Function *CodeGenFunction::EmitCapturedStmt(const CapturedStmt &S,
+                                                  CapturedRegionKind K) {
   LValue CapStruct = InitCapturedStruct(S);
 
   // Emit the CapturedDecl
@@ -2783,8 +3094,9 @@ Address CodeGenFunction::GenerateCapture
 /// Creates the outlined function for a CapturedStmt.
 llvm::Function *
 CodeGenFunction::GenerateCapturedStmtFunction(const CapturedStmt &S) {
-  assert(CapturedStmtInfo &&
-    "CapturedStmtInfo should be set when generating the captured function");
+  assert(
+      CapturedStmtInfo &&
+      "CapturedStmtInfo should be set when generating the captured function");
   const CapturedDecl *CD = S.getCapturedDecl();
   const RecordDecl *RD = S.getCapturedRecordDecl();
   SourceLocation Loc = S.getBeginLoc();
@@ -2797,12 +3109,12 @@ CodeGenFunction::GenerateCapturedStmtFun
 
   // Create the function declaration.
   const CGFunctionInfo &FuncInfo =
-    CGM.getTypes().arrangeBuiltinFunctionDeclaration(Ctx.VoidTy, Args);
+      CGM.getTypes().arrangeBuiltinFunctionDeclaration(Ctx.VoidTy, Args);
   llvm::FunctionType *FuncLLVMTy = CGM.getTypes().GetFunctionType(FuncInfo);
 
-  llvm::Function *F =
-    llvm::Function::Create(FuncLLVMTy, llvm::GlobalValue::InternalLinkage,
-                           CapturedStmtInfo->getHelperName(), &CGM.getModule());
+  llvm::Function *F = llvm::Function::Create(
+      FuncLLVMTy, llvm::GlobalValue::InternalLinkage,
+      CapturedStmtInfo->getHelperName(), &CGM.getModule());
   CGM.SetInternalFunctionAttributes(CD, F, FuncInfo);
   if (CD->isNothrow())
     F->addFnAttr(llvm::Attribute::NoUnwind);
diff --color -uprN clang-14.0.6.src/lib/Parse/ParsePragma.cpp clang-14.0.6.src.patched/lib/Parse/ParsePragma.cpp
--- clang-14.0.6.src/lib/Parse/ParsePragma.cpp	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/lib/Parse/ParsePragma.cpp	2024-11-12 13:24:23.357485188 +0800
@@ -11,21 +11,40 @@
 //===----------------------------------------------------------------------===//
 
 #include "clang/AST/ASTContext.h"
+#include "clang/AST/Stmt.h"
+#include "clang/Basic/AttributeCommonInfo.h"
+#include "clang/Basic/DiagnosticParse.h"
 #include "clang/Basic/PragmaKinds.h"
+#include "clang/Basic/SourceLocation.h"
 #include "clang/Basic/TargetInfo.h"
+#include "clang/Basic/TokenKinds.h"
+#include "clang/Lex/Pragma.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Lex/Token.h"
 #include "clang/Parse/LoopHint.h"
 #include "clang/Parse/ParseDiagnostic.h"
 #include "clang/Parse/Parser.h"
 #include "clang/Parse/RAIIObjectsForParser.h"
+#include "clang/Sema/Ownership.h"
 #include "clang/Sema/Scope.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/StringSwitch.h"
+#include "llvm/ADT/Twine.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/raw_ostream.h"
+#include <cstdint>
 using namespace clang;
 
 namespace {
 
+// Modified by Zeng-WCh
+struct PragmaLoopBoundHandler : public PragmaHandler {
+  explicit PragmaLoopBoundHandler() : PragmaHandler("loopbound") {}
+  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
+                    Token &FirstToken) override;
+};
+// End Modification
+
 struct PragmaAlignHandler : public PragmaHandler {
   explicit PragmaAlignHandler() : PragmaHandler("align") {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
@@ -52,7 +71,7 @@ struct PragmaPackHandler : public Pragma
 
 struct PragmaClangSectionHandler : public PragmaHandler {
   explicit PragmaClangSectionHandler(Sema &S)
-             : PragmaHandler("section"), Actions(S) {}
+      : PragmaHandler("section"), Actions(S) {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
                     Token &FirstToken) override;
 
@@ -90,7 +109,6 @@ struct PragmaOpenCLExtensionHandler : pu
                     Token &FirstToken) override;
 };
 
-
 struct PragmaFPContractHandler : public PragmaHandler {
   PragmaFPContractHandler() : PragmaHandler("FP_CONTRACT") {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
@@ -113,16 +131,16 @@ struct PragmaSTDC_FENV_ACCESSHandler : p
     }
     tok::OnOffSwitch OOS;
     if (PP.LexOnOffSwitch(OOS))
-     return;
+      return;
 
-    MutableArrayRef<Token> Toks(PP.getPreprocessorAllocator().Allocate<Token>(1),
-                                1);
+    MutableArrayRef<Token> Toks(
+        PP.getPreprocessorAllocator().Allocate<Token>(1), 1);
     Toks[0].startToken();
     Toks[0].setKind(tok::annot_pragma_fenv_access);
     Toks[0].setLocation(Tok.getLocation());
     Toks[0].setAnnotationEndLoc(Tok.getLocation());
-    Toks[0].setAnnotationValue(reinterpret_cast<void*>(
-                               static_cast<uintptr_t>(OOS)));
+    Toks[0].setAnnotationValue(
+        reinterpret_cast<void *>(static_cast<uintptr_t>(OOS)));
     PP.EnterTokenStream(Toks, /*DisableMacroExpansion=*/true,
                         /*IsReinject=*/false);
   }
@@ -165,13 +183,13 @@ struct PragmaFPHandler : public PragmaHa
 };
 
 struct PragmaNoOpenMPHandler : public PragmaHandler {
-  PragmaNoOpenMPHandler() : PragmaHandler("omp") { }
+  PragmaNoOpenMPHandler() : PragmaHandler("omp") {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
                     Token &FirstToken) override;
 };
 
 struct PragmaOpenMPHandler : public PragmaHandler {
-  PragmaOpenMPHandler() : PragmaHandler("omp") { }
+  PragmaOpenMPHandler() : PragmaHandler("omp") {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
                     Token &FirstToken) override;
 };
@@ -179,7 +197,7 @@ struct PragmaOpenMPHandler : public Prag
 /// PragmaCommentHandler - "\#pragma comment ...".
 struct PragmaCommentHandler : public PragmaHandler {
   PragmaCommentHandler(Sema &Actions)
-    : PragmaHandler("comment"), Actions(Actions) {}
+      : PragmaHandler("comment"), Actions(Actions) {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
                     Token &FirstToken) override;
 
@@ -189,7 +207,7 @@ private:
 
 struct PragmaDetectMismatchHandler : public PragmaHandler {
   PragmaDetectMismatchHandler(Sema &Actions)
-    : PragmaHandler("detect_mismatch"), Actions(Actions) {}
+      : PragmaHandler("detect_mismatch"), Actions(Actions) {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
                     Token &FirstToken) override;
 
@@ -198,8 +216,7 @@ private:
 };
 
 struct PragmaFloatControlHandler : public PragmaHandler {
-  PragmaFloatControlHandler(Sema &Actions)
-      : PragmaHandler("float_control") {}
+  PragmaFloatControlHandler(Sema &Actions) : PragmaHandler("float_control") {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
                     Token &FirstToken) override;
 };
@@ -224,8 +241,7 @@ struct PragmaMSPragma : public PragmaHan
 
 /// PragmaOptimizeHandler - "\#pragma clang optimize on/off".
 struct PragmaOptimizeHandler : public PragmaHandler {
-  PragmaOptimizeHandler(Sema &S)
-    : PragmaHandler("optimize"), Actions(S) {}
+  PragmaOptimizeHandler(Sema &S) : PragmaHandler("optimize"), Actions(S) {}
   void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
                     Token &FirstToken) override;
 
@@ -317,7 +333,7 @@ struct PragmaMSFenvAccessHandler : publi
     Toks[0].setLocation(FirstToken.getLocation());
     Toks[0].setAnnotationEndLoc(Tok.getLocation());
     Toks[0].setAnnotationValue(
-        reinterpret_cast<void*>(static_cast<uintptr_t>(OOS)));
+        reinterpret_cast<void *>(static_cast<uintptr_t>(OOS)));
     PP.EnterTokenStream(Toks, /*DisableMacroExpansion=*/true,
                         /*IsReinject=*/false);
   }
@@ -360,9 +376,13 @@ void markAsReinjectedForRelexing(llvm::M
   for (auto &T : Toks)
     T.setFlag(clang::Token::IsReinjected);
 }
-}  // end namespace
+} // end namespace
 
 void Parser::initializePragmaHandlers() {
+  // Modified By Zeng-WCh
+  LoopBoundHandler = std::make_unique<PragmaLoopBoundHandler>();
+  PP.AddPragmaHandler(LoopBoundHandler.get());
+  // End Modification
   AlignHandler = std::make_unique<PragmaAlignHandler>();
   PP.AddPragmaHandler(AlignHandler.get());
 
@@ -516,6 +536,11 @@ void Parser::resetPragmaHandlers() {
   PP.RemovePragmaHandler(RedefineExtnameHandler.get());
   RedefineExtnameHandler.reset();
 
+  // Modified By Zeng-WCh
+  PP.RemovePragmaHandler(LoopBoundHandler.get());
+  LoopBoundHandler.reset();
+  // End Modification
+
   if (getLangOpts().OpenCL) {
     PP.RemovePragmaHandler("OPENCL", OpenCLExtensionHandler.get());
     OpenCLExtensionHandler.reset();
@@ -632,11 +657,74 @@ void Parser::HandlePragmaUnused() {
 void Parser::HandlePragmaVisibility() {
   assert(Tok.is(tok::annot_pragma_vis));
   const IdentifierInfo *VisType =
-    static_cast<IdentifierInfo *>(Tok.getAnnotationValue());
+      static_cast<IdentifierInfo *>(Tok.getAnnotationValue());
   SourceLocation VisLoc = ConsumeAnnotationToken();
   Actions.ActOnPragmaVisibility(VisType, VisLoc);
 }
 
+// Modified by Zeng-WCh
+StmtResult Parser::HandlePragmaLoopBound(StmtVector &Stmts,
+                                         ParsedStmtContext StmtCtx,
+                                         SourceLocation *TrailingElseLoc) {
+  assert(Tok.is(tok::annot_loop_bound));
+  auto *Bound = reinterpret_cast<uint64_t *>(Tok.getAnnotationValue());
+  // uint64_t lower = Bound[0];
+  // uint64_t upper = Bound[1];
+  Tok.setAnnotationValue(nullptr);
+  // Consume the token after processing the pragma to enable pragma-specific
+  ConsumeAnnotationToken();
+  // delete[] Bound;
+
+  // We assume that following the pragma is a loop statement.
+  StmtResult LoopStmt =
+      ParseStatementOrDeclaration(Stmts, StmtCtx, TrailingElseLoc);
+  if (LoopStmt.isInvalid()) {
+    PP.Diag(Tok.getLocation(), diag::err_pragma_loop_invalid_option);
+  }
+
+  // Add comments to the loop statement
+  if (LoopStmt.isUsable()) {
+    // Get Loop Type
+    auto type = LoopStmt.get()->getStmtClass();
+    switch (type) {
+    case Stmt::ForStmtClass: {
+      // Type Casting
+      auto *For = cast<ForStmt>(LoopStmt.get());
+      // Add Loop attributes to the loop statement
+      For->setBound(Bound);
+      break;
+    }
+    case Stmt::WhileStmtClass: {
+      auto *While = cast<WhileStmt>(LoopStmt.get());
+      While->setBound(Bound);
+      break;
+    }
+    case Stmt::DoStmtClass: {
+      auto *Do = cast<DoStmt>(LoopStmt.get());
+      Do->setBound(Bound);
+      break;
+    }
+    default:
+      PP.Diag(Tok.getLocation(), diag::err_pragma_loop_invalid_option);
+    }
+    // llvm::outs() << "Loop Bound: " << Bound[0] << " " << Bound[1] << "\n";
+    // llvm::outs() << "Loop Stmt: " << LoopStmt.get()->getStmtClassName() <<
+    // "\n"; StmtResult SR = Actions.ActOnPragmaLoopBound(lower, upper,
+    //                                              LoopStmt.get()->getBeginLoc());
+    // Stmts.push_back(SR.get());
+
+    // Add Loop attributes to the loop statement
+    // LoopHintAttr *Attr = new LoopHintAttr()
+    // LoopStmt.get()->addAttr(Attr);
+    return LoopStmt;
+  } else {
+    PP.Diag(Tok.getLocation(), diag::err_pragma_loop_invalid_option)
+        << "loopbound";
+    return StmtEmpty();
+  }
+}
+// End Modification
+
 namespace {
 struct PragmaPackInfo {
   Sema::PragmaMsStackAction Action;
@@ -648,7 +736,7 @@ struct PragmaPackInfo {
 void Parser::HandlePragmaPack() {
   assert(Tok.is(tok::annot_pragma_pack));
   PragmaPackInfo *Info =
-    static_cast<PragmaPackInfo *>(Tok.getAnnotationValue());
+      static_cast<PragmaPackInfo *>(Tok.getAnnotationValue());
   SourceLocation PragmaLoc = Tok.getLocation();
   ExprResult Alignment;
   if (Info->Alignment.is(tok::numeric_constant)) {
@@ -675,9 +763,8 @@ void Parser::HandlePragmaMSStruct() {
 
 void Parser::HandlePragmaAlign() {
   assert(Tok.is(tok::annot_pragma_align));
-  Sema::PragmaOptionsAlignKind Kind =
-    static_cast<Sema::PragmaOptionsAlignKind>(
-    reinterpret_cast<uintptr_t>(Tok.getAnnotationValue()));
+  Sema::PragmaOptionsAlignKind Kind = static_cast<Sema::PragmaOptionsAlignKind>(
+      reinterpret_cast<uintptr_t>(Tok.getAnnotationValue()));
   Actions.ActOnPragmaOptionsAlign(Kind, Tok.getLocation());
   // Consume the token after processing the pragma to enable pragma-specific
   // #include warnings.
@@ -709,9 +796,8 @@ void Parser::HandlePragmaWeakAlias() {
   IdentifierInfo *AliasName = Tok.getIdentifierInfo();
   SourceLocation AliasNameLoc = Tok.getLocation();
   ConsumeToken();
-  Actions.ActOnPragmaWeakAlias(WeakName, AliasName, PragmaLoc,
-                               WeakNameLoc, AliasNameLoc);
-
+  Actions.ActOnPragmaWeakAlias(WeakName, AliasName, PragmaLoc, WeakNameLoc,
+                               AliasNameLoc);
 }
 
 void Parser::HandlePragmaRedefineExtname() {
@@ -729,9 +815,8 @@ void Parser::HandlePragmaRedefineExtname
 
 void Parser::HandlePragmaFPContract() {
   assert(Tok.is(tok::annot_pragma_fp_contract));
-  tok::OnOffSwitch OOS =
-    static_cast<tok::OnOffSwitch>(
-    reinterpret_cast<uintptr_t>(Tok.getAnnotationValue()));
+  tok::OnOffSwitch OOS = static_cast<tok::OnOffSwitch>(
+      reinterpret_cast<uintptr_t>(Tok.getAnnotationValue()));
 
   LangOptions::FPModeKind FPC;
   switch (OOS) {
@@ -769,9 +854,8 @@ void Parser::HandlePragmaFloatControl()
 void Parser::HandlePragmaFEnvAccess() {
   assert(Tok.is(tok::annot_pragma_fenv_access) ||
          Tok.is(tok::annot_pragma_fenv_access_ms));
-  tok::OnOffSwitch OOS =
-    static_cast<tok::OnOffSwitch>(
-    reinterpret_cast<uintptr_t>(Tok.getAnnotationValue()));
+  tok::OnOffSwitch OOS = static_cast<tok::OnOffSwitch>(
+      reinterpret_cast<uintptr_t>(Tok.getAnnotationValue()));
 
   bool IsEnabled;
   switch (OOS) {
@@ -799,8 +883,7 @@ void Parser::HandlePragmaFEnvRound() {
   Actions.setRoundingMode(PragmaLoc, RM);
 }
 
-StmtResult Parser::HandlePragmaCaptured()
-{
+StmtResult Parser::HandlePragmaCaptured() {
   assert(Tok.is(tok::annot_pragma_captured));
   ConsumeAnnotationToken();
 
@@ -828,15 +911,13 @@ StmtResult Parser::HandlePragmaCaptured(
 }
 
 namespace {
-  enum OpenCLExtState : char {
-    Disable, Enable, Begin, End
-  };
-  typedef std::pair<const IdentifierInfo *, OpenCLExtState> OpenCLExtData;
-}
+enum OpenCLExtState : char { Disable, Enable, Begin, End };
+typedef std::pair<const IdentifierInfo *, OpenCLExtState> OpenCLExtData;
+} // namespace
 
 void Parser::HandlePragmaOpenCLExtension() {
   assert(Tok.is(tok::annot_pragma_opencl_extension));
-  OpenCLExtData *Data = static_cast<OpenCLExtData*>(Tok.getAnnotationValue());
+  OpenCLExtData *Data = static_cast<OpenCLExtData *>(Tok.getAnnotationValue());
   auto State = Data->second;
   auto Ident = Data->first;
   SourceLocation NameLoc = Tok.getLocation();
@@ -907,12 +988,12 @@ void Parser::HandlePragmaMSPragma() {
   // because lex shouldn't emit the annotation token for unrecognized pragmas.
   typedef bool (Parser::*PragmaHandler)(StringRef, SourceLocation);
   PragmaHandler Handler = llvm::StringSwitch<PragmaHandler>(PragmaName)
-    .Case("data_seg", &Parser::HandlePragmaMSSegment)
-    .Case("bss_seg", &Parser::HandlePragmaMSSegment)
-    .Case("const_seg", &Parser::HandlePragmaMSSegment)
-    .Case("code_seg", &Parser::HandlePragmaMSSegment)
-    .Case("section", &Parser::HandlePragmaMSSection)
-    .Case("init_seg", &Parser::HandlePragmaMSInitSeg);
+                              .Case("data_seg", &Parser::HandlePragmaMSSegment)
+                              .Case("bss_seg", &Parser::HandlePragmaMSSegment)
+                              .Case("const_seg", &Parser::HandlePragmaMSSegment)
+                              .Case("code_seg", &Parser::HandlePragmaMSSegment)
+                              .Case("section", &Parser::HandlePragmaMSSection)
+                              .Case("init_seg", &Parser::HandlePragmaMSInitSeg);
 
   if (!(this->*Handler)(PragmaName, PragmaLocation)) {
     // Pragma handling failed, and has been diagnosed.  Slurp up the tokens
@@ -963,17 +1044,17 @@ bool Parser::HandlePragmaMSSection(Strin
       return false;
     }
     ASTContext::PragmaSectionFlag Flag =
-      llvm::StringSwitch<ASTContext::PragmaSectionFlag>(
-      Tok.getIdentifierInfo()->getName())
-      .Case("read", ASTContext::PSF_Read)
-      .Case("write", ASTContext::PSF_Write)
-      .Case("execute", ASTContext::PSF_Execute)
-      .Case("shared", ASTContext::PSF_Invalid)
-      .Case("nopage", ASTContext::PSF_Invalid)
-      .Case("nocache", ASTContext::PSF_Invalid)
-      .Case("discard", ASTContext::PSF_Invalid)
-      .Case("remove", ASTContext::PSF_Invalid)
-      .Default(ASTContext::PSF_None);
+        llvm::StringSwitch<ASTContext::PragmaSectionFlag>(
+            Tok.getIdentifierInfo()->getName())
+            .Case("read", ASTContext::PSF_Read)
+            .Case("write", ASTContext::PSF_Write)
+            .Case("execute", ASTContext::PSF_Execute)
+            .Case("shared", ASTContext::PSF_Invalid)
+            .Case("nopage", ASTContext::PSF_Invalid)
+            .Case("nocache", ASTContext::PSF_Invalid)
+            .Case("discard", ASTContext::PSF_Invalid)
+            .Case("remove", ASTContext::PSF_Invalid)
+            .Default(ASTContext::PSF_None);
     if (Flag == ASTContext::PSF_None || Flag == ASTContext::PSF_Invalid) {
       PP.Diag(PragmaLocation, Flag == ASTContext::PSF_None
                                   ? diag::warn_pragma_invalid_specific_action
@@ -1051,10 +1132,12 @@ bool Parser::HandlePragmaMSSegment(Strin
   StringLiteral *SegmentName = nullptr;
   if (Tok.isNot(tok::r_paren)) {
     if (Tok.isNot(tok::string_literal)) {
-      unsigned DiagID = Action != Sema::PSK_Reset ? !SlotLabel.empty() ?
-          diag::warn_pragma_expected_section_name :
-          diag::warn_pragma_expected_section_label_or_name :
-          diag::warn_pragma_expected_section_push_pop_or_name;
+      unsigned DiagID =
+          Action != Sema::PSK_Reset
+              ? !SlotLabel.empty()
+                    ? diag::warn_pragma_expected_section_name
+                    : diag::warn_pragma_expected_section_label_or_name
+              : diag::warn_pragma_expected_section_push_pop_or_name;
       PP.Diag(PragmaLocation, DiagID) << PragmaName;
       return false;
     }
@@ -1082,8 +1165,8 @@ bool Parser::HandlePragmaMSSegment(Strin
     return false;
   }
   PP.Lex(Tok); // eof
-  Actions.ActOnPragmaMSSeg(PragmaLocation, Action, SlotLabel,
-                           SegmentName, PragmaName);
+  Actions.ActOnPragmaMSSeg(PragmaLocation, Action, SlotLabel, SegmentName,
+                           PragmaName);
   return true;
 }
 
@@ -1242,13 +1325,13 @@ bool Parser::HandlePragmaLoopHint(LoopHi
     SourceLocation StateLoc = Toks[0].getLocation();
     IdentifierInfo *StateInfo = Toks[0].getIdentifierInfo();
 
-    bool Valid = StateInfo &&
-                 llvm::StringSwitch<bool>(StateInfo->getName())
-                     .Case("disable", true)
-                     .Case("enable", !OptionPipelineDisabled)
-                     .Case("full", OptionUnroll || OptionUnrollAndJam)
-                     .Case("assume_safety", AssumeSafetyArg)
-                     .Default(false);
+    bool Valid =
+        StateInfo && llvm::StringSwitch<bool>(StateInfo->getName())
+                         .Case("disable", true)
+                         .Case("enable", !OptionPipelineDisabled)
+                         .Case("full", OptionUnroll || OptionUnrollAndJam)
+                         .Case("assume_safety", AssumeSafetyArg)
+                         .Default(false);
     if (!Valid) {
       if (OptionPipelineDisabled) {
         Diag(Toks[0].getLocation(), diag::err_pragma_pipeline_invalid_keyword);
@@ -1820,32 +1903,32 @@ void PragmaGCCVisibilityHandler::HandleP
     PP.LexUnexpandedToken(Tok);
     if (Tok.isNot(tok::l_paren)) {
       PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_lparen)
-        << "visibility";
+          << "visibility";
       return;
     }
     PP.LexUnexpandedToken(Tok);
     VisType = Tok.getIdentifierInfo();
     if (!VisType) {
       PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
-        << "visibility";
+          << "visibility";
       return;
     }
     PP.LexUnexpandedToken(Tok);
     if (Tok.isNot(tok::r_paren)) {
       PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_rparen)
-        << "visibility";
+          << "visibility";
       return;
     }
   } else {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
-      << "visibility";
+        << "visibility";
     return;
   }
   SourceLocation EndLoc = Tok.getLocation();
   PP.LexUnexpandedToken(Tok);
   if (Tok.isNot(tok::eod)) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol)
-      << "visibility";
+        << "visibility";
     return;
   }
 
@@ -1972,7 +2055,7 @@ void PragmaPackHandler::HandlePragma(Pre
   Toks[0].setKind(tok::annot_pragma_pack);
   Toks[0].setLocation(PackLoc);
   Toks[0].setAnnotationEndLoc(RParenLoc);
-  Toks[0].setAnnotationValue(static_cast<void*>(Info));
+  Toks[0].setAnnotationValue(static_cast<void *>(Info));
   PP.EnterTokenStream(Toks, /*DisableMacroExpansion=*/true,
                       /*IsReinject=*/false);
 }
@@ -1995,8 +2078,7 @@ void PragmaMSStructHandler::HandlePragma
   if (II->isStr("on")) {
     Kind = PMSST_ON;
     PP.Lex(Tok);
-  }
-  else if (II->isStr("off") || II->isStr("reset"))
+  } else if (II->isStr("off") || II->isStr("reset"))
     PP.Lex(Tok);
   else {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_ms_struct);
@@ -2005,7 +2087,7 @@ void PragmaMSStructHandler::HandlePragma
 
   if (Tok.isNot(tok::eod)) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol)
-      << "ms_struct";
+        << "ms_struct";
     return;
   }
 
@@ -2015,8 +2097,8 @@ void PragmaMSStructHandler::HandlePragma
   Toks[0].setKind(tok::annot_pragma_msstruct);
   Toks[0].setLocation(MSStructTok.getLocation());
   Toks[0].setAnnotationEndLoc(EndLoc);
-  Toks[0].setAnnotationValue(reinterpret_cast<void*>(
-                             static_cast<uintptr_t>(Kind)));
+  Toks[0].setAnnotationValue(
+      reinterpret_cast<void *>(static_cast<uintptr_t>(Kind)));
   PP.EnterTokenStream(Toks, /*DisableMacroExpansion=*/true,
                       /*IsReinject=*/false);
 }
@@ -2032,7 +2114,8 @@ void PragmaClangSectionHandler::HandlePr
   PP.Lex(Tok); // eat 'section'
   while (Tok.isNot(tok::eod)) {
     if (Tok.isNot(tok::identifier)) {
-      PP.Diag(Tok.getLocation(), diag::err_pragma_expected_clang_section_name) << "clang section";
+      PP.Diag(Tok.getLocation(), diag::err_pragma_expected_clang_section_name)
+          << "clang section";
       return;
     }
 
@@ -2048,14 +2131,16 @@ void PragmaClangSectionHandler::HandlePr
     else if (SecType->isStr("text"))
       SecKind = Sema::PragmaClangSectionKind::PCSK_Text;
     else {
-      PP.Diag(Tok.getLocation(), diag::err_pragma_expected_clang_section_name) << "clang section";
+      PP.Diag(Tok.getLocation(), diag::err_pragma_expected_clang_section_name)
+          << "clang section";
       return;
     }
 
     SourceLocation PragmaLocation = Tok.getLocation();
     PP.Lex(Tok); // eat ['bss'|'data'|'rodata'|'text']
     if (Tok.isNot(tok::equal)) {
-      PP.Diag(Tok.getLocation(), diag::err_pragma_clang_section_expected_equal) << SecKind;
+      PP.Diag(Tok.getLocation(), diag::err_pragma_clang_section_expected_equal)
+          << SecKind;
       return;
     }
 
@@ -2095,14 +2180,14 @@ static void ParseAlignPragma(Preprocesso
     }
   } else if (Tok.isNot(tok::equal)) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_align_expected_equal)
-      << IsOptions;
+        << IsOptions;
     return;
   }
 
   PP.Lex(Tok);
   if (Tok.isNot(tok::identifier)) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
-      << (IsOptions ? "options" : "align");
+        << (IsOptions ? "options" : "align");
     return;
   }
 
@@ -2122,7 +2207,7 @@ static void ParseAlignPragma(Preprocesso
     Kind = Sema::POAK_Reset;
   else {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_align_invalid_option)
-      << IsOptions;
+        << IsOptions;
     return;
   }
 
@@ -2138,7 +2223,7 @@ static void ParseAlignPragma(Preprocesso
   PP.Lex(Tok);
   if (Tok.isNot(tok::eod)) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol)
-      << (IsOptions ? "options" : "align");
+        << (IsOptions ? "options" : "align");
     return;
   }
 
@@ -2148,8 +2233,8 @@ static void ParseAlignPragma(Preprocesso
   Toks[0].setKind(tok::annot_pragma_align);
   Toks[0].setLocation(FirstTok.getLocation());
   Toks[0].setAnnotationEndLoc(EndLoc);
-  Toks[0].setAnnotationValue(reinterpret_cast<void*>(
-                             static_cast<uintptr_t>(Kind)));
+  Toks[0].setAnnotationValue(
+      reinterpret_cast<void *>(static_cast<uintptr_t>(Kind)));
   PP.EnterTokenStream(Toks, /*DisableMacroExpansion=*/true,
                       /*IsReinject=*/false);
 }
@@ -2219,8 +2304,8 @@ void PragmaUnusedHandler::HandlePragma(P
 
   PP.Lex(Tok);
   if (Tok.isNot(tok::eod)) {
-    PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol) <<
-        "unused";
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol)
+        << "unused";
     return;
   }
 
@@ -2236,8 +2321,8 @@ void PragmaUnusedHandler::HandlePragma(P
   MutableArrayRef<Token> Toks(
       PP.getPreprocessorAllocator().Allocate<Token>(2 * Identifiers.size()),
       2 * Identifiers.size());
-  for (unsigned i=0; i != Identifiers.size(); i++) {
-    Token &pragmaUnusedTok = Toks[2*i], &idTok = Toks[2*i+1];
+  for (unsigned i = 0; i != Identifiers.size(); i++) {
+    Token &pragmaUnusedTok = Toks[2 * i], &idTok = Toks[2 * i + 1];
     pragmaUnusedTok.startToken();
     pragmaUnusedTok.setKind(tok::annot_pragma_unused);
     pragmaUnusedTok.setLocation(UnusedLoc);
@@ -2318,8 +2403,8 @@ void PragmaRedefineExtnameHandler::Handl
   Token Tok;
   PP.Lex(Tok);
   if (Tok.isNot(tok::identifier)) {
-    PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier) <<
-      "redefine_extname";
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
+        << "redefine_extname";
     return;
   }
 
@@ -2336,8 +2421,8 @@ void PragmaRedefineExtnameHandler::Handl
   PP.Lex(Tok);
 
   if (Tok.isNot(tok::eod)) {
-    PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol) <<
-      "redefine_extname";
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol)
+        << "redefine_extname";
     return;
   }
 
@@ -2367,8 +2452,8 @@ void PragmaFPContractHandler::HandlePrag
   Toks[0].setKind(tok::annot_pragma_fp_contract);
   Toks[0].setLocation(Tok.getLocation());
   Toks[0].setAnnotationEndLoc(Tok.getLocation());
-  Toks[0].setAnnotationValue(reinterpret_cast<void*>(
-                             static_cast<uintptr_t>(OOS)));
+  Toks[0].setAnnotationValue(
+      reinterpret_cast<void *>(static_cast<uintptr_t>(OOS)));
   PP.EnterTokenStream(Toks, /*DisableMacroExpansion=*/true,
                       /*IsReinject=*/false);
 }
@@ -2378,8 +2463,8 @@ void PragmaOpenCLExtensionHandler::Handl
                                                 Token &Tok) {
   PP.LexUnexpandedToken(Tok);
   if (Tok.isNot(tok::identifier)) {
-    PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier) <<
-      "OPENCL";
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
+        << "OPENCL";
     return;
   }
   IdentifierInfo *Ext = Tok.getIdentifierInfo();
@@ -2409,15 +2494,15 @@ void PragmaOpenCLExtensionHandler::Handl
     State = End;
   else {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_predicate)
-      << Ext->isStr("all");
+        << Ext->isStr("all");
     return;
   }
   SourceLocation StateLoc = Tok.getLocation();
 
   PP.Lex(Tok);
   if (Tok.isNot(tok::eod)) {
-    PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol) <<
-      "OPENCL EXTENSION";
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol)
+        << "OPENCL EXTENSION";
     return;
   }
 
@@ -2429,14 +2514,13 @@ void PragmaOpenCLExtensionHandler::Handl
   Toks[0].startToken();
   Toks[0].setKind(tok::annot_pragma_opencl_extension);
   Toks[0].setLocation(NameLoc);
-  Toks[0].setAnnotationValue(static_cast<void*>(Info));
+  Toks[0].setAnnotationValue(static_cast<void *>(Info));
   Toks[0].setAnnotationEndLoc(StateLoc);
   PP.EnterTokenStream(Toks, /*DisableMacroExpansion=*/true,
                       /*IsReinject=*/false);
 
   if (PP.getPPCallbacks())
-    PP.getPPCallbacks()->PragmaOpenCLExtension(NameLoc, Ext,
-                                               StateLoc, State);
+    PP.getPPCallbacks()->PragmaOpenCLExtension(NameLoc, Ext, StateLoc, State);
 }
 
 /// Handle '#pragma omp ...' when OpenMP is disabled.
@@ -2507,14 +2591,14 @@ void PragmaMSPointersToMembers::HandlePr
   PP.Lex(Tok);
   if (Tok.isNot(tok::l_paren)) {
     PP.Diag(PointersToMembersLoc, diag::warn_pragma_expected_lparen)
-      << "pointers_to_members";
+        << "pointers_to_members";
     return;
   }
   PP.Lex(Tok);
   const IdentifierInfo *Arg = Tok.getIdentifierInfo();
   if (!Arg) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
-      << "pointers_to_members";
+        << "pointers_to_members";
     return;
   }
   PP.Lex(Tok);
@@ -2539,7 +2623,8 @@ void PragmaMSPointersToMembers::HandlePr
         // #pragma pointers_to_members(full_generality) implicitly specifies
         // virtual_inheritance.
         Arg = nullptr;
-        RepresentationMethod = LangOptions::PPTMK_FullGeneralityVirtualInheritance;
+        RepresentationMethod =
+            LangOptions::PPTMK_FullGeneralityVirtualInheritance;
       } else {
         PP.Diag(Tok.getLocation(), diag::err_expected_punc)
             << "full_generality";
@@ -2576,7 +2661,7 @@ void PragmaMSPointersToMembers::HandlePr
   PP.Lex(Tok);
   if (Tok.isNot(tok::eod)) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_extra_tokens_at_eol)
-      << "pointers_to_members";
+        << "pointers_to_members";
     return;
   }
 
@@ -2634,7 +2719,6 @@ void PragmaMSVtorDisp::HandlePragma(Prep
     }
   }
 
-
   uint64_t Value = 0;
   if (Action & Sema::PSK_Push || Action & Sema::PSK_Set) {
     const IdentifierInfo *II = Tok.getIdentifierInfo();
@@ -2684,8 +2768,8 @@ void PragmaMSVtorDisp::HandlePragma(Prep
 
 /// Handle all MS pragmas.  Simply forwards the tokens after inserting
 /// an annotation token.
-void PragmaMSPragma::HandlePragma(Preprocessor &PP,
-                                  PragmaIntroducer Introducer, Token &Tok) {
+void PragmaMSPragma::HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,
+                                  Token &Tok) {
   Token EoF, AnnotTok;
   EoF.startToken();
   EoF.setKind(tok::eof);
@@ -2864,8 +2948,7 @@ void PragmaDetectMismatchHandler::Handle
 
   // Read the name to embed, which must be a string literal.
   std::string NameString;
-  if (!PP.LexStringLiteral(Tok, NameString,
-                           "pragma detect_mismatch",
+  if (!PP.LexStringLiteral(Tok, NameString, "pragma detect_mismatch",
                            /*AllowMacroExpansion=*/true))
     return;
 
@@ -2884,7 +2967,7 @@ void PragmaDetectMismatchHandler::Handle
     PP.Diag(Tok.getLocation(), diag::err_expected) << tok::r_paren;
     return;
   }
-  PP.Lex(Tok);  // Eat the r_paren.
+  PP.Lex(Tok); // Eat the r_paren.
 
   if (Tok.isNot(tok::eod)) {
     PP.Diag(Tok.getLocation(), diag::err_pragma_detect_mismatch_malformed);
@@ -2928,13 +3011,13 @@ void PragmaCommentHandler::HandlePragma(
   // Verify that this is one of the 5 explicitly listed options.
   IdentifierInfo *II = Tok.getIdentifierInfo();
   PragmaMSCommentKind Kind =
-    llvm::StringSwitch<PragmaMSCommentKind>(II->getName())
-    .Case("linker",   PCK_Linker)
-    .Case("lib",      PCK_Lib)
-    .Case("compiler", PCK_Compiler)
-    .Case("exestr",   PCK_ExeStr)
-    .Case("user",     PCK_User)
-    .Default(PCK_Unknown);
+      llvm::StringSwitch<PragmaMSCommentKind>(II->getName())
+          .Case("linker", PCK_Linker)
+          .Case("lib", PCK_Lib)
+          .Case("compiler", PCK_Compiler)
+          .Case("exestr", PCK_ExeStr)
+          .Case("user", PCK_User)
+          .Default(PCK_Unknown);
   if (Kind == PCK_Unknown) {
     PP.Diag(Tok.getLocation(), diag::err_pragma_comment_unknown_kind);
     return;
@@ -2950,16 +3033,16 @@ void PragmaCommentHandler::HandlePragma(
   // #pragma comment lib.
   if (PP.getTargetInfo().getTriple().isPS4() && Kind != PCK_Lib) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_comment_ignored)
-      << II->getName();
+        << II->getName();
     return;
   }
 
   // Read the optional string if present.
   PP.Lex(Tok);
   std::string ArgumentString;
-  if (Tok.is(tok::comma) && !PP.LexStringLiteral(Tok, ArgumentString,
-                                                 "pragma comment",
-                                                 /*AllowMacroExpansion=*/true))
+  if (Tok.is(tok::comma) &&
+      !PP.LexStringLiteral(Tok, ArgumentString, "pragma comment",
+                           /*AllowMacroExpansion=*/true))
     return;
 
   // FIXME: warn that 'exestr' is deprecated.
@@ -2973,7 +3056,7 @@ void PragmaCommentHandler::HandlePragma(
     PP.Diag(Tok.getLocation(), diag::err_pragma_comment_malformed);
     return;
   }
-  PP.Lex(Tok);  // eat the r_paren.
+  PP.Lex(Tok); // eat the r_paren.
 
   if (Tok.isNot(tok::eod)) {
     PP.Diag(Tok.getLocation(), diag::err_pragma_comment_malformed);
@@ -3001,7 +3084,7 @@ void PragmaOptimizeHandler::HandlePragma
   }
   if (Tok.isNot(tok::identifier)) {
     PP.Diag(Tok.getLocation(), diag::err_pragma_optimize_invalid_argument)
-      << PP.getSpelling(Tok);
+        << PP.getSpelling(Tok);
     return;
   }
   const IdentifierInfo *II = Tok.getIdentifierInfo();
@@ -3011,14 +3094,14 @@ void PragmaOptimizeHandler::HandlePragma
     IsOn = true;
   } else if (!II->isStr("off")) {
     PP.Diag(Tok.getLocation(), diag::err_pragma_optimize_invalid_argument)
-      << PP.getSpelling(Tok);
+        << PP.getSpelling(Tok);
     return;
   }
   PP.Lex(Tok);
 
   if (Tok.isNot(tok::eod)) {
     PP.Diag(Tok.getLocation(), diag::err_pragma_optimize_extra_argument)
-      << PP.getSpelling(Tok);
+        << PP.getSpelling(Tok);
     return;
   }
 
@@ -3569,8 +3652,9 @@ void PragmaMSOptimizeHandler::HandlePrag
   PP.Diag(StartLoc, diag::warn_pragma_optimize);
 }
 
-void PragmaForceCUDAHostDeviceHandler::HandlePragma(
-    Preprocessor &PP, PragmaIntroducer Introducer, Token &Tok) {
+void PragmaForceCUDAHostDeviceHandler::HandlePragma(Preprocessor &PP,
+                                                    PragmaIntroducer Introducer,
+                                                    Token &Tok) {
   Token FirstTok = Tok;
 
   PP.Lex(Tok);
@@ -3798,3 +3882,92 @@ void PragmaMaxTokensTotalHandler::Handle
 
   PP.overrideMaxTokens(MaxTokens, Loc);
 }
+
+// Modified By Zeng-WCh
+/// This is a pragma for loop annotation
+/// use like this:
+/// \code
+/// #pragma loopbound min 10 max 10
+/// for (int i = 0; i < 10; i++) {
+///  // do something
+/// }
+/// \endcode
+/// But note that this pragma do not constrain the actual loop
+/// bound, only for annotation.
+/// So that actual code can be run with different loop bound
+void PragmaLoopBoundHandler::HandlePragma(Preprocessor &PP,
+                                          PragmaIntroducer Introducer,
+                                          Token &FirstToken) {
+  // SourceLocation loc = FirstToken.getLocation();
+  // auto lineno = PP.getSourceManager().getExpansionLineNumber(loc);
+  uint64_t lower = 0, upper = 0;
+
+  Token Tok;
+  bool is_max = false;
+
+  PP.Lex(Tok);
+
+  while (Tok.isNot(tok::eod)) {
+    // Print the token literal.
+    // llvm::outs() << PP.getSpelling(Tok) << "\n";
+    if (Tok.isNot(tok::identifier)) {
+      PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
+          << "loopbound min/max";
+    }
+    StringRef kind = Tok.getIdentifierInfo()->getName();
+    if (kind == "min") {
+      is_max = false;
+    } else if (kind == "max") {
+      is_max = true;
+    } else {
+      PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
+          << "loopbound min/max";
+    }
+    PP.Lex(Tok);
+    // llvm::outs() << PP.getSpelling(Tok) << "\n";
+    if (Tok.isNot(tok::numeric_constant)) {
+      PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_identifier)
+          << "loopbound min/max";
+      return;
+    }
+    uint64_t value;
+    if (!PP.parseSimpleIntegerLiteral(Tok, value)) {
+      PP.Diag(Tok.getLocation(), diag::warn_pragma_expected_integer)
+          << "loopbound min/max";
+      return;
+    }
+    if (is_max) {
+      upper = value;
+    } else {
+      lower = value;
+    }
+  }
+
+  if (lower > upper) {
+    std::swap(lower, upper);
+  }
+
+  // llvm::outs() << "LineNo: " << lineno << ", Lower: " << lower
+  //              << ", Upper: " << upper << "\n";
+  // reset the token, which will be used
+  Tok.startToken();
+  Tok.setKind(tok::annot_loop_bound);
+
+  // [0] is min, [1] is max
+  uint64_t *bound = new uint64_t[2];
+  bound[0] = lower;
+  bound[1] = upper;
+
+  Tok.setAnnotationValue((void *)bound);
+  Tok.setLocation(FirstToken.getLocation());
+  Tok.setAnnotationEndLoc(FirstToken.getLocation());
+  // PP.EnterToken(Tok, false);
+  // auto TokenArray = std::make_unique<Token[]>(1);
+  // TokenArray[0] = Tok;
+
+  // PP.EnterTokenStream(std::move(TokenArray), 1,
+  //                     /*DisableMacroExpansion=*/false, /*IsReinject=*/false);
+  PP.EnterToken(Tok, false);
+  // Tok.setKind(tok::annot_attr_pragma);
+}
+// End of Modification
\ No newline at end of file
diff --color -uprN clang-14.0.6.src/lib/Parse/ParseStmt.cpp clang-14.0.6.src.patched/lib/Parse/ParseStmt.cpp
--- clang-14.0.6.src/lib/Parse/ParseStmt.cpp	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/lib/Parse/ParseStmt.cpp	2024-11-12 13:24:23.357485188 +0800
@@ -154,7 +154,7 @@ public:
 private:
   Token NextToken;
 };
-}
+} // namespace
 
 StmtResult Parser::ParseStatementOrDeclarationAfterAttributes(
     StmtVector &Stmts, ParsedStmtContext StmtCtx,
@@ -167,14 +167,14 @@ StmtResult Parser::ParseStatementOrDecla
   // the token to end in a semicolon (in which case SemiError should be set),
   // or they directly 'return;' if not.
 Retry:
-  tok::TokenKind Kind  = Tok.getKind();
+  tok::TokenKind Kind = Tok.getKind();
   SourceLocation AtLoc;
   switch (Kind) {
   case tok::at: // May be a @try or @throw statement
-    {
-      AtLoc = ConsumeToken();  // consume @
-      return ParseObjCAtStatement(AtLoc, StmtCtx);
-    }
+  {
+    AtLoc = ConsumeToken(); // consume @
+    return ParseObjCAtStatement(AtLoc, StmtCtx);
+  }
 
   case tok::code_completion:
     cutOffParsing();
@@ -249,49 +249,49 @@ Retry:
     goto Retry;
   }
 
-  case tok::kw_case:                // C99 6.8.1: labeled-statement
+  case tok::kw_case: // C99 6.8.1: labeled-statement
     return ParseCaseStatement(StmtCtx);
-  case tok::kw_default:             // C99 6.8.1: labeled-statement
+  case tok::kw_default: // C99 6.8.1: labeled-statement
     return ParseDefaultStatement(StmtCtx);
 
-  case tok::l_brace:                // C99 6.8.2: compound-statement
+  case tok::l_brace: // C99 6.8.2: compound-statement
     return ParseCompoundStatement();
-  case tok::semi: {                 // C99 6.8.3p3: expression[opt] ';'
+  case tok::semi: { // C99 6.8.3p3: expression[opt] ';'
     bool HasLeadingEmptyMacro = Tok.hasLeadingEmptyMacro();
     return Actions.ActOnNullStmt(ConsumeToken(), HasLeadingEmptyMacro);
   }
 
-  case tok::kw_if:                  // C99 6.8.4.1: if-statement
+  case tok::kw_if: // C99 6.8.4.1: if-statement
     return ParseIfStatement(TrailingElseLoc);
-  case tok::kw_switch:              // C99 6.8.4.2: switch-statement
+  case tok::kw_switch: // C99 6.8.4.2: switch-statement
     return ParseSwitchStatement(TrailingElseLoc);
 
-  case tok::kw_while:               // C99 6.8.5.1: while-statement
+  case tok::kw_while: // C99 6.8.5.1: while-statement
     return ParseWhileStatement(TrailingElseLoc);
-  case tok::kw_do:                  // C99 6.8.5.2: do-statement
+  case tok::kw_do: // C99 6.8.5.2: do-statement
     Res = ParseDoStatement();
     SemiError = "do/while";
     break;
-  case tok::kw_for:                 // C99 6.8.5.3: for-statement
+  case tok::kw_for: // C99 6.8.5.3: for-statement
     return ParseForStatement(TrailingElseLoc);
 
-  case tok::kw_goto:                // C99 6.8.6.1: goto-statement
+  case tok::kw_goto: // C99 6.8.6.1: goto-statement
     Res = ParseGotoStatement();
     SemiError = "goto";
     break;
-  case tok::kw_continue:            // C99 6.8.6.2: continue-statement
+  case tok::kw_continue: // C99 6.8.6.2: continue-statement
     Res = ParseContinueStatement();
     SemiError = "continue";
     break;
-  case tok::kw_break:               // C99 6.8.6.3: break-statement
+  case tok::kw_break: // C99 6.8.6.3: break-statement
     Res = ParseBreakStatement();
     SemiError = "break";
     break;
-  case tok::kw_return:              // C99 6.8.6.4: return-statement
+  case tok::kw_return: // C99 6.8.6.4: return-statement
     Res = ParseReturnStatement();
     SemiError = "return";
     break;
-  case tok::kw_co_return:            // C++ Coroutines: co_return statement
+  case tok::kw_co_return: // C++ Coroutines: co_return statement
     Res = ParseReturnStatement();
     SemiError = "co_return";
     break;
@@ -301,7 +301,8 @@ Retry:
     bool msAsm = false;
     Res = ParseAsmStatement(msAsm);
     Res = Actions.ActOnFinishFullStmt(Res.get());
-    if (msAsm) return Res;
+    if (msAsm)
+      return Res;
     SemiError = "asm";
     break;
   }
@@ -314,7 +315,7 @@ Retry:
     // a new scope.
     return StmtEmpty();
 
-  case tok::kw_try:                 // C++ 15: try-block
+  case tok::kw_try: // C++ 15: try-block
     return ParseCXXTryBlock();
 
   case tok::kw___try:
@@ -326,6 +327,13 @@ Retry:
     SemiError = "__leave";
     break;
 
+    // Modified By Zeng-WCh
+  case tok::annot_loop_bound: {
+    ProhibitAttributes(Attrs);
+    return HandlePragmaLoopBound(Stmts, StmtCtx, TrailingElseLoc);
+  }
+    // End of Modification
+
   case tok::annot_pragma_vis:
     ProhibitAttributes(Attrs);
     HandlePragmaVisibility();
@@ -378,7 +386,7 @@ Retry:
     ProhibitAttributes(Attrs);
     Diag(Tok, diag::err_pragma_file_or_compound_scope)
         << (Kind == tok::annot_pragma_fenv_access ? "STDC FENV_ACCESS"
-                                                    : "fenv_access");
+                                                  : "fenv_access");
     ConsumeAnnotationToken();
     return StmtEmpty();
 
@@ -477,7 +485,7 @@ StmtResult Parser::ParseExprStatement(Pa
     // If a constant expression is followed by a colon inside a switch block,
     // suggest a missing case keyword.
     Diag(OldToken, diag::err_expected_case_before_expression)
-      << FixItHint::CreateInsertion(OldToken.getLocation(), "case ");
+        << FixItHint::CreateInsertion(OldToken.getLocation(), "case ");
 
     // Recover parsing as a case statement.
     return ParseCaseStatement(StmtCtx, /*MissingCase=*/true, Expr);
@@ -522,12 +530,10 @@ StmtResult Parser::ParseSEHTryBlock() {
     return StmtError(Diag(Tok, diag::err_seh_expected_handler));
   }
 
-  if(Handler.isInvalid())
+  if (Handler.isInvalid())
     return Handler;
 
-  return Actions.ActOnSEHTryBlock(false /* IsCXXTry */,
-                                  TryLoc,
-                                  TryBlock.get(),
+  return Actions.ActOnSEHTryBlock(false /* IsCXXTry */, TryLoc, TryBlock.get(),
                                   Handler.get());
 }
 
@@ -538,8 +544,8 @@ StmtResult Parser::ParseSEHTryBlock() {
 ///
 StmtResult Parser::ParseSEHExceptBlock(SourceLocation ExceptLoc) {
   PoisonIdentifierRAIIObject raii(Ident__exception_code, false),
-    raii2(Ident___exception_code, false),
-    raii3(Ident_GetExceptionCode, false);
+      raii2(Ident___exception_code, false),
+      raii3(Ident_GetExceptionCode, false);
 
   if (ExpectAndConsume(tok::l_paren))
     return StmtError();
@@ -566,7 +572,7 @@ StmtResult Parser::ParseSEHExceptBlock(S
     Ident_GetExceptionInfo->setIsPoisoned(true);
   }
 
-  if(FilterExpr.isInvalid())
+  if (FilterExpr.isInvalid())
     return StmtError();
 
   if (ExpectAndConsume(tok::r_paren))
@@ -577,7 +583,7 @@ StmtResult Parser::ParseSEHExceptBlock(S
 
   StmtResult Block(ParseCompoundStatement());
 
-  if(Block.isInvalid())
+  if (Block.isInvalid())
     return Block;
 
   return Actions.ActOnSEHExceptBlock(ExceptLoc, FilterExpr.get(), Block.get());
@@ -590,8 +596,8 @@ StmtResult Parser::ParseSEHExceptBlock(S
 ///
 StmtResult Parser::ParseSEHFinallyBlock(SourceLocation FinallyLoc) {
   PoisonIdentifierRAIIObject raii(Ident__abnormal_termination, false),
-    raii2(Ident___abnormal_termination, false),
-    raii3(Ident_AbnormalTermination, false);
+      raii2(Ident___abnormal_termination, false),
+      raii3(Ident_AbnormalTermination, false);
 
   if (Tok.isNot(tok::l_brace))
     return StmtError(Diag(Tok, diag::err_expected) << tok::l_brace);
@@ -600,7 +606,7 @@ StmtResult Parser::ParseSEHFinallyBlock(
   Actions.ActOnStartSEHFinallyBlock();
 
   StmtResult Block(ParseCompoundStatement());
-  if(Block.isInvalid()) {
+  if (Block.isInvalid()) {
     Actions.ActOnAbortSEHFinallyBlock();
     return Block;
   }
@@ -614,7 +620,7 @@ StmtResult Parser::ParseSEHFinallyBlock(
 ///   '__leave' ';'
 ///
 StmtResult Parser::ParseSEHLeaveStatement() {
-  SourceLocation LeaveLoc = ConsumeToken();  // eat the '__leave'.
+  SourceLocation LeaveLoc = ConsumeToken(); // eat the '__leave'.
   return Actions.ActOnSEHLeaveStmt(LeaveLoc, getCurScope());
 }
 
@@ -633,8 +639,8 @@ StmtResult Parser::ParseLabeledStatement
   // otherwise in the same context as the labeled-statement.
   StmtCtx &= ~ParsedStmtContext::AllowDeclarationsInC;
 
-  Token IdentTok = Tok;  // Save the whole token.
-  ConsumeToken();  // eat the identifier.
+  Token IdentTok = Tok; // Save the whole token.
+  ConsumeToken();       // eat the identifier.
 
   assert(Tok.is(tok::colon) && "Not a label!");
 
@@ -721,8 +727,8 @@ StmtResult Parser::ParseCaseStatement(Pa
   // While we have case statements, eat and stack them.
   SourceLocation ColonLoc;
   do {
-    SourceLocation CaseLoc = MissingCase ? Expr.get()->getExprLoc() :
-                                           ConsumeToken();  // eat the 'case'.
+    SourceLocation CaseLoc = MissingCase ? Expr.get()->getExprLoc()
+                                         : ConsumeToken(); // eat the 'case'.
     ColonLoc = SourceLocation();
 
     if (Tok.is(tok::code_completion)) {
@@ -785,7 +791,7 @@ StmtResult Parser::ParseCaseStatement(Pa
     // If we had a sema error parsing this case, then just ignore it and
     // continue parsing the sub-stmt.
     if (Case.isInvalid()) {
-      if (TopLevelCase.isInvalid())  // No parsed case stmts.
+      if (TopLevelCase.isInvalid()) // No parsed case stmts.
         return ParseStatement(/*TrailingElseLoc=*/nullptr, StmtCtx);
       // Otherwise, just don't add it as a nested case.
     } else {
@@ -814,7 +820,7 @@ StmtResult Parser::ParseCaseStatement(Pa
     if (ColonLoc.isValid()) {
       SourceLocation AfterColonLoc = PP.getLocForEndOfToken(ColonLoc);
       Diag(AfterColonLoc, diag::err_label_end_of_compound_statement)
-        << FixItHint::CreateInsertion(AfterColonLoc, " ;");
+          << FixItHint::CreateInsertion(AfterColonLoc, " ;");
     }
     SubStmt = StmtError();
   }
@@ -843,7 +849,7 @@ StmtResult Parser::ParseDefaultStatement
   // otherwise in the same context as the labeled-statement.
   StmtCtx &= ~ParsedStmtContext::AllowDeclarationsInC;
 
-  SourceLocation DefaultLoc = ConsumeToken();  // eat the 'default'.
+  SourceLocation DefaultLoc = ConsumeToken(); // eat the 'default'.
 
   SourceLocation ColonLoc;
   if (TryConsumeToken(tok::colon, ColonLoc)) {
@@ -869,7 +875,7 @@ StmtResult Parser::ParseDefaultStatement
     // not valid.
     SourceLocation AfterColonLoc = PP.getLocForEndOfToken(ColonLoc);
     Diag(AfterColonLoc, diag::err_label_end_of_compound_statement)
-      << FixItHint::CreateInsertion(AfterColonLoc, " ;");
+        << FixItHint::CreateInsertion(AfterColonLoc, " ;");
     SubStmt = true;
   }
 
@@ -877,8 +883,8 @@ StmtResult Parser::ParseDefaultStatement
   if (SubStmt.isInvalid())
     SubStmt = Actions.ActOnNullStmt(ColonLoc);
 
-  return Actions.ActOnDefaultStmt(DefaultLoc, ColonLoc,
-                                  SubStmt.get(), getCurScope());
+  return Actions.ActOnDefaultStmt(DefaultLoc, ColonLoc, SubStmt.get(),
+                                  getCurScope());
 }
 
 StmtResult Parser::ParseCompoundStatement(bool isStmtExpr) {
@@ -984,7 +990,6 @@ void Parser::ParseCompoundStatementLeadi
       break;
     }
   }
-
 }
 
 /// Consume any extra semi-colons resulting in null statements,
@@ -1041,8 +1046,7 @@ StmtResult Parser::handleExprStmt(ExprRe
 /// consume the '}' at the end of the block.  It does not manipulate the scope
 /// stack.
 StmtResult Parser::ParseCompoundStatementBody(bool isStmtExpr) {
-  PrettyStackTraceLoc CrashInfo(PP.getSourceManager(),
-                                Tok.getLocation(),
+  PrettyStackTraceLoc CrashInfo(PP.getSourceManager(), Tok.getLocation(),
                                 "in compound statement ('{}')");
 
   // Record the current FPFeatures, restore on leaving the
@@ -1170,8 +1174,8 @@ StmtResult Parser::ParseCompoundStatemen
   if (T.getCloseLocation().isValid())
     CloseLoc = T.getCloseLocation();
 
-  return Actions.ActOnCompoundStmt(T.getOpenLocation(), CloseLoc,
-                                   Stmts, isStmtExpr);
+  return Actions.ActOnCompoundStmt(T.getOpenLocation(), CloseLoc, Stmts,
+                                   isStmtExpr);
 }
 
 /// ParseParenExprOrCondition:
@@ -1246,7 +1250,7 @@ bool Parser::ParseParenExprOrCondition(S
   // isn't valid.
   while (Tok.is(tok::r_paren)) {
     Diag(Tok, diag::err_extraneous_rparen_in_condition)
-      << FixItHint::CreateRemoval(Tok.getLocation());
+        << FixItHint::CreateRemoval(Tok.getLocation());
     ConsumeParen();
   }
 
@@ -1345,7 +1349,7 @@ struct MisleadingIndentationChecker {
   }
 };
 
-}
+} // namespace
 
 /// ParseIfStatement
 ///       if-statement: [C99 6.8.4.1]
@@ -1358,7 +1362,7 @@ struct MisleadingIndentationChecker {
 ///
 StmtResult Parser::ParseIfStatement(SourceLocation *TrailingElseLoc) {
   assert(Tok.is(tok::kw_if) && "Not an if stmt!");
-  SourceLocation IfLoc = ConsumeToken();  // eat the 'if'.
+  SourceLocation IfLoc = ConsumeToken(); // eat the 'if'.
 
   bool IsConstexpr = false;
   bool IsConsteval = false;
@@ -1577,7 +1581,7 @@ StmtResult Parser::ParseIfStatement(Sour
 /// [C++]   'switch' '(' condition ')' statement
 StmtResult Parser::ParseSwitchStatement(SourceLocation *TrailingElseLoc) {
   assert(Tok.is(tok::kw_switch) && "Not a switch stmt!");
-  SourceLocation SwitchLoc = ConsumeToken();  // eat the 'switch'.
+  SourceLocation SwitchLoc = ConsumeToken(); // eat the 'switch'.
 
   if (Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "switch";
@@ -1666,7 +1670,7 @@ StmtResult Parser::ParseSwitchStatement(
 StmtResult Parser::ParseWhileStatement(SourceLocation *TrailingElseLoc) {
   assert(Tok.is(tok::kw_while) && "Not a while stmt!");
   SourceLocation WhileLoc = Tok.getLocation();
-  ConsumeToken();  // eat the 'while'.
+  ConsumeToken(); // eat the 'while'.
 
   if (Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "while";
@@ -1690,8 +1694,8 @@ StmtResult Parser::ParseWhileStatement(S
   //
   unsigned ScopeFlags;
   if (C99orCXX)
-    ScopeFlags = Scope::BreakScope | Scope::ContinueScope |
-                 Scope::DeclScope  | Scope::ControlScope;
+    ScopeFlags = Scope::BreakScope | Scope::ContinueScope | Scope::DeclScope |
+                 Scope::ControlScope;
   else
     ScopeFlags = Scope::BreakScope | Scope::ContinueScope;
   ParseScope WhileScope(this, ScopeFlags);
@@ -1741,7 +1745,7 @@ StmtResult Parser::ParseWhileStatement(S
 /// Note: this lets the caller parse the end ';'.
 StmtResult Parser::ParseDoStatement() {
   assert(Tok.is(tok::kw_do) && "Not a do stmt!");
-  SourceLocation DoLoc = ConsumeToken();  // eat the 'do'.
+  SourceLocation DoLoc = ConsumeToken(); // eat the 'do'.
 
   // C99 6.8.5p5 - In C99, the do statement is a block.  This is not
   // the case for C90.  Start the loop scope.
@@ -1859,7 +1863,7 @@ bool Parser::isForRangeIdentifier() {
 /// [C++0x]   braced-init-list            [TODO]
 StmtResult Parser::ParseForStatement(SourceLocation *TrailingElseLoc) {
   assert(Tok.is(tok::kw_for) && "Not a for stmt!");
-  SourceLocation ForLoc = ConsumeToken();  // eat the 'for'.
+  SourceLocation ForLoc = ConsumeToken(); // eat the 'for'.
 
   SourceLocation CoawaitLoc;
   if (Tok.is(tok::kw_co_await))
@@ -1871,8 +1875,8 @@ StmtResult Parser::ParseForStatement(Sou
     return StmtError();
   }
 
-  bool C99orCXXorObjC = getLangOpts().C99 || getLangOpts().CPlusPlus ||
-    getLangOpts().ObjC;
+  bool C99orCXXorObjC =
+      getLangOpts().C99 || getLangOpts().CPlusPlus || getLangOpts().ObjC;
 
   // C99 6.8.5p5 - In C99, the for statement is a block.  This is not
   // the case for C90.  Start the loop scope.
@@ -1909,9 +1913,9 @@ StmtResult Parser::ParseForStatement(Sou
 
   if (Tok.is(tok::code_completion)) {
     cutOffParsing();
-    Actions.CodeCompleteOrdinaryName(getCurScope(),
-                                     C99orCXXorObjC? Sema::PCC_ForInit
-                                                   : Sema::PCC_Expression);
+    Actions.CodeCompleteOrdinaryName(getCurScope(), C99orCXXorObjC
+                                                        ? Sema::PCC_ForInit
+                                                        : Sema::PCC_Expression);
     return StmtError();
   }
 
@@ -1921,7 +1925,7 @@ StmtResult Parser::ParseForStatement(Sou
   SourceLocation EmptyInitStmtSemiLoc;
 
   // Parse the first part of the for specifier.
-  if (Tok.is(tok::semi)) {  // for (;
+  if (Tok.is(tok::semi)) { // for (;
     ProhibitAttributes(attrs);
     // no first part, eat the ';'.
     SourceLocation SemiLoc = Tok.getLocation();
@@ -1942,17 +1946,17 @@ StmtResult Parser::ParseForStatement(Sou
       ForRangeInfo.RangeExpr = ParseExpression();
 
     Diag(Loc, diag::err_for_range_identifier)
-      << ((getLangOpts().CPlusPlus11 && !getLangOpts().CPlusPlus17)
-              ? FixItHint::CreateInsertion(Loc, "auto &&")
-              : FixItHint());
+        << ((getLangOpts().CPlusPlus11 && !getLangOpts().CPlusPlus17)
+                ? FixItHint::CreateInsertion(Loc, "auto &&")
+                : FixItHint());
 
     ForRangeInfo.LoopVar = Actions.ActOnCXXForRangeIdentifier(
         getCurScope(), Loc, Name, attrs, attrs.Range.getEnd());
-  } else if (isForInitDeclaration()) {  // for (int X = 4;
+  } else if (isForInitDeclaration()) { // for (int X = 4;
     ParenBraceBracketBalancer BalancerRAIIObj(*this);
 
     // Parse declaration, which eats the ';'.
-    if (!C99orCXXorObjC) {   // Use of C99-style for loops in C90 mode?
+    if (!C99orCXXorObjC) { // Use of C99-style for loops in C90 mode?
       Diag(Tok, diag::ext_c99_variable_decl_in_for_loop);
       Diag(Tok, diag::warn_gcc_variable_decl_in_for_loop);
     }
@@ -2026,11 +2030,12 @@ StmtResult Parser::ParseForStatement(Sou
         return StmtError();
       }
       Collection = ParseExpression();
-    } else if (getLangOpts().CPlusPlus11 && Tok.is(tok::colon) && FirstPart.get()) {
+    } else if (getLangOpts().CPlusPlus11 && Tok.is(tok::colon) &&
+               FirstPart.get()) {
       // User tried to write the reasonable, but ill-formed, for-range-statement
       //   for (expr : expr) { ... }
       Diag(Tok, diag::err_for_range_expected_decl)
-        << FirstPart.get()->getSourceRange();
+          << FirstPart.get()->getSourceRange();
       SkipUntil(tok::r_paren, StopBeforeMatch);
       SecondPart = Sema::ConditionError();
     } else {
@@ -2049,7 +2054,7 @@ StmtResult Parser::ParseForStatement(Sou
   if (!ForEach && !ForRangeInfo.ParsedForRangeDecl() &&
       !SecondPart.isInvalid()) {
     // Parse the second part of the for specifier.
-    if (Tok.is(tok::semi)) {  // for (...;;
+    if (Tok.is(tok::semi)) { // for (...;;
       // no second part.
     } else if (Tok.is(tok::r_paren)) {
       // missing both semicolons.
@@ -2113,7 +2118,7 @@ StmtResult Parser::ParseForStatement(Sou
       ConsumeToken();
     }
 
-    if (Tok.isNot(tok::r_paren)) {   // for (...;...;)
+    if (Tok.isNot(tok::r_paren)) { // for (...;...;)
       ExprResult Third = ParseExpression();
       // FIXME: The C++11 standard doesn't actually say that this is a
       // discarded-value expression, but it clearly should be.
@@ -2147,13 +2152,11 @@ StmtResult Parser::ParseForStatement(Sou
         ForRangeInfo.LoopVar.get(), ForRangeInfo.ColonLoc, CorrectedRange.get(),
         T.getCloseLocation(), Sema::BFRK_Build);
 
-  // Similarly, we need to do the semantic analysis for a for-range
-  // statement immediately in order to close over temporaries correctly.
+    // Similarly, we need to do the semantic analysis for a for-range
+    // statement immediately in order to close over temporaries correctly.
   } else if (ForEach) {
-    ForEachStmt = Actions.ActOnObjCForCollectionStmt(ForLoc,
-                                                     FirstPart.get(),
-                                                     Collection.get(),
-                                                     T.getCloseLocation());
+    ForEachStmt = Actions.ActOnObjCForCollectionStmt(
+        ForLoc, FirstPart.get(), Collection.get(), T.getCloseLocation());
   } else {
     // In OpenMP loop region loop control variable must be captured and be
     // private. Perform analysis of first part (if any).
@@ -2201,8 +2204,7 @@ StmtResult Parser::ParseForStatement(Sou
     return StmtError();
 
   if (ForEach)
-   return Actions.FinishObjCForCollectionStmt(ForEachStmt.get(),
-                                              Body.get());
+    return Actions.FinishObjCForCollectionStmt(ForEachStmt.get(), Body.get());
 
   if (ForRangeInfo.ParsedForRangeDecl())
     return Actions.FinishCXXForRangeStmt(ForRangeStmt.get(), Body.get());
@@ -2221,12 +2223,12 @@ StmtResult Parser::ParseForStatement(Sou
 ///
 StmtResult Parser::ParseGotoStatement() {
   assert(Tok.is(tok::kw_goto) && "Not a goto stmt!");
-  SourceLocation GotoLoc = ConsumeToken();  // eat the 'goto'.
+  SourceLocation GotoLoc = ConsumeToken(); // eat the 'goto'.
 
   StmtResult Res;
   if (Tok.is(tok::identifier)) {
-    LabelDecl *LD = Actions.LookupOrCreateLabel(Tok.getIdentifierInfo(),
-                                                Tok.getLocation());
+    LabelDecl *LD =
+        Actions.LookupOrCreateLabel(Tok.getIdentifierInfo(), Tok.getLocation());
     Res = Actions.ActOnGotoStmt(GotoLoc, Tok.getLocation(), LD);
     ConsumeToken();
   } else if (Tok.is(tok::star)) {
@@ -2234,7 +2236,7 @@ StmtResult Parser::ParseGotoStatement()
     Diag(Tok, diag::ext_gnu_indirect_goto);
     SourceLocation StarLoc = ConsumeToken();
     ExprResult R(ParseExpression());
-    if (R.isInvalid()) {  // Skip to the semicolon, but don't consume it.
+    if (R.isInvalid()) { // Skip to the semicolon, but don't consume it.
       SkipUntil(tok::semi, StopBeforeMatch);
       return StmtError();
     }
@@ -2254,7 +2256,7 @@ StmtResult Parser::ParseGotoStatement()
 /// Note: this lets the caller parse the end ';'.
 ///
 StmtResult Parser::ParseContinueStatement() {
-  SourceLocation ContinueLoc = ConsumeToken();  // eat the 'continue'.
+  SourceLocation ContinueLoc = ConsumeToken(); // eat the 'continue'.
   return Actions.ActOnContinueStmt(ContinueLoc, getCurScope());
 }
 
@@ -2265,7 +2267,7 @@ StmtResult Parser::ParseContinueStatemen
 /// Note: this lets the caller parse the end ';'.
 ///
 StmtResult Parser::ParseBreakStatement() {
-  SourceLocation BreakLoc = ConsumeToken();  // eat the 'break'.
+  SourceLocation BreakLoc = ConsumeToken(); // eat the 'break'.
   return Actions.ActOnBreakStmt(BreakLoc, getCurScope());
 }
 
@@ -2279,7 +2281,7 @@ StmtResult Parser::ParseReturnStatement(
   assert((Tok.is(tok::kw_return) || Tok.is(tok::kw_co_return)) &&
          "Not a return stmt!");
   bool IsCoreturn = Tok.is(tok::kw_co_return);
-  SourceLocation ReturnLoc = ConsumeToken();  // eat the 'return'.
+  SourceLocation ReturnLoc = ConsumeToken(); // eat the 'return'.
 
   ExprResult R;
   if (Tok.isNot(tok::semi)) {
@@ -2361,8 +2363,8 @@ Decl *Parser::ParseFunctionStatementBody
   // Save and reset current vtordisp stack if we have entered a C++ method body.
   bool IsCXXMethod =
       getLangOpts().CPlusPlus && Decl && isa<CXXMethodDecl>(Decl);
-  Sema::PragmaStackSentinelRAII
-    PragmaStackSentinel(Actions, "InternalPragmaState", IsCXXMethod);
+  Sema::PragmaStackSentinelRAII PragmaStackSentinel(
+      Actions, "InternalPragmaState", IsCXXMethod);
 
   // Do not enter a scope for the brace, as the arguments are in the same scope
   // (the function body) as the body itself.  Instead, just read the statement
@@ -2400,11 +2402,11 @@ Decl *Parser::ParseFunctionTryBlock(Decl
   // Save and reset current vtordisp stack if we have entered a C++ method body.
   bool IsCXXMethod =
       getLangOpts().CPlusPlus && Decl && isa<CXXMethodDecl>(Decl);
-  Sema::PragmaStackSentinelRAII
-    PragmaStackSentinel(Actions, "InternalPragmaState", IsCXXMethod);
+  Sema::PragmaStackSentinelRAII PragmaStackSentinel(
+      Actions, "InternalPragmaState", IsCXXMethod);
 
   SourceLocation LBraceLoc = Tok.getLocation();
-  StmtResult FnBody(ParseCXXTryBlockCommon(TryLoc, /*FnTry*/true));
+  StmtResult FnBody(ParseCXXTryBlockCommon(TryLoc, /*FnTry*/ true));
   // If we failed to parse the try-catch, we just give the function an empty
   // compound statement as the body.
   if (FnBody.isInvalid()) {
@@ -2502,23 +2504,19 @@ StmtResult Parser::ParseCXXTryBlockCommo
       Tok.is(tok::kw___finally)) {
     // TODO: Factor into common return ParseSEHHandlerCommon(...)
     StmtResult Handler;
-    if(Tok.getIdentifierInfo() == getSEHExceptKeyword()) {
+    if (Tok.getIdentifierInfo() == getSEHExceptKeyword()) {
       SourceLocation Loc = ConsumeToken();
       Handler = ParseSEHExceptBlock(Loc);
-    }
-    else {
+    } else {
       SourceLocation Loc = ConsumeToken();
       Handler = ParseSEHFinallyBlock(Loc);
     }
-    if(Handler.isInvalid())
+    if (Handler.isInvalid())
       return Handler;
 
-    return Actions.ActOnSEHTryBlock(true /* IsCXXTry */,
-                                    TryLoc,
-                                    TryBlock.get(),
+    return Actions.ActOnSEHTryBlock(true /* IsCXXTry */, TryLoc, TryBlock.get(),
                                     Handler.get());
-  }
-  else {
+  } else {
     StmtVector Handlers;
 
     // C++11 attributes can't appear here, despite this context seeming
@@ -2620,11 +2618,9 @@ void Parser::ParseMicrosoftIfExistsState
     if (Compound.isInvalid())
       return;
 
-    StmtResult DepResult = Actions.ActOnMSDependentExistsStmt(Result.KeywordLoc,
-                                                              Result.IsIfExists,
-                                                              Result.SS,
-                                                              Result.Name,
-                                                              Compound.get());
+    StmtResult DepResult = Actions.ActOnMSDependentExistsStmt(
+        Result.KeywordLoc, Result.IsIfExists, Result.SS, Result.Name,
+        Compound.get());
     if (DepResult.isUsable())
       Stmts.push_back(DepResult.get());
     return;
diff --color -uprN clang-14.0.6.src/lib/Sema/Sema.cpp clang-14.0.6.src.patched/lib/Sema/Sema.cpp
--- clang-14.0.6.src/lib/Sema/Sema.cpp	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/lib/Sema/Sema.cpp	2024-11-12 13:24:23.357485188 +0800
@@ -21,6 +21,7 @@
 #include "clang/AST/Expr.h"
 #include "clang/AST/ExprCXX.h"
 #include "clang/AST/PrettyDeclStackTrace.h"
+#include "clang/AST/Stmt.h"
 #include "clang/AST/StmtCXX.h"
 #include "clang/Basic/DarwinSDKInfo.h"
 #include "clang/Basic/DiagnosticOptions.h"
@@ -258,8 +259,8 @@ void Sema::Initialize() {
     SC->InitializeSema(*this);
 
   // Tell the external Sema source about this Sema object.
-  if (ExternalSemaSource *ExternalSema
-      = dyn_cast_or_null<ExternalSemaSource>(Context.getExternalSource()))
+  if (ExternalSemaSource *ExternalSema =
+          dyn_cast_or_null<ExternalSemaSource>(Context.getExternalSource()))
     ExternalSema->InitializeSema(*this);
 
   // This needs to happen after ExternalSemaSource::InitializeSema(this) or we
@@ -284,7 +285,6 @@ void Sema::Initialize() {
       PushOnScopeChains(Context.getUInt128Decl(), TUScope);
   }
 
-
   // Initialize predefined Objective-C types:
   if (getLangOpts().ObjC) {
     // If 'SEL' does not yet refer to any declarations, make it refer to the
@@ -349,7 +349,6 @@ void Sema::Initialize() {
       // 32-bit integer and OpenCLC v2.0, s6.1.1 int is always 32-bit wide.
       addImplicitTypedef("atomic_flag", Context.getAtomicType(Context.IntTy));
 
-
       // OpenCL v2.0 s6.13.11.6:
       // - The atomic_long and atomic_ulong types are supported if the
       //   cl_khr_int64_base_atomics and cl_khr_int64_extended_atomics
@@ -398,7 +397,6 @@ void Sema::Initialize() {
         addImplicitTypedef("atomic_long", AtomicLongT);
         addImplicitTypedef("atomic_ulong", AtomicULongT);
 
-
         if (Context.getTypeSize(Context.getSizeType()) == 64) {
           AddPointerSizeDependentTypes();
         }
@@ -413,17 +411,17 @@ void Sema::Initialize() {
   }
 
   if (Context.getTargetInfo().hasAArch64SVETypes()) {
-#define SVE_TYPE(Name, Id, SingletonId) \
-    addImplicitTypedef(Name, Context.SingletonId);
+#define SVE_TYPE(Name, Id, SingletonId)                                        \
+  addImplicitTypedef(Name, Context.SingletonId);
 #include "clang/Basic/AArch64SVEACLETypes.def"
   }
 
   if (Context.getTargetInfo().getTriple().isPPC64()) {
-#define PPC_VECTOR_MMA_TYPE(Name, Id, Size) \
-      addImplicitTypedef(#Name, Context.Id##Ty);
+#define PPC_VECTOR_MMA_TYPE(Name, Id, Size)                                    \
+  addImplicitTypedef(#Name, Context.Id##Ty);
 #include "clang/Basic/PPCTypes.def"
-#define PPC_VECTOR_VSX_TYPE(Name, Id, Size) \
-    addImplicitTypedef(#Name, Context.Id##Ty);
+#define PPC_VECTOR_VSX_TYPE(Name, Id, Size)                                    \
+  addImplicitTypedef(#Name, Context.Id##Ty);
 #include "clang/Basic/PPCTypes.def"
   }
 
@@ -448,7 +446,8 @@ Sema::~Sema() {
   assert(InstantiatingSpecializations.empty() &&
          "failed to clean up an InstantiatingTemplate?");
 
-  if (VisContext) FreeVisContext();
+  if (VisContext)
+    FreeVisContext();
 
   // Kill all the active scopes.
   for (sema::FunctionScopeInfo *FSI : FunctionScopes)
@@ -459,8 +458,8 @@ Sema::~Sema() {
     SC->ForgetSema();
 
   // Detach from the external Sema source.
-  if (ExternalSemaSource *ExternalSema
-        = dyn_cast_or_null<ExternalSemaSource>(Context.getExternalSource()))
+  if (ExternalSemaSource *ExternalSema =
+          dyn_cast_or_null<ExternalSemaSource>(Context.getExternalSource()))
     ExternalSema->ForgetSema();
 
   // If Sema's ExternalSource is the multiplexer - we own it.
@@ -502,11 +501,12 @@ void Sema::runWithSufficientStackSpace(S
 /// context.  If we're still in a system header, and we can plausibly
 /// make the relevant declaration unavailable instead of erroring, do
 /// so and return true.
-bool Sema::makeUnavailableInSystemHeader(SourceLocation loc,
-                                      UnavailableAttr::ImplicitReason reason) {
+bool Sema::makeUnavailableInSystemHeader(
+    SourceLocation loc, UnavailableAttr::ImplicitReason reason) {
   // If we're not in a function, it's an error.
   FunctionDecl *fn = dyn_cast<FunctionDecl>(CurContext);
-  if (!fn) return false;
+  if (!fn)
+    return false;
 
   // If we're in template instantiation, it's an error.
   if (inTemplateInstantiation())
@@ -517,7 +517,8 @@ bool Sema::makeUnavailableInSystemHeader
     return false;
 
   // If the function is already unavailable, it's not an error.
-  if (fn->hasAttr<UnavailableAttr>()) return true;
+  if (fn->hasAttr<UnavailableAttr>())
+    return true;
 
   fn->addAttr(UnavailableAttr::CreateImplicit(Context, "", reason, loc));
   return true;
@@ -527,8 +528,8 @@ ASTMutationListener *Sema::getASTMutatio
   return getASTConsumer().GetASTMutationListener();
 }
 
-///Registers an external source. If an external source already exists,
-/// creates a multiplex external source and appends to it.
+/// Registers an external source. If an external source already exists,
+///  creates a multiplex external source and appends to it.
 ///
 ///\param[in] E - A non-null external sema source.
 ///
@@ -541,7 +542,7 @@ void Sema::addExternalSource(ExternalSem
   }
 
   if (isMultiplexExternalSource)
-    static_cast<MultiplexExternalSemaSource*>(ExternalSource)->addSource(*E);
+    static_cast<MultiplexExternalSemaSource *>(ExternalSource)->addSource(*E);
   else {
     ExternalSource = new MultiplexExternalSemaSource(*ExternalSource, *E);
     isMultiplexExternalSource = true;
@@ -572,7 +573,7 @@ void Sema::diagnoseNullableToNonnullConv
   Diag(Loc, diag::warn_nullability_lost) << SrcType << DstType;
 }
 
-void Sema::diagnoseZeroToNullptrConversion(CastKind Kind, const Expr* E) {
+void Sema::diagnoseZeroToNullptrConversion(CastKind Kind, const Expr *E) {
   if (Diags.isIgnored(diag::warn_zero_as_null_pointer_constant,
                       E->getBeginLoc()))
     return;
@@ -607,8 +608,8 @@ void Sema::diagnoseZeroToNullptrConversi
 /// ImpCastExprToType - If Expr is not of type 'Type', insert an implicit cast.
 /// If there is already an implicit cast, merge into the existing one.
 /// The result is of the given category.
-ExprResult Sema::ImpCastExprToType(Expr *E, QualType Ty,
-                                   CastKind Kind, ExprValueKind VK,
+ExprResult Sema::ImpCastExprToType(Expr *E, QualType Ty, CastKind Kind,
+                                   ExprValueKind VK,
                                    const CXXCastPath *BasePath,
                                    CheckedConversionKind CCK) {
 #ifndef NDEBUG
@@ -690,16 +691,26 @@ ExprResult Sema::ImpCastExprToType(Expr
 /// to the conversion from scalar type ScalarTy to the Boolean type.
 CastKind Sema::ScalarTypeToBooleanCastKind(QualType ScalarTy) {
   switch (ScalarTy->getScalarTypeKind()) {
-  case Type::STK_Bool: return CK_NoOp;
-  case Type::STK_CPointer: return CK_PointerToBoolean;
-  case Type::STK_BlockPointer: return CK_PointerToBoolean;
-  case Type::STK_ObjCObjectPointer: return CK_PointerToBoolean;
-  case Type::STK_MemberPointer: return CK_MemberPointerToBoolean;
-  case Type::STK_Integral: return CK_IntegralToBoolean;
-  case Type::STK_Floating: return CK_FloatingToBoolean;
-  case Type::STK_IntegralComplex: return CK_IntegralComplexToBoolean;
-  case Type::STK_FloatingComplex: return CK_FloatingComplexToBoolean;
-  case Type::STK_FixedPoint: return CK_FixedPointToBoolean;
+  case Type::STK_Bool:
+    return CK_NoOp;
+  case Type::STK_CPointer:
+    return CK_PointerToBoolean;
+  case Type::STK_BlockPointer:
+    return CK_PointerToBoolean;
+  case Type::STK_ObjCObjectPointer:
+    return CK_PointerToBoolean;
+  case Type::STK_MemberPointer:
+    return CK_MemberPointerToBoolean;
+  case Type::STK_Integral:
+    return CK_IntegralToBoolean;
+  case Type::STK_Floating:
+    return CK_FloatingToBoolean;
+  case Type::STK_IntegralComplex:
+    return CK_IntegralComplexToBoolean;
+  case Type::STK_FloatingComplex:
+    return CK_FloatingComplexToBoolean;
+  case Type::STK_FixedPoint:
+    return CK_FixedPointToBoolean;
   }
   llvm_unreachable("unknown scalar type kind");
 }
@@ -786,15 +797,17 @@ bool Sema::isExternalWithNoLinkageType(V
 /// Obtains a sorted list of functions and variables that are undefined but
 /// ODR-used.
 void Sema::getUndefinedButUsed(
-    SmallVectorImpl<std::pair<NamedDecl *, SourceLocation> > &Undefined) {
+    SmallVectorImpl<std::pair<NamedDecl *, SourceLocation>> &Undefined) {
   for (const auto &UndefinedUse : UndefinedButUsed) {
     NamedDecl *ND = UndefinedUse.first;
 
     // Ignore attributes that have become invalid.
-    if (ND->isInvalidDecl()) continue;
+    if (ND->isInvalidDecl())
+      continue;
 
     // __attribute__((weakref)) is basically a definition.
-    if (ND->hasAttr<WeakRefAttr>()) continue;
+    if (ND->hasAttr<WeakRefAttr>())
+      continue;
 
     if (isa<CXXDeductionGuideDecl>(ND))
       continue;
@@ -809,8 +822,7 @@ void Sema::getUndefinedButUsed(
     if (FunctionDecl *FD = dyn_cast<FunctionDecl>(ND)) {
       if (FD->isDefined())
         continue;
-      if (FD->isExternallyVisible() &&
-          !isExternalWithNoLinkageType(FD) &&
+      if (FD->isExternallyVisible() && !isExternalWithNoLinkageType(FD) &&
           !FD->getMostRecentDecl()->isInlined() &&
           !FD->hasAttr<ExcludeFromExplicitInstantiationAttr>())
         continue;
@@ -820,8 +832,7 @@ void Sema::getUndefinedButUsed(
       auto *VD = cast<VarDecl>(ND);
       if (VD->hasDefinition() != VarDecl::DeclarationOnly)
         continue;
-      if (VD->isExternallyVisible() &&
-          !isExternalWithNoLinkageType(VD) &&
+      if (VD->isExternallyVisible() && !isExternalWithNoLinkageType(VD) &&
           !VD->getMostRecentDecl()->isInline() &&
           !VD->hasAttr<ExcludeFromExplicitInstantiationAttr>())
         continue;
@@ -839,12 +850,14 @@ void Sema::getUndefinedButUsed(
 /// checkUndefinedButUsed - Check for undefined objects with internal linkage
 /// or that are inline.
 static void checkUndefinedButUsed(Sema &S) {
-  if (S.UndefinedButUsed.empty()) return;
+  if (S.UndefinedButUsed.empty())
+    return;
 
   // Collect all the still-undefined entities with internal linkage.
   SmallVector<std::pair<NamedDecl *, SourceLocation>, 16> Undefined;
   S.getUndefinedButUsed(Undefined);
-  if (Undefined.empty()) return;
+  if (Undefined.empty())
+    return;
 
   for (auto Undef : Undefined) {
     ValueDecl *VD = cast<ValueDecl>(Undef.first);
@@ -863,7 +876,7 @@ static void checkUndefinedButUsed(Sema &
       S.Diag(VD->getLocation(), isExternallyVisible(VD->getType()->getLinkage())
                                     ? diag::ext_undefined_internal_type
                                     : diag::err_undefined_internal_type)
-        << isa<VarDecl>(VD) << VD;
+          << isa<VarDecl>(VD) << VD;
     } else if (!VD->isExternallyVisible()) {
       // FIXME: We can promote this to an error. The function or variable can't
       // be defined anywhere else, so the program must necessarily violate the
@@ -911,8 +924,7 @@ void Sema::LoadExternalWeakUndeclaredIde
     WeakUndeclaredIdentifiers.insert(WeakID);
 }
 
-
-typedef llvm::DenseMap<const CXXRecordDecl*, bool> RecordCompleteMap;
+typedef llvm::DenseMap<const CXXRecordDecl *, bool> RecordCompleteMap;
 
 /// Returns true, if all methods and nested classes of the given
 /// CXXRecordDecl are defined in this translation unit.
@@ -927,8 +939,7 @@ static bool MethodsAndNestedClassesCompl
   if (!RD->isCompleteDefinition())
     return false;
   bool Complete = true;
-  for (DeclContext::decl_iterator I = RD->decls_begin(),
-                                  E = RD->decls_end();
+  for (DeclContext::decl_iterator I = RD->decls_begin(), E = RD->decls_end();
        I != E && Complete; ++I) {
     if (const CXXMethodDecl *M = dyn_cast<CXXMethodDecl>(*I))
       Complete = M->isDefined() || M->isDefaulted() ||
@@ -939,13 +950,13 @@ static bool MethodsAndNestedClassesCompl
       // performed semantic analysis on it yet, so we cannot know if the type
       // can be considered complete.
       Complete = !F->getTemplatedDecl()->isLateTemplateParsed() &&
-                  F->getTemplatedDecl()->isDefined();
+                 F->getTemplatedDecl()->isDefined();
     else if (const CXXRecordDecl *R = dyn_cast<CXXRecordDecl>(*I)) {
       if (R->isInjectedClassName())
         continue;
       if (R->hasDefinition())
-        Complete = MethodsAndNestedClassesComplete(R->getDefinition(),
-                                                   MNCComplete);
+        Complete =
+            MethodsAndNestedClassesComplete(R->getDefinition(), MNCComplete);
       else
         Complete = false;
     }
@@ -981,7 +992,7 @@ static bool IsRecordFullyDefined(const C
     } else {
       // Friend functions are available through the NamedDecl of FriendDecl.
       if (const FunctionDecl *FD =
-          dyn_cast<FunctionDecl>((*I)->getFriendDecl()))
+              dyn_cast<FunctionDecl>((*I)->getFriendDecl()))
         Complete = FD->isDefined();
       else
         // This is a template friend, give up.
@@ -1060,8 +1071,8 @@ void Sema::ActOnEndOfTranslationUnitFrag
     for (auto PII : Pending)
       if (auto Func = dyn_cast<FunctionDecl>(PII.first))
         Func->setInstantiationIsPending(true);
-    PendingInstantiations.insert(PendingInstantiations.begin(),
-                                 Pending.begin(), Pending.end());
+    PendingInstantiations.insert(PendingInstantiations.begin(), Pending.begin(),
+                                 Pending.end());
   }
 
   {
@@ -1089,8 +1100,8 @@ void Sema::ActOnEndOfTranslationUnitFrag
 /// translation unit when EOF is reached and all but the top-level scope is
 /// popped.
 void Sema::ActOnEndOfTranslationUnit() {
-  assert(DelayedDiagnostics.getCurrentPool() == nullptr
-         && "reached end of translation unit with a pool attached?");
+  assert(DelayedDiagnostics.getCurrentPool() == nullptr &&
+         "reached end of translation unit with a pool attached?");
 
   // If code completion is enabled, don't perform any end-of-translation-unit
   // work.
@@ -1249,8 +1260,8 @@ void Sema::ActOnEndOfTranslationUnit() {
   //   translation unit, with an initializer equal to 0.
   llvm::SmallSet<VarDecl *, 32> Seen;
   for (TentativeDefinitionsType::iterator
-            T = TentativeDefinitions.begin(ExternalSource),
-         TEnd = TentativeDefinitions.end();
+           T = TentativeDefinitions.begin(ExternalSource),
+           TEnd = TentativeDefinitions.end();
        T != TEnd; ++T) {
     VarDecl *VD = (*T)->getActingDefinition();
 
@@ -1260,8 +1271,8 @@ void Sema::ActOnEndOfTranslationUnit() {
     if (!VD || VD->isInvalidDecl() || !Seen.insert(VD).second)
       continue;
 
-    if (const IncompleteArrayType *ArrayT
-        = Context.getAsIncompleteArrayType(VD->getType())) {
+    if (const IncompleteArrayType *ArrayT =
+            Context.getAsIncompleteArrayType(VD->getType())) {
       // Set the length of the array to 1 (C99 6.9.2p5).
       Diag(VD->getLocation(), diag::warn_tentative_incomplete_array);
       llvm::APInt One(Context.getTypeSize(Context.getSizeType()), true);
@@ -1294,8 +1305,9 @@ void Sema::ActOnEndOfTranslationUnit() {
   if (!Diags.hasErrorOccurred() && TUKind != TU_Module) {
     // Output warning for unused file scoped decls.
     for (UnusedFileScopedDeclsType::iterator
-           I = UnusedFileScopedDecls.begin(ExternalSource),
-           E = UnusedFileScopedDecls.end(); I != E; ++I) {
+             I = UnusedFileScopedDecls.begin(ExternalSource),
+             E = UnusedFileScopedDecls.end();
+         I != E; ++I) {
       if (ShouldRemoveFromUnused(this, *I))
         continue;
 
@@ -1313,7 +1325,7 @@ void Sema::ActOnEndOfTranslationUnit() {
             if (FD->getStorageClass() == SC_Static &&
                 !FD->isInlineSpecified() &&
                 !SourceMgr.isInMainFile(
-                   SourceMgr.getExpansionLoc(FD->getLocation())))
+                    SourceMgr.getExpansionLoc(FD->getLocation())))
               Diag(DiagD->getLocation(),
                    diag::warn_unneeded_static_internal_decl)
                   << DiagD;
@@ -1363,13 +1375,14 @@ void Sema::ActOnEndOfTranslationUnit() {
     RecordCompleteMap RecordsComplete;
     RecordCompleteMap MNCComplete;
     for (NamedDeclSetType::iterator I = UnusedPrivateFields.begin(),
-         E = UnusedPrivateFields.end(); I != E; ++I) {
+                                    E = UnusedPrivateFields.end();
+         I != E; ++I) {
       const NamedDecl *D = *I;
       const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(D->getDeclContext());
       if (RD && !RD->isUnion() &&
           IsRecordFullyDefined(RD, RecordsComplete, MNCComplete)) {
         Diag(D->getLocation(), diag::warn_unused_private_field)
-              << D->getDeclName();
+            << D->getDeclName();
       }
     }
   }
@@ -1395,7 +1408,6 @@ void Sema::ActOnEndOfTranslationUnit() {
     TUScope = nullptr;
 }
 
-
 //===----------------------------------------------------------------------===//
 // Helper functions.
 //===----------------------------------------------------------------------===//
@@ -1411,8 +1423,8 @@ DeclContext *Sema::getFunctionLevelDeclC
                cast<CXXMethodDecl>(DC)->getOverloadedOperator() == OO_Call &&
                cast<CXXRecordDecl>(DC->getParent())->isLambda()) {
       DC = DC->getParent()->getParent();
-    }
-    else break;
+    } else
+      break;
   }
 
   return DC;
@@ -1454,9 +1466,9 @@ void Sema::EmitCurrentDiagnostic(unsigne
   // eliminated. If it truly cannot be (for example, there is some reentrancy
   // issue I am not seeing yet), then there should at least be a clarifying
   // comment somewhere.
-  if (Optional<TemplateDeductionInfo*> Info = isSFINAEContext()) {
-    switch (DiagnosticIDs::getDiagnosticSFINAEResponse(
-              Diags.getCurrentDiagID())) {
+  if (Optional<TemplateDeductionInfo *> Info = isSFINAEContext()) {
+    switch (
+        DiagnosticIDs::getDiagnosticSFINAEResponse(Diags.getCurrentDiagID())) {
     case DiagnosticIDs::SFINAE_Report:
       // We'll report the diagnostic below.
       break;
@@ -1470,8 +1482,9 @@ void Sema::EmitCurrentDiagnostic(unsigne
       // template-deduction information.
       if (*Info && !(*Info)->hasSFINAEDiagnostic()) {
         Diagnostic DiagInfo(&Diags);
-        (*Info)->addSFINAEDiagnostic(DiagInfo.getLocation(),
-                       PartialDiagnostic(DiagInfo, Context.getDiagAllocator()));
+        (*Info)->addSFINAEDiagnostic(
+            DiagInfo.getLocation(),
+            PartialDiagnostic(DiagInfo, Context.getDiagAllocator()));
       }
 
       Diags.setLastDiagnosticIgnored(true);
@@ -1495,8 +1508,9 @@ void Sema::EmitCurrentDiagnostic(unsigne
       // template-deduction information.
       if (*Info && !(*Info)->hasSFINAEDiagnostic()) {
         Diagnostic DiagInfo(&Diags);
-        (*Info)->addSFINAEDiagnostic(DiagInfo.getLocation(),
-                       PartialDiagnostic(DiagInfo, Context.getDiagAllocator()));
+        (*Info)->addSFINAEDiagnostic(
+            DiagInfo.getLocation(),
+            PartialDiagnostic(DiagInfo, Context.getDiagAllocator()));
       }
 
       Diags.setLastDiagnosticIgnored(true);
@@ -1517,8 +1531,9 @@ void Sema::EmitCurrentDiagnostic(unsigne
       // template-deduction information;
       if (*Info) {
         Diagnostic DiagInfo(&Diags);
-        (*Info)->addSuppressedDiagnostic(DiagInfo.getLocation(),
-                       PartialDiagnostic(DiagInfo, Context.getDiagAllocator()));
+        (*Info)->addSuppressedDiagnostic(
+            DiagInfo.getLocation(),
+            PartialDiagnostic(DiagInfo, Context.getDiagAllocator()));
       }
 
       // Suppress this diagnostic.
@@ -1655,8 +1670,7 @@ public:
   }
 
   void checkVar(VarDecl *VD) {
-    assert(VD->isFileVarDecl() &&
-           "Should only check file-scope variables");
+    assert(VD->isFileVarDecl() && "Should only check file-scope variables");
     if (auto *Init = VD->getInit()) {
       auto DevTy = OMPDeclareTargetDeclAttr::getDeviceType(VD);
       bool IsDev = DevTy && (*DevTy == OMPDeclareTargetDeclAttr::DT_NoHost ||
@@ -2010,7 +2024,8 @@ void Sema::checkTypeSupport(QualType Ty,
 /// expansion loc.
 bool Sema::findMacroSpelling(SourceLocation &locref, StringRef name) {
   SourceLocation loc = locref;
-  if (!loc.isMacroID()) return false;
+  if (!loc.isMacroID())
+    return false;
 
   // There's no good way right now to look at the intermediate
   // expansions, so just jump to the expansion location.
@@ -2068,8 +2083,8 @@ void Sema::PushFunctionScope() {
 }
 
 void Sema::PushBlockScope(Scope *BlockScope, BlockDecl *Block) {
-  FunctionScopes.push_back(new BlockScopeInfo(getDiagnostics(),
-                                              BlockScope, Block));
+  FunctionScopes.push_back(
+      new BlockScopeInfo(getDiagnostics(), BlockScope, Block));
 }
 
 LambdaScopeInfo *Sema::PushLambdaScope() {
@@ -2144,10 +2159,9 @@ static void markEscapingByrefs(const Fun
       QualType CapType = BC.getVariable()->getType();
       if (CapType.hasNonTrivialToPrimitiveDestructCUnion() ||
           CapType.hasNonTrivialToPrimitiveCopyCUnion())
-        S.checkNonTrivialCUnion(BC.getVariable()->getType(),
-                                BD->getCaretLocation(),
-                                Sema::NTCUC_BlockCapture,
-                                Sema::NTCUK_Destruct|Sema::NTCUK_Copy);
+        S.checkNonTrivialCUnion(
+            BC.getVariable()->getType(), BD->getCaretLocation(),
+            Sema::NTCUC_BlockCapture, Sema::NTCUK_Destruct | Sema::NTCUK_Copy);
     }
   }
 
@@ -2194,8 +2208,8 @@ Sema::PopFunctionScopeInfo(const Analysi
   return Scope;
 }
 
-void Sema::PoppedFunctionScopeDeleter::
-operator()(sema::FunctionScopeInfo *Scope) const {
+void Sema::PoppedFunctionScopeDeleter::operator()(
+    sema::FunctionScopeInfo *Scope) const {
   // Stash the function scope for later reuse if it's for a normal function.
   if (Scope->isPlainFunction() && !Self->CachedFunctionScope)
     Self->CachedFunctionScope.reset(Scope);
@@ -2245,8 +2259,7 @@ BlockScopeInfo *Sema::getCurBlock() {
     return nullptr;
 
   auto CurBSI = dyn_cast<BlockScopeInfo>(FunctionScopes.back());
-  if (CurBSI && CurBSI->TheDecl &&
-      !CurBSI->TheDecl->Encloses(CurContext)) {
+  if (CurBSI && CurBSI->TheDecl && !CurBSI->TheDecl->Encloses(CurContext)) {
     // We have switched contexts due to template instantiation.
     assert(!CodeSynthesisContexts.empty());
     return nullptr;
@@ -2296,8 +2309,7 @@ LambdaScopeInfo *Sema::getCurLambda(bool
       return nullptr;
   }
   auto *CurLSI = dyn_cast<LambdaScopeInfo>(*I);
-  if (CurLSI && CurLSI->Lambda &&
-      !CurLSI->Lambda->Encloses(CurContext)) {
+  if (CurLSI && CurLSI->Lambda && !CurLSI->Lambda->Encloses(CurContext)) {
     // We have switched contexts due to template instantiation.
     assert(!CodeSynthesisContexts.empty());
     return nullptr;
@@ -2309,14 +2321,14 @@ LambdaScopeInfo *Sema::getCurLambda(bool
 // We have a generic lambda if we parsed auto parameters, or we have
 // an associated template parameter list.
 LambdaScopeInfo *Sema::getCurGenericLambda() {
-  if (LambdaScopeInfo *LSI =  getCurLambda()) {
-    return (LSI->TemplateParams.size() ||
-                    LSI->GLTemplateParameterList) ? LSI : nullptr;
+  if (LambdaScopeInfo *LSI = getCurLambda()) {
+    return (LSI->TemplateParams.size() || LSI->GLTemplateParameterList)
+               ? LSI
+               : nullptr;
   }
   return nullptr;
 }
 
-
 void Sema::ActOnComment(SourceRange Comment) {
   if (!LangOpts.RetainCommentsFromSystemHeaders &&
       SourceMgr.isInSystemHeader(Comment.getBegin()))
@@ -2337,8 +2349,8 @@ void Sema::ActOnComment(SourceRange Comm
       llvm_unreachable("if this is an almost Doxygen comment, "
                        "it should be ordinary");
     }
-    Diag(Comment.getBegin(), diag::warn_not_a_doxygen_trailing_member_comment) <<
-      FixItHint::CreateReplacement(MagicMarkerRange, MagicMarkerText);
+    Diag(Comment.getBegin(), diag::warn_not_a_doxygen_trailing_member_comment)
+        << FixItHint::CreateReplacement(MagicMarkerRange, MagicMarkerText);
   }
   Context.addComment(RC);
 }
@@ -2347,18 +2359,18 @@ void Sema::ActOnComment(SourceRange Comm
 ExternalSemaSource::~ExternalSemaSource() {}
 char ExternalSemaSource::ID;
 
-void ExternalSemaSource::ReadMethodPool(Selector Sel) { }
-void ExternalSemaSource::updateOutOfDateSelector(Selector Sel) { }
+void ExternalSemaSource::ReadMethodPool(Selector Sel) {}
+void ExternalSemaSource::updateOutOfDateSelector(Selector Sel) {}
 
 void ExternalSemaSource::ReadKnownNamespaces(
-                           SmallVectorImpl<NamespaceDecl *> &Namespaces) {
-}
+    SmallVectorImpl<NamespaceDecl *> &Namespaces) {}
 
 void ExternalSemaSource::ReadUndefinedButUsed(
     llvm::MapVector<NamedDecl *, SourceLocation> &Undefined) {}
 
-void ExternalSemaSource::ReadMismatchingDeleteExpressions(llvm::MapVector<
-    FieldDecl *, llvm::SmallVector<std::pair<SourceLocation, bool>, 4>> &) {}
+void ExternalSemaSource::ReadMismatchingDeleteExpressions(
+    llvm::MapVector<FieldDecl *,
+                    llvm::SmallVector<std::pair<SourceLocation, bool>, 4>> &) {}
 
 /// Figure out if an expression could be turned into a call.
 ///
@@ -2379,7 +2391,7 @@ bool Sema::tryExprAsCall(Expr &E, QualTy
   const OverloadExpr *Overloads = nullptr;
   bool IsMemExpr = false;
   if (E.getType() == Context.OverloadTy) {
-    OverloadExpr::FindResult FR = OverloadExpr::find(const_cast<Expr*>(&E));
+    OverloadExpr::FindResult FR = OverloadExpr::find(const_cast<Expr *>(&E));
 
     // Ignore overloads that are pointer-to-member constants.
     if (FR.HasFormOfMemberPointer)
@@ -2396,15 +2408,16 @@ bool Sema::tryExprAsCall(Expr &E, QualTy
 
   if (Overloads) {
     for (OverloadExpr::decls_iterator it = Overloads->decls_begin(),
-         DeclsEnd = Overloads->decls_end(); it != DeclsEnd; ++it) {
+                                      DeclsEnd = Overloads->decls_end();
+         it != DeclsEnd; ++it) {
       OverloadSet.addDecl(*it);
 
       // Check whether the function is a non-template, non-member which takes no
       // arguments.
       if (IsMemExpr)
         continue;
-      if (const FunctionDecl *OverloadDecl
-            = dyn_cast<FunctionDecl>((*it)->getUnderlyingDecl())) {
+      if (const FunctionDecl *OverloadDecl =
+              dyn_cast<FunctionDecl>((*it)->getUnderlyingDecl())) {
         if (OverloadDecl->getMinRequiredArguments() == 0) {
           if (!ZeroArgCallReturnTy.isNull() && !Ambiguous &&
               (!IsMV || !(OverloadDecl->isCPUDispatchMultiVersion() ||
@@ -2458,7 +2471,7 @@ bool Sema::tryExprAsCall(Expr &E, QualTy
     FunTy = ExprTy->getAs<FunctionType>();
 
   if (const FunctionProtoType *FPT =
-      dyn_cast_or_null<FunctionProtoType>(FunTy)) {
+          dyn_cast_or_null<FunctionProtoType>(FunTy)) {
     if (FPT->getNumParams() == 0)
       ZeroArgCallReturnTy = FunTy->getReturnType();
     return true;
@@ -2483,7 +2496,8 @@ static void noteOverloads(Sema &S, const
   unsigned ShownOverloads = 0;
   unsigned SuppressedOverloads = 0;
   for (UnresolvedSetImpl::iterator It = Overloads.begin(),
-       DeclsEnd = Overloads.end(); It != DeclsEnd; ++It) {
+                                   DeclsEnd = Overloads.end();
+       It != DeclsEnd; ++It) {
     if (ShownOverloads >= S.Diags.getNumOverloadCandidatesToShow()) {
       ++SuppressedOverloads;
       continue;
@@ -2504,7 +2518,7 @@ static void noteOverloads(Sema &S, const
 
   if (SuppressedOverloads)
     S.Diag(FinalNoteLoc, diag::note_ovl_too_many_candidates)
-      << SuppressedOverloads;
+        << SuppressedOverloads;
 }
 
 static void notePlausibleOverloads(Sema &S, SourceLocation Loc,
@@ -2515,7 +2529,8 @@ static void notePlausibleOverloads(Sema
 
   UnresolvedSet<2> PlausibleOverloads;
   for (OverloadExpr::decls_iterator It = Overloads.begin(),
-         DeclsEnd = Overloads.end(); It != DeclsEnd; ++It) {
+                                    DeclsEnd = Overloads.end();
+       It != DeclsEnd; ++It) {
     const FunctionDecl *OverloadDecl = cast<FunctionDecl>(*It);
     QualType OverloadResultTy = OverloadDecl->getReturnType();
     if (IsPlausibleResult(OverloadResultTy))
@@ -2530,10 +2545,8 @@ static void notePlausibleOverloads(Sema
 /// outside the call.
 static bool IsCallableWithAppend(Expr *E) {
   E = E->IgnoreImplicit();
-  return (!isa<CStyleCastExpr>(E) &&
-          !isa<UnaryOperator>(E) &&
-          !isa<BinaryOperator>(E) &&
-          !isa<CXXOperatorCallExpr>(E));
+  return (!isa<CStyleCastExpr>(E) && !isa<UnaryOperator>(E) &&
+          !isa<BinaryOperator>(E) && !isa<CXXOperatorCallExpr>(E));
 }
 
 static bool IsCPUDispatchCPUSpecificMultiVersion(const Expr *E) {
@@ -2586,7 +2599,8 @@ bool Sema::tryToRecoverWithCall(ExprResu
       return true;
     }
   }
-  if (!ForceComplain) return false;
+  if (!ForceComplain)
+    return false;
 
   bool IsMV = IsCPUDispatchCPUSpecificMultiVersion(E.get());
   Diag(Loc, PD) << /*not zero-arg*/ 0 << IsMV << Range;
@@ -2630,3 +2644,10 @@ const llvm::MapVector<FieldDecl *, Sema:
 Sema::getMismatchingDeleteExpressions() const {
   return DeleteExprs;
 }
+
+// Modified By Zeng-WCh
+// StmtResult Sema::ActOnPragmaLoopBound(uint64_t lower, uint64_t upper,
+//                                       SourceLocation Loc) {
+//   return new (Context) DeclStmt();
+// }
+// End Modification
\ No newline at end of file
diff --color -uprN clang-14.0.6.src/lib/Sema/SemaStmt.cpp clang-14.0.6.src.patched/lib/Sema/SemaStmt.cpp
--- clang-14.0.6.src/lib/Sema/SemaStmt.cpp	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/lib/Sema/SemaStmt.cpp	2024-11-12 13:24:23.357485188 +0800
@@ -59,7 +59,6 @@ StmtResult Sema::ActOnExprStmt(ExprResul
   return StmtResult(FE.getAs<Stmt>());
 }
 
-
 StmtResult Sema::ActOnExprStmtError() {
   DiscardCleanupsInEvaluationContext();
   return StmtError();
@@ -75,7 +74,8 @@ StmtResult Sema::ActOnDeclStmt(DeclGroup
   DeclGroupRef DG = dg.get();
 
   // If we have an invalid decl, just return an error.
-  if (DG.isNull()) return StmtError();
+  if (DG.isNull())
+    return StmtError();
 
   return new (Context) DeclStmt(DG, StartLoc, EndLoc);
 }
@@ -181,17 +181,17 @@ static bool DiagnoseUnusedComparison(Sem
     return false;
 
   S.Diag(Loc, diag::warn_unused_comparison)
-    << (unsigned)Kind << E->getSourceRange();
+      << (unsigned)Kind << E->getSourceRange();
 
   // If the LHS is a plausible entity to assign to, provide a fixit hint to
   // correct common typos.
   if (CanAssign) {
     if (Kind == Inequality)
       S.Diag(Loc, diag::note_inequality_comparison_to_or_assign)
-        << FixItHint::CreateReplacement(Loc, "|=");
+          << FixItHint::CreateReplacement(Loc, "|=");
     else if (Kind == Equality)
       S.Diag(Loc, diag::note_equality_comparison_to_assign)
-        << FixItHint::CreateReplacement(Loc, "=");
+          << FixItHint::CreateReplacement(Loc, "=");
   }
 
   return true;
@@ -211,8 +211,8 @@ static bool DiagnoseNoDiscard(Sema &S, c
   }
 
   if (IsCtor)
-    return S.Diag(Loc, diag::warn_unused_constructor_msg) << A << Msg << R1
-                                                          << R2;
+    return S.Diag(Loc, diag::warn_unused_constructor_msg)
+           << A << Msg << R1 << R2;
   return S.Diag(Loc, diag::warn_unused_result_msg) << A << Msg << R1 << R2;
 }
 
@@ -235,9 +235,8 @@ void Sema::DiagnoseUnusedExprResult(cons
   // expression is a call to a function with the warn_unused_result attribute,
   // we warn no matter the location. Because of the order in which the various
   // checks need to happen, we factor out the macro-related test here.
-  bool ShouldSuppress =
-      SourceMgr.isMacroBodyExpansion(ExprLoc) ||
-      SourceMgr.isInSystemMacro(ExprLoc);
+  bool ShouldSuppress = SourceMgr.isMacroBodyExpansion(ExprLoc) ||
+                        SourceMgr.isInSystemMacro(ExprLoc);
 
   const Expr *WarnExpr;
   SourceLocation Loc;
@@ -282,8 +281,9 @@ void Sema::DiagnoseUnusedExprResult(cons
     if (E->getType()->isVoidType())
       return;
 
-    if (DiagnoseNoDiscard(*this, cast_or_null<WarnUnusedResultAttr>(
-                                     CE->getUnusedResultAttr(Context)),
+    if (DiagnoseNoDiscard(*this,
+                          cast_or_null<WarnUnusedResultAttr>(
+                              CE->getUnusedResultAttr(Context)),
                           Loc, R1, R2, /*isCtor=*/false))
       return;
 
@@ -343,8 +343,8 @@ void Sema::DiagnoseUnusedExprResult(cons
       DiagID = diag::warn_unused_container_subscript_expr;
     else
       DiagID = diag::warn_unused_property_expr;
-  } else if (const CXXFunctionalCastExpr *FC
-                                       = dyn_cast<CXXFunctionalCastExpr>(E)) {
+  } else if (const CXXFunctionalCastExpr *FC =
+                 dyn_cast<CXXFunctionalCastExpr>(E)) {
     const Expr *E = FC->getSubExpr();
     if (const CXXBindTemporaryExpr *TE = dyn_cast<CXXBindTemporaryExpr>(E))
       E = TE->getSubExpr();
@@ -365,7 +365,7 @@ void Sema::DiagnoseUnusedExprResult(cons
       PointerTypeLoc TL = TI->getTypeLoc().castAs<PointerTypeLoc>();
 
       Diag(Loc, diag::warn_unused_voidptr)
-        << FixItHint::CreateRemoval(TL.getStarLoc());
+          << FixItHint::CreateRemoval(TL.getStarLoc());
       return;
     }
   }
@@ -398,9 +398,7 @@ void Sema::ActOnAfterCompoundStatementLe
   }
 }
 
-void Sema::ActOnFinishOfCompoundStmt() {
-  PopCompoundScope();
-}
+void Sema::ActOnFinishOfCompoundStmt() { PopCompoundScope(); }
 
 sema::CompoundScopeInfo &Sema::getCurCompoundScope() const {
   return getCurFunction()->CompoundScopes.back();
@@ -445,8 +443,7 @@ StmtResult Sema::ActOnCompoundStmt(Sourc
   return CompoundStmt::Create(Context, Elts, L, R);
 }
 
-ExprResult
-Sema::ActOnCaseExpr(SourceLocation CaseLoc, ExprResult Val) {
+ExprResult Sema::ActOnCaseExpr(SourceLocation CaseLoc, ExprResult Val) {
   if (!Val.get())
     return Val;
 
@@ -459,8 +456,7 @@ Sema::ActOnCaseExpr(SourceLocation CaseL
     return ActOnFinishFullExpr(Val.get(), Val.get()->getExprLoc(), false,
                                getLangOpts().CPlusPlus11);
 
-  Expr *CondExpr =
-      getCurFunction()->SwitchStack.back().getPointer()->getCond();
+  Expr *CondExpr = getCurFunction()->SwitchStack.back().getPointer()->getCond();
   if (!CondExpr)
     return ExprError();
   QualType CondType = CondExpr->getType();
@@ -497,10 +493,9 @@ Sema::ActOnCaseExpr(SourceLocation CaseL
   return Converted;
 }
 
-StmtResult
-Sema::ActOnCaseStmt(SourceLocation CaseLoc, ExprResult LHSVal,
-                    SourceLocation DotDotDotLoc, ExprResult RHSVal,
-                    SourceLocation ColonLoc) {
+StmtResult Sema::ActOnCaseStmt(SourceLocation CaseLoc, ExprResult LHSVal,
+                               SourceLocation DotDotDotLoc, ExprResult RHSVal,
+                               SourceLocation ColonLoc) {
   assert((LHSVal.isInvalid() || LHSVal.get()) && "missing LHS value");
   assert((DotDotDotLoc.isInvalid() ? RHSVal.isUnset()
                                    : RHSVal.isInvalid() || RHSVal.get()) &&
@@ -516,8 +511,8 @@ Sema::ActOnCaseStmt(SourceLocation CaseL
     return StmtError();
   }
 
-  auto *CS = CaseStmt::Create(Context, LHSVal.get(), RHSVal.get(),
-                              CaseLoc, DotDotDotLoc, ColonLoc);
+  auto *CS = CaseStmt::Create(Context, LHSVal.get(), RHSVal.get(), CaseLoc,
+                              DotDotDotLoc, ColonLoc);
   getCurFunction()->SwitchStack.back().getPointer()->addSwitchCase(CS);
   return CS;
 }
@@ -527,9 +522,9 @@ void Sema::ActOnCaseStmtBody(Stmt *S, St
   cast<CaseStmt>(S)->setSubStmt(SubStmt);
 }
 
-StmtResult
-Sema::ActOnDefaultStmt(SourceLocation DefaultLoc, SourceLocation ColonLoc,
-                       Stmt *SubStmt, Scope *CurScope) {
+StmtResult Sema::ActOnDefaultStmt(SourceLocation DefaultLoc,
+                                  SourceLocation ColonLoc, Stmt *SubStmt,
+                                  Scope *CurScope) {
   if (getCurFunction()->SwitchStack.empty()) {
     Diag(DefaultLoc, diag::err_default_not_in_switch);
     return SubStmt;
@@ -540,9 +535,8 @@ Sema::ActOnDefaultStmt(SourceLocation De
   return DS;
 }
 
-StmtResult
-Sema::ActOnLabelStmt(SourceLocation IdentLoc, LabelDecl *TheDecl,
-                     SourceLocation ColonLoc, Stmt *SubStmt) {
+StmtResult Sema::ActOnLabelStmt(SourceLocation IdentLoc, LabelDecl *TheDecl,
+                                SourceLocation ColonLoc, Stmt *SubStmt) {
   // If the label was multiply defined, reject it now.
   if (TheDecl->getStmt()) {
     Diag(IdentLoc, diag::err_redefinition_of_label) << TheDecl->getDeclName();
@@ -856,6 +850,7 @@ namespace {
 class CommaVisitor : public EvaluatedExprVisitor<CommaVisitor> {
   typedef EvaluatedExprVisitor<CommaVisitor> Inherited;
   Sema &SemaRef;
+
 public:
   CommaVisitor(Sema &SemaRef) : Inherited(SemaRef.Context), SemaRef(SemaRef) {}
   void VisitBinaryOperator(BinaryOperator *E) {
@@ -864,7 +859,7 @@ public:
     EvaluatedExprVisitor<CommaVisitor>::VisitBinaryOperator(E);
   }
 };
-}
+} // namespace
 
 StmtResult Sema::ActOnIfStmt(SourceLocation IfLoc,
                              IfStatementKind StatementKind,
@@ -958,26 +953,26 @@ StmtResult Sema::BuildIfStmt(SourceLocat
 }
 
 namespace {
-  struct CaseCompareFunctor {
-    bool operator()(const std::pair<llvm::APSInt, CaseStmt*> &LHS,
-                    const llvm::APSInt &RHS) {
-      return LHS.first < RHS;
-    }
-    bool operator()(const std::pair<llvm::APSInt, CaseStmt*> &LHS,
-                    const std::pair<llvm::APSInt, CaseStmt*> &RHS) {
-      return LHS.first < RHS.first;
-    }
-    bool operator()(const llvm::APSInt &LHS,
-                    const std::pair<llvm::APSInt, CaseStmt*> &RHS) {
-      return LHS < RHS.first;
-    }
-  };
-}
+struct CaseCompareFunctor {
+  bool operator()(const std::pair<llvm::APSInt, CaseStmt *> &LHS,
+                  const llvm::APSInt &RHS) {
+    return LHS.first < RHS;
+  }
+  bool operator()(const std::pair<llvm::APSInt, CaseStmt *> &LHS,
+                  const std::pair<llvm::APSInt, CaseStmt *> &RHS) {
+    return LHS.first < RHS.first;
+  }
+  bool operator()(const llvm::APSInt &LHS,
+                  const std::pair<llvm::APSInt, CaseStmt *> &RHS) {
+    return LHS < RHS.first;
+  }
+};
+} // namespace
 
 /// CmpCaseVals - Comparison predicate for sorting case values.
 ///
-static bool CmpCaseVals(const std::pair<llvm::APSInt, CaseStmt*>& lhs,
-                        const std::pair<llvm::APSInt, CaseStmt*>& rhs) {
+static bool CmpCaseVals(const std::pair<llvm::APSInt, CaseStmt *> &lhs,
+                        const std::pair<llvm::APSInt, CaseStmt *> &rhs) {
   if (lhs.first < rhs.first)
     return true;
 
@@ -989,17 +984,16 @@ static bool CmpCaseVals(const std::pair<
 
 /// CmpEnumVals - Comparison predicate for sorting enumeration values.
 ///
-static bool CmpEnumVals(const std::pair<llvm::APSInt, EnumConstantDecl*>& lhs,
-                        const std::pair<llvm::APSInt, EnumConstantDecl*>& rhs)
-{
+static bool
+CmpEnumVals(const std::pair<llvm::APSInt, EnumConstantDecl *> &lhs,
+            const std::pair<llvm::APSInt, EnumConstantDecl *> &rhs) {
   return lhs.first < rhs.first;
 }
 
 /// EqEnumVals - Comparison preficate for uniqing enumeration values.
 ///
-static bool EqEnumVals(const std::pair<llvm::APSInt, EnumConstantDecl*>& lhs,
-                       const std::pair<llvm::APSInt, EnumConstantDecl*>& rhs)
-{
+static bool EqEnumVals(const std::pair<llvm::APSInt, EnumConstantDecl *> &lhs,
+                       const std::pair<llvm::APSInt, EnumConstantDecl *> &rhs) {
   return lhs.first == rhs.first;
 }
 
@@ -1009,7 +1003,8 @@ static QualType GetTypeBeforeIntegralPro
   if (const auto *FE = dyn_cast<FullExpr>(E))
     E = FE->getSubExpr();
   while (const auto *ImpCast = dyn_cast<ImplicitCastExpr>(E)) {
-    if (ImpCast->getCastKind() != CK_IntegralCast) break;
+    if (ImpCast->getCastKind() != CK_IntegralCast)
+      break;
     E = ImpCast->getSubExpr();
   }
   return E->getType();
@@ -1021,7 +1016,7 @@ ExprResult Sema::CheckSwitchCondition(So
 
   public:
     SwitchConvertDiagnoser(Expr *Cond)
-        : ICEConvertDiagnoser(/*AllowScopedEnumerations*/true, false, true),
+        : ICEConvertDiagnoser(/*AllowScopedEnumerations*/ true, false, true),
           Cond(Cond) {}
 
     SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,
@@ -1029,21 +1024,22 @@ ExprResult Sema::CheckSwitchCondition(So
       return S.Diag(Loc, diag::err_typecheck_statement_requires_integer) << T;
     }
 
-    SemaDiagnosticBuilder diagnoseIncomplete(
-        Sema &S, SourceLocation Loc, QualType T) override {
+    SemaDiagnosticBuilder diagnoseIncomplete(Sema &S, SourceLocation Loc,
+                                             QualType T) override {
       return S.Diag(Loc, diag::err_switch_incomplete_class_type)
-               << T << Cond->getSourceRange();
+             << T << Cond->getSourceRange();
     }
 
-    SemaDiagnosticBuilder diagnoseExplicitConv(
-        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) override {
+    SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S, SourceLocation Loc,
+                                               QualType T,
+                                               QualType ConvTy) override {
       return S.Diag(Loc, diag::err_switch_explicit_conversion) << T << ConvTy;
     }
 
-    SemaDiagnosticBuilder noteExplicitConv(
-        Sema &S, CXXConversionDecl *Conv, QualType ConvTy) override {
+    SemaDiagnosticBuilder noteExplicitConv(Sema &S, CXXConversionDecl *Conv,
+                                           QualType ConvTy) override {
       return S.Diag(Conv->getLocation(), diag::note_switch_conversion)
-        << ConvTy->isEnumeralType() << ConvTy;
+             << ConvTy->isEnumeralType() << ConvTy;
     }
 
     SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,
@@ -1051,14 +1047,15 @@ ExprResult Sema::CheckSwitchCondition(So
       return S.Diag(Loc, diag::err_switch_multiple_conversions) << T;
     }
 
-    SemaDiagnosticBuilder noteAmbiguous(
-        Sema &S, CXXConversionDecl *Conv, QualType ConvTy) override {
+    SemaDiagnosticBuilder noteAmbiguous(Sema &S, CXXConversionDecl *Conv,
+                                        QualType ConvTy) override {
       return S.Diag(Conv->getLocation(), diag::note_switch_conversion)
-      << ConvTy->isEnumeralType() << ConvTy;
+             << ConvTy->isEnumeralType() << ConvTy;
     }
 
-    SemaDiagnosticBuilder diagnoseConversion(
-        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) override {
+    SemaDiagnosticBuilder diagnoseConversion(Sema &S, SourceLocation Loc,
+                                             QualType T,
+                                             QualType ConvTy) override {
       llvm_unreachable("conversion functions are permitted");
     }
   } SwitchDiagnoser(Cond);
@@ -1135,17 +1132,16 @@ static void checkCaseValue(Sema &S, Sour
     // type versus "switch expression cannot have this value". Use proper
     // IntRange checking rather than just looking at the unpromoted type here.
     if (ConvVal != Val)
-      S.Diag(Loc, diag::warn_case_value_overflow) << toString(Val, 10)
-                                                  << toString(ConvVal, 10);
+      S.Diag(Loc, diag::warn_case_value_overflow)
+          << toString(Val, 10) << toString(ConvVal, 10);
   }
 }
 
-typedef SmallVector<std::pair<llvm::APSInt, EnumConstantDecl*>, 64> EnumValsTy;
+typedef SmallVector<std::pair<llvm::APSInt, EnumConstantDecl *>, 64> EnumValsTy;
 
 /// Returns true if we should emit a diagnostic about this case expression not
 /// being a part of the enum used in the switch controlling expression.
-static bool ShouldDiagnoseSwitchCaseNotInEnum(const Sema &S,
-                                              const EnumDecl *ED,
+static bool ShouldDiagnoseSwitchCaseNotInEnum(const Sema &S, const EnumDecl *ED,
                                               const Expr *CaseExpr,
                                               EnumValsTy::iterator &EI,
                                               EnumValsTy::iterator &EIEnd,
@@ -1202,9 +1198,8 @@ static void checkEnumTypesInSwitchStmt(S
       << Case->getSourceRange();
 }
 
-StmtResult
-Sema::ActOnFinishSwitchStmt(SourceLocation SwitchLoc, Stmt *Switch,
-                            Stmt *BodyStmt) {
+StmtResult Sema::ActOnFinishSwitchStmt(SourceLocation SwitchLoc, Stmt *Switch,
+                                       Stmt *BodyStmt) {
   SwitchStmt *SS = cast<SwitchStmt>(Switch);
   bool CaseListIsIncomplete = getCurFunction()->SwitchStack.back().getInt();
   assert(SS == getCurFunction()->SwitchStack.back().getPointer() &&
@@ -1212,11 +1207,13 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
 
   getCurFunction()->SwitchStack.pop_back();
 
-  if (!BodyStmt) return StmtError();
+  if (!BodyStmt)
+    return StmtError();
   SS->setBody(BodyStmt, SwitchLoc);
 
   Expr *CondExpr = SS->getCond();
-  if (!CondExpr) return StmtError();
+  if (!CondExpr)
+    return StmtError();
 
   QualType CondType = CondExpr->getType();
 
@@ -1233,8 +1230,8 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
 
   // Get the bitwidth of the switched-on value after promotions. We must
   // convert the integer case values to this width before comparison.
-  bool HasDependentValue
-    = CondExpr->isTypeDependent() || CondExpr->isValueDependent();
+  bool HasDependentValue =
+      CondExpr->isTypeDependent() || CondExpr->isValueDependent();
   unsigned CondWidth = HasDependentValue ? 0 : Context.getIntWidth(CondType);
   bool CondIsSigned = CondType->isSignedIntegerOrEnumerationType();
 
@@ -1242,19 +1239,19 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
   // warning purposes.
   // FIXME: Grab an IntRange for the condition rather than using the unpromoted
   // type.
-  unsigned CondWidthBeforePromotion
-    = HasDependentValue ? 0 : Context.getIntWidth(CondTypeBeforePromotion);
-  bool CondIsSignedBeforePromotion
-    = CondTypeBeforePromotion->isSignedIntegerOrEnumerationType();
+  unsigned CondWidthBeforePromotion =
+      HasDependentValue ? 0 : Context.getIntWidth(CondTypeBeforePromotion);
+  bool CondIsSignedBeforePromotion =
+      CondTypeBeforePromotion->isSignedIntegerOrEnumerationType();
 
   // Accumulate all of the case values in a vector so that we can sort them
   // and detect duplicates.  This vector contains the APInt for the case after
   // it has been converted to the condition type.
-  typedef SmallVector<std::pair<llvm::APSInt, CaseStmt*>, 64> CaseValsTy;
+  typedef SmallVector<std::pair<llvm::APSInt, CaseStmt *>, 64> CaseValsTy;
   CaseValsTy CaseVals;
 
   // Keep track of any GNU case ranges we see.  The APSInt is the low value.
-  typedef std::vector<std::pair<llvm::APSInt, CaseStmt*> > CaseRangesTy;
+  typedef std::vector<std::pair<llvm::APSInt, CaseStmt *>> CaseRangesTy;
   CaseRangesTy CaseRanges;
 
   DefaultStmt *TheDefaultStmt = nullptr;
@@ -1324,8 +1321,8 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
     bool HasConstantCond = false;
     if (!TheDefaultStmt) {
       Expr::EvalResult Result;
-      HasConstantCond = CondExpr->EvaluateAsInt(Result, Context,
-                                                Expr::SE_AllowSideEffects);
+      HasConstantCond =
+          CondExpr->EvaluateAsInt(Result, Context, Expr::SE_AllowSideEffects);
       if (Result.Val.isInt())
         ConstantCondValue = Result.Val.getInt();
       assert(!HasConstantCond ||
@@ -1339,15 +1336,14 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
 
     if (!CaseVals.empty()) {
       for (unsigned i = 0, e = CaseVals.size(); i != e; ++i) {
-        if (ShouldCheckConstantCond &&
-            CaseVals[i].first == ConstantCondValue)
+        if (ShouldCheckConstantCond && CaseVals[i].first == ConstantCondValue)
           ShouldCheckConstantCond = false;
 
-        if (i != 0 && CaseVals[i].first == CaseVals[i-1].first) {
+        if (i != 0 && CaseVals[i].first == CaseVals[i - 1].first) {
           // If we have a duplicate, report it.
           // First, determine if either case value has a name
           StringRef PrevString, CurrString;
-          Expr *PrevCase = CaseVals[i-1].second->getLHS()->IgnoreParenCasts();
+          Expr *PrevCase = CaseVals[i - 1].second->getLHS()->IgnoreParenCasts();
           Expr *CurrCase = CaseVals[i].second->getLHS()->IgnoreParenCasts();
           if (DeclRefExpr *DeclRef = dyn_cast<DeclRefExpr>(PrevCase)) {
             PrevString = DeclRef->getDecl()->getName();
@@ -1356,7 +1352,7 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
             CurrString = DeclRef->getDecl()->getName();
           }
           SmallString<16> CaseValStr;
-          CaseVals[i-1].first.toString(CaseValStr);
+          CaseVals[i - 1].first.toString(CaseValStr);
 
           if (PrevString == CurrString)
             Diag(CaseVals[i].second->getLHS()->getBeginLoc(),
@@ -1408,14 +1404,13 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
         if (LoVal > HiVal) {
           Diag(CR->getLHS()->getBeginLoc(), diag::warn_case_empty_range)
               << SourceRange(CR->getLHS()->getBeginLoc(), Hi->getEndLoc());
-          CaseRanges.erase(CaseRanges.begin()+i);
+          CaseRanges.erase(CaseRanges.begin() + i);
           --i;
           --e;
           continue;
         }
 
-        if (ShouldCheckConstantCond &&
-            LoVal <= ConstantCondValue &&
+        if (ShouldCheckConstantCond && LoVal <= ConstantCondValue &&
             ConstantCondValue <= HiVal)
           ShouldCheckConstantCond = false;
 
@@ -1440,22 +1435,22 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
         CaseValsTy::iterator I =
             llvm::lower_bound(CaseVals, CRLo, CaseCompareFunctor());
         if (I != CaseVals.end() && I->first < CRHi) {
-          OverlapVal  = I->first;   // Found overlap with scalar.
+          OverlapVal = I->first; // Found overlap with scalar.
           OverlapStmt = I->second;
         }
 
         // Find the smallest value bigger than the upper bound.
         I = std::upper_bound(I, CaseVals.end(), CRHi, CaseCompareFunctor());
-        if (I != CaseVals.begin() && (I-1)->first >= CRLo) {
-          OverlapVal  = (I-1)->first;      // Found overlap with scalar.
-          OverlapStmt = (I-1)->second;
+        if (I != CaseVals.begin() && (I - 1)->first >= CRLo) {
+          OverlapVal = (I - 1)->first; // Found overlap with scalar.
+          OverlapStmt = (I - 1)->second;
         }
 
         // Check to see if this case stmt overlaps with the subsequent
         // case range.
-        if (i && CRLo <= HiVals[i-1]) {
-          OverlapVal  = HiVals[i-1];       // Found overlap with range.
-          OverlapStmt = CaseRanges[i-1].second;
+        if (i && CRLo <= HiVals[i - 1]) {
+          OverlapVal = HiVals[i - 1]; // Found overlap with range.
+          OverlapStmt = CaseRanges[i - 1].second;
         }
 
         if (OverlapStmt) {
@@ -1477,8 +1472,7 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
       // TODO: it would be nice if we printed enums as enums, chars as
       // chars, etc.
       Diag(CondExpr->getExprLoc(), diag::warn_missing_case_for_condition)
-        << toString(ConstantCondValue, 10)
-        << CondExpr->getSourceRange();
+          << toString(ConstantCondValue, 10) << CondExpr->getSourceRange();
     }
 
     // Check to see if switch is over an Enum and handles all of its
@@ -1503,38 +1497,37 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
         EnumVals.push_back(std::make_pair(Val, EDI));
       }
       llvm::stable_sort(EnumVals, CmpEnumVals);
-      auto EI = EnumVals.begin(), EIEnd =
-        std::unique(EnumVals.begin(), EnumVals.end(), EqEnumVals);
+      auto EI = EnumVals.begin(),
+           EIEnd = std::unique(EnumVals.begin(), EnumVals.end(), EqEnumVals);
 
       // See which case values aren't in enum.
       for (CaseValsTy::const_iterator CI = CaseVals.begin();
-          CI != CaseVals.end(); CI++) {
+           CI != CaseVals.end(); CI++) {
         Expr *CaseExpr = CI->second->getLHS();
         if (ShouldDiagnoseSwitchCaseNotInEnum(*this, ED, CaseExpr, EI, EIEnd,
                                               CI->first))
           Diag(CaseExpr->getExprLoc(), diag::warn_not_in_enum)
-            << CondTypeBeforePromotion;
+              << CondTypeBeforePromotion;
       }
 
       // See which of case ranges aren't in enum
       EI = EnumVals.begin();
       for (CaseRangesTy::const_iterator RI = CaseRanges.begin();
-          RI != CaseRanges.end(); RI++) {
+           RI != CaseRanges.end(); RI++) {
         Expr *CaseExpr = RI->second->getLHS();
         if (ShouldDiagnoseSwitchCaseNotInEnum(*this, ED, CaseExpr, EI, EIEnd,
                                               RI->first))
           Diag(CaseExpr->getExprLoc(), diag::warn_not_in_enum)
-            << CondTypeBeforePromotion;
+              << CondTypeBeforePromotion;
 
-        llvm::APSInt Hi =
-          RI->second->getRHS()->EvaluateKnownConstInt(Context);
+        llvm::APSInt Hi = RI->second->getRHS()->EvaluateKnownConstInt(Context);
         AdjustAPSInt(Hi, CondWidth, CondIsSigned);
 
         CaseExpr = RI->second->getRHS();
         if (ShouldDiagnoseSwitchCaseNotInEnum(*this, ED, CaseExpr, EI, EIEnd,
                                               Hi))
           Diag(CaseExpr->getExprLoc(), diag::warn_not_in_enum)
-            << CondTypeBeforePromotion;
+              << CondTypeBeforePromotion;
       }
 
       // Check which enum vals aren't in switch
@@ -1542,7 +1535,7 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
       auto RI = CaseRanges.begin();
       bool hasCasesNotInSwitch = false;
 
-      SmallVector<DeclarationName,8> UnhandledNames;
+      SmallVector<DeclarationName, 8> UnhandledNames;
 
       for (EI = EnumVals.begin(); EI != EIEnd; EI++) {
         // Don't warn about omitted unavailable EnumConstantDecls.
@@ -1572,7 +1565,7 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
         // Drop unneeded case ranges
         for (; RI != CaseRanges.end(); RI++) {
           llvm::APSInt Hi =
-            RI->second->getRHS()->EvaluateKnownConstInt(Context);
+              RI->second->getRHS()->EvaluateKnownConstInt(Context);
           AdjustAPSInt(Hi, CondWidth, CondIsSigned);
           if (EI->first <= Hi)
             break;
@@ -1616,9 +1609,8 @@ Sema::ActOnFinishSwitchStmt(SourceLocati
   return SS;
 }
 
-void
-Sema::DiagnoseAssignmentEnum(QualType DstType, QualType SrcType,
-                             Expr *SrcExpr) {
+void Sema::DiagnoseAssignmentEnum(QualType DstType, QualType SrcType,
+                                  Expr *SrcExpr) {
   if (Diags.isIgnored(diag::warn_not_in_enum_assignment, SrcExpr->getExprLoc()))
     return;
 
@@ -1641,7 +1633,7 @@ Sema::DiagnoseAssignmentEnum(QualType Ds
         if (ED->hasAttr<FlagEnumAttr>()) {
           if (!IsValueInFlagEnum(ED, RhsVal, true))
             Diag(SrcExpr->getExprLoc(), diag::warn_not_in_enum_assignment)
-              << DstType.getUnqualifiedType();
+                << DstType.getUnqualifiedType();
         } else {
           typedef SmallVector<std::pair<llvm::APSInt, EnumConstantDecl *>, 64>
               EnumValsTy;
@@ -1693,10 +1685,9 @@ StmtResult Sema::ActOnWhileStmt(SourceLo
                            WhileLoc, LParenLoc, RParenLoc);
 }
 
-StmtResult
-Sema::ActOnDoStmt(SourceLocation DoLoc, Stmt *Body,
-                  SourceLocation WhileLoc, SourceLocation CondLParen,
-                  Expr *Cond, SourceLocation CondRParen) {
+StmtResult Sema::ActOnDoStmt(SourceLocation DoLoc, Stmt *Body,
+                             SourceLocation WhileLoc, SourceLocation CondLParen,
+                             Expr *Cond, SourceLocation CondRParen) {
   assert(Cond && "ActOnDoStmt(): missing expression");
 
   CheckBreakContinueBinding(Cond);
@@ -1719,389 +1710,388 @@ Sema::ActOnDoStmt(SourceLocation DoLoc,
 }
 
 namespace {
-  // Use SetVector since the diagnostic cares about the ordering of the Decl's.
-  using DeclSetVector =
-      llvm::SetVector<VarDecl *, llvm::SmallVector<VarDecl *, 8>,
-                      llvm::SmallPtrSet<VarDecl *, 8>>;
-
-  // This visitor will traverse a conditional statement and store all
-  // the evaluated decls into a vector.  Simple is set to true if none
-  // of the excluded constructs are used.
-  class DeclExtractor : public EvaluatedExprVisitor<DeclExtractor> {
-    DeclSetVector &Decls;
-    SmallVectorImpl<SourceRange> &Ranges;
-    bool Simple;
-  public:
-    typedef EvaluatedExprVisitor<DeclExtractor> Inherited;
+// Use SetVector since the diagnostic cares about the ordering of the Decl's.
+using DeclSetVector =
+    llvm::SetVector<VarDecl *, llvm::SmallVector<VarDecl *, 8>,
+                    llvm::SmallPtrSet<VarDecl *, 8>>;
+
+// This visitor will traverse a conditional statement and store all
+// the evaluated decls into a vector.  Simple is set to true if none
+// of the excluded constructs are used.
+class DeclExtractor : public EvaluatedExprVisitor<DeclExtractor> {
+  DeclSetVector &Decls;
+  SmallVectorImpl<SourceRange> &Ranges;
+  bool Simple;
 
-    DeclExtractor(Sema &S, DeclSetVector &Decls,
-                  SmallVectorImpl<SourceRange> &Ranges) :
-        Inherited(S.Context),
-        Decls(Decls),
-        Ranges(Ranges),
-        Simple(true) {}
+public:
+  typedef EvaluatedExprVisitor<DeclExtractor> Inherited;
 
-    bool isSimple() { return Simple; }
+  DeclExtractor(Sema &S, DeclSetVector &Decls,
+                SmallVectorImpl<SourceRange> &Ranges)
+      : Inherited(S.Context), Decls(Decls), Ranges(Ranges), Simple(true) {}
 
-    // Replaces the method in EvaluatedExprVisitor.
-    void VisitMemberExpr(MemberExpr* E) {
-      Simple = false;
-    }
+  bool isSimple() { return Simple; }
 
-    // Any Stmt not explicitly listed will cause the condition to be marked
-    // complex.
-    void VisitStmt(Stmt *S) { Simple = false; }
+  // Replaces the method in EvaluatedExprVisitor.
+  void VisitMemberExpr(MemberExpr *E) { Simple = false; }
 
-    void VisitBinaryOperator(BinaryOperator *E) {
-      Visit(E->getLHS());
-      Visit(E->getRHS());
-    }
+  // Any Stmt not explicitly listed will cause the condition to be marked
+  // complex.
+  void VisitStmt(Stmt *S) { Simple = false; }
+
+  void VisitBinaryOperator(BinaryOperator *E) {
+    Visit(E->getLHS());
+    Visit(E->getRHS());
+  }
 
-    void VisitCastExpr(CastExpr *E) {
+  void VisitCastExpr(CastExpr *E) { Visit(E->getSubExpr()); }
+
+  void VisitUnaryOperator(UnaryOperator *E) {
+    // Skip checking conditionals with derefernces.
+    if (E->getOpcode() == UO_Deref)
+      Simple = false;
+    else
       Visit(E->getSubExpr());
-    }
+  }
 
-    void VisitUnaryOperator(UnaryOperator *E) {
-      // Skip checking conditionals with derefernces.
-      if (E->getOpcode() == UO_Deref)
-        Simple = false;
-      else
-        Visit(E->getSubExpr());
+  void VisitConditionalOperator(ConditionalOperator *E) {
+    Visit(E->getCond());
+    Visit(E->getTrueExpr());
+    Visit(E->getFalseExpr());
+  }
+
+  void VisitParenExpr(ParenExpr *E) { Visit(E->getSubExpr()); }
+
+  void VisitBinaryConditionalOperator(BinaryConditionalOperator *E) {
+    Visit(E->getOpaqueValue()->getSourceExpr());
+    Visit(E->getFalseExpr());
+  }
+
+  void VisitIntegerLiteral(IntegerLiteral *E) {}
+  void VisitFloatingLiteral(FloatingLiteral *E) {}
+  void VisitCXXBoolLiteralExpr(CXXBoolLiteralExpr *E) {}
+  void VisitCharacterLiteral(CharacterLiteral *E) {}
+  void VisitGNUNullExpr(GNUNullExpr *E) {}
+  void VisitImaginaryLiteral(ImaginaryLiteral *E) {}
+
+  void VisitDeclRefExpr(DeclRefExpr *E) {
+    VarDecl *VD = dyn_cast<VarDecl>(E->getDecl());
+    if (!VD) {
+      // Don't allow unhandled Decl types.
+      Simple = false;
+      return;
     }
 
-    void VisitConditionalOperator(ConditionalOperator *E) {
-      Visit(E->getCond());
-      Visit(E->getTrueExpr());
-      Visit(E->getFalseExpr());
-    }
+    Ranges.push_back(E->getSourceRange());
 
-    void VisitParenExpr(ParenExpr *E) {
-      Visit(E->getSubExpr());
-    }
+    Decls.insert(VD);
+  }
 
-    void VisitBinaryConditionalOperator(BinaryConditionalOperator *E) {
-      Visit(E->getOpaqueValue()->getSourceExpr());
-      Visit(E->getFalseExpr());
-    }
-
-    void VisitIntegerLiteral(IntegerLiteral *E) { }
-    void VisitFloatingLiteral(FloatingLiteral *E) { }
-    void VisitCXXBoolLiteralExpr(CXXBoolLiteralExpr *E) { }
-    void VisitCharacterLiteral(CharacterLiteral *E) { }
-    void VisitGNUNullExpr(GNUNullExpr *E) { }
-    void VisitImaginaryLiteral(ImaginaryLiteral *E) { }
-
-    void VisitDeclRefExpr(DeclRefExpr *E) {
-      VarDecl *VD = dyn_cast<VarDecl>(E->getDecl());
-      if (!VD) {
-        // Don't allow unhandled Decl types.
-        Simple = false;
-        return;
-      }
+}; // end class DeclExtractor
 
-      Ranges.push_back(E->getSourceRange());
+// DeclMatcher checks to see if the decls are used in a non-evaluated
+// context.
+class DeclMatcher : public EvaluatedExprVisitor<DeclMatcher> {
+  DeclSetVector &Decls;
+  bool FoundDecl;
 
-      Decls.insert(VD);
-    }
+public:
+  typedef EvaluatedExprVisitor<DeclMatcher> Inherited;
 
-  }; // end class DeclExtractor
+  DeclMatcher(Sema &S, DeclSetVector &Decls, Stmt *Statement)
+      : Inherited(S.Context), Decls(Decls), FoundDecl(false) {
+    if (!Statement)
+      return;
 
-  // DeclMatcher checks to see if the decls are used in a non-evaluated
-  // context.
-  class DeclMatcher : public EvaluatedExprVisitor<DeclMatcher> {
-    DeclSetVector &Decls;
-    bool FoundDecl;
+    Visit(Statement);
+  }
 
-  public:
-    typedef EvaluatedExprVisitor<DeclMatcher> Inherited;
+  void VisitReturnStmt(ReturnStmt *S) { FoundDecl = true; }
 
-    DeclMatcher(Sema &S, DeclSetVector &Decls, Stmt *Statement) :
-        Inherited(S.Context), Decls(Decls), FoundDecl(false) {
-      if (!Statement) return;
+  void VisitBreakStmt(BreakStmt *S) { FoundDecl = true; }
 
-      Visit(Statement);
-    }
+  void VisitGotoStmt(GotoStmt *S) { FoundDecl = true; }
 
-    void VisitReturnStmt(ReturnStmt *S) {
-      FoundDecl = true;
-    }
+  void VisitCastExpr(CastExpr *E) {
+    if (E->getCastKind() == CK_LValueToRValue)
+      CheckLValueToRValueCast(E->getSubExpr());
+    else
+      Visit(E->getSubExpr());
+  }
 
-    void VisitBreakStmt(BreakStmt *S) {
-      FoundDecl = true;
+  void CheckLValueToRValueCast(Expr *E) {
+    E = E->IgnoreParenImpCasts();
+
+    if (isa<DeclRefExpr>(E)) {
+      return;
     }
 
-    void VisitGotoStmt(GotoStmt *S) {
-      FoundDecl = true;
+    if (ConditionalOperator *CO = dyn_cast<ConditionalOperator>(E)) {
+      Visit(CO->getCond());
+      CheckLValueToRValueCast(CO->getTrueExpr());
+      CheckLValueToRValueCast(CO->getFalseExpr());
+      return;
     }
 
-    void VisitCastExpr(CastExpr *E) {
-      if (E->getCastKind() == CK_LValueToRValue)
-        CheckLValueToRValueCast(E->getSubExpr());
-      else
-        Visit(E->getSubExpr());
+    if (BinaryConditionalOperator *BCO =
+            dyn_cast<BinaryConditionalOperator>(E)) {
+      CheckLValueToRValueCast(BCO->getOpaqueValue()->getSourceExpr());
+      CheckLValueToRValueCast(BCO->getFalseExpr());
+      return;
     }
 
-    void CheckLValueToRValueCast(Expr *E) {
-      E = E->IgnoreParenImpCasts();
+    Visit(E);
+  }
 
-      if (isa<DeclRefExpr>(E)) {
-        return;
-      }
+  void VisitDeclRefExpr(DeclRefExpr *E) {
+    if (VarDecl *VD = dyn_cast<VarDecl>(E->getDecl()))
+      if (Decls.count(VD))
+        FoundDecl = true;
+  }
+
+  void VisitPseudoObjectExpr(PseudoObjectExpr *POE) {
+    // Only need to visit the semantics for POE.
+    // SyntaticForm doesn't really use the Decal.
+    for (auto *S : POE->semantics()) {
+      if (auto *OVE = dyn_cast<OpaqueValueExpr>(S))
+        // Look past the OVE into the expression it binds.
+        Visit(OVE->getSourceExpr());
+      else
+        Visit(S);
+    }
+  }
 
-      if (ConditionalOperator *CO = dyn_cast<ConditionalOperator>(E)) {
-        Visit(CO->getCond());
-        CheckLValueToRValueCast(CO->getTrueExpr());
-        CheckLValueToRValueCast(CO->getFalseExpr());
-        return;
-      }
+  bool FoundDeclInUse() { return FoundDecl; }
 
-      if (BinaryConditionalOperator *BCO =
-              dyn_cast<BinaryConditionalOperator>(E)) {
-        CheckLValueToRValueCast(BCO->getOpaqueValue()->getSourceExpr());
-        CheckLValueToRValueCast(BCO->getFalseExpr());
-        return;
-      }
+}; // end class DeclMatcher
 
-      Visit(E);
-    }
+void CheckForLoopConditionalStatement(Sema &S, Expr *Second, Expr *Third,
+                                      Stmt *Body) {
+  // Condition is empty
+  if (!Second)
+    return;
 
-    void VisitDeclRefExpr(DeclRefExpr *E) {
-      if (VarDecl *VD = dyn_cast<VarDecl>(E->getDecl()))
-        if (Decls.count(VD))
-          FoundDecl = true;
-    }
-
-    void VisitPseudoObjectExpr(PseudoObjectExpr *POE) {
-      // Only need to visit the semantics for POE.
-      // SyntaticForm doesn't really use the Decal.
-      for (auto *S : POE->semantics()) {
-        if (auto *OVE = dyn_cast<OpaqueValueExpr>(S))
-          // Look past the OVE into the expression it binds.
-          Visit(OVE->getSourceExpr());
-        else
-          Visit(S);
-      }
-    }
+  if (S.Diags.isIgnored(diag::warn_variables_not_in_loop_body,
+                        Second->getBeginLoc()))
+    return;
 
-    bool FoundDeclInUse() { return FoundDecl; }
+  PartialDiagnostic PDiag = S.PDiag(diag::warn_variables_not_in_loop_body);
+  DeclSetVector Decls;
+  SmallVector<SourceRange, 10> Ranges;
+  DeclExtractor DE(S, Decls, Ranges);
+  DE.Visit(Second);
 
-  };  // end class DeclMatcher
+  // Don't analyze complex conditionals.
+  if (!DE.isSimple())
+    return;
 
-  void CheckForLoopConditionalStatement(Sema &S, Expr *Second,
-                                        Expr *Third, Stmt *Body) {
-    // Condition is empty
-    if (!Second) return;
+  // No decls found.
+  if (Decls.size() == 0)
+    return;
 
-    if (S.Diags.isIgnored(diag::warn_variables_not_in_loop_body,
-                          Second->getBeginLoc()))
+  // Don't warn on volatile, static, or global variables.
+  for (auto *VD : Decls)
+    if (VD->getType().isVolatileQualified() || VD->hasGlobalStorage())
       return;
 
-    PartialDiagnostic PDiag = S.PDiag(diag::warn_variables_not_in_loop_body);
-    DeclSetVector Decls;
-    SmallVector<SourceRange, 10> Ranges;
-    DeclExtractor DE(S, Decls, Ranges);
-    DE.Visit(Second);
+  if (DeclMatcher(S, Decls, Second).FoundDeclInUse() ||
+      DeclMatcher(S, Decls, Third).FoundDeclInUse() ||
+      DeclMatcher(S, Decls, Body).FoundDeclInUse())
+    return;
 
-    // Don't analyze complex conditionals.
-    if (!DE.isSimple()) return;
+  // Load decl names into diagnostic.
+  if (Decls.size() > 4) {
+    PDiag << 0;
+  } else {
+    PDiag << (unsigned)Decls.size();
+    for (auto *VD : Decls)
+      PDiag << VD->getDeclName();
+  }
 
-    // No decls found.
-    if (Decls.size() == 0) return;
+  for (auto Range : Ranges)
+    PDiag << Range;
 
-    // Don't warn on volatile, static, or global variables.
-    for (auto *VD : Decls)
-      if (VD->getType().isVolatileQualified() || VD->hasGlobalStorage())
-        return;
+  S.Diag(Ranges.begin()->getBegin(), PDiag);
+}
 
-    if (DeclMatcher(S, Decls, Second).FoundDeclInUse() ||
-        DeclMatcher(S, Decls, Third).FoundDeclInUse() ||
-        DeclMatcher(S, Decls, Body).FoundDeclInUse())
-      return;
+// If Statement is an incemement or decrement, return true and sets the
+// variables Increment and DRE.
+bool ProcessIterationStmt(Sema &S, Stmt *Statement, bool &Increment,
+                          DeclRefExpr *&DRE) {
+  if (auto Cleanups = dyn_cast<ExprWithCleanups>(Statement))
+    if (!Cleanups->cleanupsHaveSideEffects())
+      Statement = Cleanups->getSubExpr();
 
-    // Load decl names into diagnostic.
-    if (Decls.size() > 4) {
-      PDiag << 0;
-    } else {
-      PDiag << (unsigned)Decls.size();
-      for (auto *VD : Decls)
-        PDiag << VD->getDeclName();
-    }
-
-    for (auto Range : Ranges)
-      PDiag << Range;
-
-    S.Diag(Ranges.begin()->getBegin(), PDiag);
-  }
-
-  // If Statement is an incemement or decrement, return true and sets the
-  // variables Increment and DRE.
-  bool ProcessIterationStmt(Sema &S, Stmt* Statement, bool &Increment,
-                            DeclRefExpr *&DRE) {
-    if (auto Cleanups = dyn_cast<ExprWithCleanups>(Statement))
-      if (!Cleanups->cleanupsHaveSideEffects())
-        Statement = Cleanups->getSubExpr();
-
-    if (UnaryOperator *UO = dyn_cast<UnaryOperator>(Statement)) {
-      switch (UO->getOpcode()) {
-        default: return false;
-        case UO_PostInc:
-        case UO_PreInc:
-          Increment = true;
-          break;
-        case UO_PostDec:
-        case UO_PreDec:
-          Increment = false;
-          break;
-      }
-      DRE = dyn_cast<DeclRefExpr>(UO->getSubExpr());
-      return DRE;
+  if (UnaryOperator *UO = dyn_cast<UnaryOperator>(Statement)) {
+    switch (UO->getOpcode()) {
+    default:
+      return false;
+    case UO_PostInc:
+    case UO_PreInc:
+      Increment = true;
+      break;
+    case UO_PostDec:
+    case UO_PreDec:
+      Increment = false;
+      break;
     }
+    DRE = dyn_cast<DeclRefExpr>(UO->getSubExpr());
+    return DRE;
+  }
 
-    if (CXXOperatorCallExpr *Call = dyn_cast<CXXOperatorCallExpr>(Statement)) {
-      FunctionDecl *FD = Call->getDirectCallee();
-      if (!FD || !FD->isOverloadedOperator()) return false;
-      switch (FD->getOverloadedOperator()) {
-        default: return false;
-        case OO_PlusPlus:
-          Increment = true;
-          break;
-        case OO_MinusMinus:
-          Increment = false;
-          break;
-      }
-      DRE = dyn_cast<DeclRefExpr>(Call->getArg(0));
-      return DRE;
+  if (CXXOperatorCallExpr *Call = dyn_cast<CXXOperatorCallExpr>(Statement)) {
+    FunctionDecl *FD = Call->getDirectCallee();
+    if (!FD || !FD->isOverloadedOperator())
+      return false;
+    switch (FD->getOverloadedOperator()) {
+    default:
+      return false;
+    case OO_PlusPlus:
+      Increment = true;
+      break;
+    case OO_MinusMinus:
+      Increment = false;
+      break;
     }
-
-    return false;
+    DRE = dyn_cast<DeclRefExpr>(Call->getArg(0));
+    return DRE;
   }
 
-  // A visitor to determine if a continue or break statement is a
-  // subexpression.
-  class BreakContinueFinder : public ConstEvaluatedExprVisitor<BreakContinueFinder> {
-    SourceLocation BreakLoc;
-    SourceLocation ContinueLoc;
-    bool InSwitch = false;
-
-  public:
-    BreakContinueFinder(Sema &S, const Stmt* Body) :
-        Inherited(S.Context) {
-      Visit(Body);
-    }
+  return false;
+}
 
-    typedef ConstEvaluatedExprVisitor<BreakContinueFinder> Inherited;
+// A visitor to determine if a continue or break statement is a
+// subexpression.
+class BreakContinueFinder
+    : public ConstEvaluatedExprVisitor<BreakContinueFinder> {
+  SourceLocation BreakLoc;
+  SourceLocation ContinueLoc;
+  bool InSwitch = false;
 
-    void VisitContinueStmt(const ContinueStmt* E) {
-      ContinueLoc = E->getContinueLoc();
-    }
+public:
+  BreakContinueFinder(Sema &S, const Stmt *Body) : Inherited(S.Context) {
+    Visit(Body);
+  }
 
-    void VisitBreakStmt(const BreakStmt* E) {
-      if (!InSwitch)
-        BreakLoc = E->getBreakLoc();
-    }
+  typedef ConstEvaluatedExprVisitor<BreakContinueFinder> Inherited;
 
-    void VisitSwitchStmt(const SwitchStmt* S) {
-      if (const Stmt *Init = S->getInit())
-        Visit(Init);
-      if (const Stmt *CondVar = S->getConditionVariableDeclStmt())
-        Visit(CondVar);
-      if (const Stmt *Cond = S->getCond())
-        Visit(Cond);
+  void VisitContinueStmt(const ContinueStmt *E) {
+    ContinueLoc = E->getContinueLoc();
+  }
 
-      // Don't return break statements from the body of a switch.
-      InSwitch = true;
-      if (const Stmt *Body = S->getBody())
-        Visit(Body);
-      InSwitch = false;
-    }
+  void VisitBreakStmt(const BreakStmt *E) {
+    if (!InSwitch)
+      BreakLoc = E->getBreakLoc();
+  }
 
-    void VisitForStmt(const ForStmt *S) {
-      // Only visit the init statement of a for loop; the body
-      // has a different break/continue scope.
-      if (const Stmt *Init = S->getInit())
-        Visit(Init);
-    }
+  void VisitSwitchStmt(const SwitchStmt *S) {
+    if (const Stmt *Init = S->getInit())
+      Visit(Init);
+    if (const Stmt *CondVar = S->getConditionVariableDeclStmt())
+      Visit(CondVar);
+    if (const Stmt *Cond = S->getCond())
+      Visit(Cond);
 
-    void VisitWhileStmt(const WhileStmt *) {
-      // Do nothing; the children of a while loop have a different
-      // break/continue scope.
-    }
+    // Don't return break statements from the body of a switch.
+    InSwitch = true;
+    if (const Stmt *Body = S->getBody())
+      Visit(Body);
+    InSwitch = false;
+  }
 
-    void VisitDoStmt(const DoStmt *) {
-      // Do nothing; the children of a while loop have a different
-      // break/continue scope.
-    }
+  void VisitForStmt(const ForStmt *S) {
+    // Only visit the init statement of a for loop; the body
+    // has a different break/continue scope.
+    if (const Stmt *Init = S->getInit())
+      Visit(Init);
+  }
+
+  void VisitWhileStmt(const WhileStmt *) {
+    // Do nothing; the children of a while loop have a different
+    // break/continue scope.
+  }
+
+  void VisitDoStmt(const DoStmt *) {
+    // Do nothing; the children of a while loop have a different
+    // break/continue scope.
+  }
+
+  void VisitCXXForRangeStmt(const CXXForRangeStmt *S) {
+    // Only visit the initialization of a for loop; the body
+    // has a different break/continue scope.
+    if (const Stmt *Init = S->getInit())
+      Visit(Init);
+    if (const Stmt *Range = S->getRangeStmt())
+      Visit(Range);
+    if (const Stmt *Begin = S->getBeginStmt())
+      Visit(Begin);
+    if (const Stmt *End = S->getEndStmt())
+      Visit(End);
+  }
+
+  void VisitObjCForCollectionStmt(const ObjCForCollectionStmt *S) {
+    // Only visit the initialization of a for loop; the body
+    // has a different break/continue scope.
+    if (const Stmt *Element = S->getElement())
+      Visit(Element);
+    if (const Stmt *Collection = S->getCollection())
+      Visit(Collection);
+  }
+
+  bool ContinueFound() { return ContinueLoc.isValid(); }
+  bool BreakFound() { return BreakLoc.isValid(); }
+  SourceLocation GetContinueLoc() { return ContinueLoc; }
+  SourceLocation GetBreakLoc() { return BreakLoc; }
+
+}; // end class BreakContinueFinder
+
+// Emit a warning when a loop increment/decrement appears twice per loop
+// iteration.  The conditions which trigger this warning are:
+// 1) The last statement in the loop body and the third expression in the
+//    for loop are both increment or both decrement of the same variable
+// 2) No continue statements in the loop body.
+void CheckForRedundantIteration(Sema &S, Expr *Third, Stmt *Body) {
+  // Return when there is nothing to check.
+  if (!Body || !Third)
+    return;
 
-    void VisitCXXForRangeStmt(const CXXForRangeStmt *S) {
-      // Only visit the initialization of a for loop; the body
-      // has a different break/continue scope.
-      if (const Stmt *Init = S->getInit())
-        Visit(Init);
-      if (const Stmt *Range = S->getRangeStmt())
-        Visit(Range);
-      if (const Stmt *Begin = S->getBeginStmt())
-        Visit(Begin);
-      if (const Stmt *End = S->getEndStmt())
-        Visit(End);
-    }
+  if (S.Diags.isIgnored(diag::warn_redundant_loop_iteration,
+                        Third->getBeginLoc()))
+    return;
 
-    void VisitObjCForCollectionStmt(const ObjCForCollectionStmt *S) {
-      // Only visit the initialization of a for loop; the body
-      // has a different break/continue scope.
-      if (const Stmt *Element = S->getElement())
-        Visit(Element);
-      if (const Stmt *Collection = S->getCollection())
-        Visit(Collection);
-    }
+  // Get the last statement from the loop body.
+  CompoundStmt *CS = dyn_cast<CompoundStmt>(Body);
+  if (!CS || CS->body_empty())
+    return;
+  Stmt *LastStmt = CS->body_back();
+  if (!LastStmt)
+    return;
 
-    bool ContinueFound() { return ContinueLoc.isValid(); }
-    bool BreakFound() { return BreakLoc.isValid(); }
-    SourceLocation GetContinueLoc() { return ContinueLoc; }
-    SourceLocation GetBreakLoc() { return BreakLoc; }
+  bool LoopIncrement, LastIncrement;
+  DeclRefExpr *LoopDRE, *LastDRE;
 
-  };  // end class BreakContinueFinder
+  if (!ProcessIterationStmt(S, Third, LoopIncrement, LoopDRE))
+    return;
+  if (!ProcessIterationStmt(S, LastStmt, LastIncrement, LastDRE))
+    return;
 
-  // Emit a warning when a loop increment/decrement appears twice per loop
-  // iteration.  The conditions which trigger this warning are:
-  // 1) The last statement in the loop body and the third expression in the
-  //    for loop are both increment or both decrement of the same variable
-  // 2) No continue statements in the loop body.
-  void CheckForRedundantIteration(Sema &S, Expr *Third, Stmt *Body) {
-    // Return when there is nothing to check.
-    if (!Body || !Third) return;
+  // Check that the two statements are both increments or both decrements
+  // on the same variable.
+  if (LoopIncrement != LastIncrement ||
+      LoopDRE->getDecl() != LastDRE->getDecl())
+    return;
 
-    if (S.Diags.isIgnored(diag::warn_redundant_loop_iteration,
-                          Third->getBeginLoc()))
-      return;
+  if (BreakContinueFinder(S, Body).ContinueFound())
+    return;
 
-    // Get the last statement from the loop body.
-    CompoundStmt *CS = dyn_cast<CompoundStmt>(Body);
-    if (!CS || CS->body_empty()) return;
-    Stmt *LastStmt = CS->body_back();
-    if (!LastStmt) return;
-
-    bool LoopIncrement, LastIncrement;
-    DeclRefExpr *LoopDRE, *LastDRE;
-
-    if (!ProcessIterationStmt(S, Third, LoopIncrement, LoopDRE)) return;
-    if (!ProcessIterationStmt(S, LastStmt, LastIncrement, LastDRE)) return;
-
-    // Check that the two statements are both increments or both decrements
-    // on the same variable.
-    if (LoopIncrement != LastIncrement ||
-        LoopDRE->getDecl() != LastDRE->getDecl()) return;
-
-    if (BreakContinueFinder(S, Body).ContinueFound()) return;
-
-    S.Diag(LastDRE->getLocation(), diag::warn_redundant_loop_iteration)
-         << LastDRE->getDecl() << LastIncrement;
-    S.Diag(LoopDRE->getLocation(), diag::note_loop_iteration_here)
-         << LoopIncrement;
-  }
+  S.Diag(LastDRE->getLocation(), diag::warn_redundant_loop_iteration)
+      << LastDRE->getDecl() << LastIncrement;
+  S.Diag(LoopDRE->getLocation(), diag::note_loop_iteration_here)
+      << LoopIncrement;
+}
 
 } // end namespace
 
-
 void Sema::CheckBreakContinueBinding(Expr *E) {
   if (!E || getLangOpts().CPlusPlus)
     return;
@@ -2169,7 +2159,7 @@ StmtResult Sema::ActOnForStmt(SourceLoca
                        Second.get().second->getExprLoc()))
     CommaVisitor(*this).Visit(Second.get().second);
 
-  Expr *Third  = third.release().getAs<Expr>();
+  Expr *Third = third.release().getAs<Expr>();
   if (isa<NullStmt>(Body))
     getCurCompoundScope().setHasEmptyLoopBodies();
 
@@ -2186,17 +2176,18 @@ StmtResult Sema::ActOnForEachLValueExpr(
   // Reduce placeholder expressions here.  Note that this rejects the
   // use of pseudo-object l-values in this position.
   ExprResult result = CheckPlaceholderExpr(E);
-  if (result.isInvalid()) return StmtError();
+  if (result.isInvalid())
+    return StmtError();
   E = result.get();
 
   ExprResult FullExpr = ActOnFinishFullExpr(E, /*DiscardedValue*/ false);
   if (FullExpr.isInvalid())
     return StmtError();
-  return StmtResult(static_cast<Stmt*>(FullExpr.get()));
+  return StmtResult(static_cast<Stmt *>(FullExpr.get()));
 }
 
-ExprResult
-Sema::CheckObjCForCollectionOperand(SourceLocation forLoc, Expr *collection) {
+ExprResult Sema::CheckObjCForCollectionOperand(SourceLocation forLoc,
+                                               Expr *collection) {
   if (!collection)
     return ExprError();
 
@@ -2206,7 +2197,8 @@ Sema::CheckObjCForCollectionOperand(Sour
   collection = result.get();
 
   // Bail out early if we've got a type-dependent expression.
-  if (collection->isTypeDependent()) return collection;
+  if (collection->isTypeDependent())
+    return collection;
 
   // Perform normal l-value conversion.
   result = DefaultFunctionArrayLvalueConversion(collection);
@@ -2217,10 +2209,10 @@ Sema::CheckObjCForCollectionOperand(Sour
   // The operand needs to have object-pointer type.
   // TODO: should we do a contextual conversion?
   const ObjCObjectPointerType *pointerType =
-    collection->getType()->getAs<ObjCObjectPointerType>();
+      collection->getType()->getAs<ObjCObjectPointerType>();
   if (!pointerType)
     return Diag(forLoc, diag::err_collection_expr_type)
-             << collection->getType() << collection->getSourceRange();
+           << collection->getType() << collection->getSourceRange();
 
   // Check that the operand provides
   //   - countByEnumeratingWithState:objects:count:
@@ -2238,10 +2230,8 @@ Sema::CheckObjCForCollectionOperand(Sour
     // the type declares the appropriate method.
   } else if (iface || !objectType->qual_empty()) {
     IdentifierInfo *selectorIdents[] = {
-      &Context.Idents.get("countByEnumeratingWithState"),
-      &Context.Idents.get("objects"),
-      &Context.Idents.get("count")
-    };
+        &Context.Idents.get("countByEnumeratingWithState"),
+        &Context.Idents.get("objects"), &Context.Idents.get("count")};
     Selector selector = Context.Selectors.getSelector(3, &selectorIdents[0]);
 
     ObjCMethodDecl *method = nullptr;
@@ -2249,7 +2239,8 @@ Sema::CheckObjCForCollectionOperand(Sour
     // If there's an interface, look in both the public and private APIs.
     if (iface) {
       method = iface->lookupInstanceMethod(selector);
-      if (!method) method = iface->lookupPrivateMethod(selector);
+      if (!method)
+        method = iface->lookupPrivateMethod(selector);
     }
 
     // Also check protocol qualifiers.
@@ -2260,7 +2251,7 @@ Sema::CheckObjCForCollectionOperand(Sour
     // If we didn't find it anywhere, give up.
     if (!method) {
       Diag(forLoc, diag::warn_collection_expr_type)
-        << collection->getType() << selector << collection->getSourceRange();
+          << collection->getType() << selector << collection->getSourceRange();
     }
 
     // TODO: check for an incompatible signature?
@@ -2270,21 +2261,20 @@ Sema::CheckObjCForCollectionOperand(Sour
   return collection;
 }
 
-StmtResult
-Sema::ActOnObjCForCollectionStmt(SourceLocation ForLoc,
-                                 Stmt *First, Expr *collection,
-                                 SourceLocation RParenLoc) {
+StmtResult Sema::ActOnObjCForCollectionStmt(SourceLocation ForLoc, Stmt *First,
+                                            Expr *collection,
+                                            SourceLocation RParenLoc) {
   setFunctionHasBranchProtectedScope();
 
   ExprResult CollectionExprResult =
-    CheckObjCForCollectionOperand(ForLoc, collection);
+      CheckObjCForCollectionOperand(ForLoc, collection);
 
   if (First) {
     QualType FirstType;
     if (DeclStmt *DS = dyn_cast<DeclStmt>(First)) {
       if (!DS->isSingleDecl())
         return StmtError(Diag((*DS->decl_begin())->getLocation(),
-                         diag::err_toomany_element_decls));
+                              diag::err_toomany_element_decls));
 
       VarDecl *D = dyn_cast<VarDecl>(DS->getSingleDecl());
       if (!D || D->isInvalidDecl())
@@ -2295,8 +2285,8 @@ Sema::ActOnObjCForCollectionStmt(SourceL
       // declare identifiers for objects having storage class 'auto' or
       // 'register'.
       if (!D->hasLocalStorage())
-        return StmtError(Diag(D->getLocation(),
-                              diag::err_non_local_variable_decl_in_for));
+        return StmtError(
+            Diag(D->getLocation(), diag::err_non_local_variable_decl_in_for));
 
       // If the type contained 'auto', deduce the 'auto' to 'id'.
       if (FirstType->getContainedAutoType()) {
@@ -2304,7 +2294,7 @@ Sema::ActOnObjCForCollectionStmt(SourceL
                                  VK_PRValue);
         Expr *DeducedInit = &OpaqueId;
         if (DeduceAutoType(D->getTypeSourceInfo(), DeducedInit, FirstType) ==
-                DAR_Failed)
+            DAR_Failed)
           DiagnoseAutoDeductionFailure(D, DeducedInit);
         if (FirstType.isNull()) {
           D->setInvalidDecl();
@@ -2316,8 +2306,7 @@ Sema::ActOnObjCForCollectionStmt(SourceL
         if (!inTemplateInstantiation()) {
           SourceLocation Loc =
               D->getTypeSourceInfo()->getTypeLoc().getBeginLoc();
-          Diag(Loc, diag::warn_auto_var_is_id)
-            << D->getDeclName();
+          Diag(Loc, diag::warn_auto_var_is_id) << D->getDeclName();
         }
       }
 
@@ -2328,16 +2317,16 @@ Sema::ActOnObjCForCollectionStmt(SourceL
             Diag(First->getBeginLoc(), diag::err_selector_element_not_lvalue)
             << First->getSourceRange());
 
-      FirstType = static_cast<Expr*>(First)->getType();
+      FirstType = static_cast<Expr *>(First)->getType();
       if (FirstType.isConstQualified())
         Diag(ForLoc, diag::err_selector_element_const_type)
-          << FirstType << First->getSourceRange();
+            << FirstType << First->getSourceRange();
     }
     if (!FirstType->isDependentType() &&
         !FirstType->isObjCObjectPointerType() &&
         !FirstType->isBlockPointerType())
-        return StmtError(Diag(ForLoc, diag::err_selector_element_type)
-                           << FirstType << First->getSourceRange());
+      return StmtError(Diag(ForLoc, diag::err_selector_element_type)
+                       << FirstType << First->getSourceRange());
   }
 
   if (CollectionExprResult.isInvalid())
@@ -2394,10 +2383,7 @@ static bool FinishForRangeVarDecl(Sema &
 namespace {
 // An enum to represent whether something is dealing with a call to begin()
 // or a call to end() in a range-based for loop.
-enum BeginEndFunction {
-  BEF_begin,
-  BEF_end
-};
+enum BeginEndFunction { BEF_begin, BEF_end };
 
 /// Produce a note indicating which begin/end function was implicitly called
 /// by a C++11 for-range statement. This is often not obvious from the code,
@@ -2417,31 +2403,31 @@ void NoteForRangeBeginEndFunction(Sema &
   bool IsTemplate = false;
   if (FunctionTemplateDecl *FunTmpl = D->getPrimaryTemplate()) {
     Description = SemaRef.getTemplateArgumentBindingsText(
-      FunTmpl->getTemplateParameters(), *D->getTemplateSpecializationArgs());
+        FunTmpl->getTemplateParameters(), *D->getTemplateSpecializationArgs());
     IsTemplate = true;
   }
 
   SemaRef.Diag(Loc, diag::note_for_range_begin_end)
-    << BEF << IsTemplate << Description << E->getType();
+      << BEF << IsTemplate << Description << E->getType();
 }
 
 /// Build a variable declaration for a for-range statement.
-VarDecl *BuildForRangeVarDecl(Sema &SemaRef, SourceLocation Loc,
-                              QualType Type, StringRef Name) {
+VarDecl *BuildForRangeVarDecl(Sema &SemaRef, SourceLocation Loc, QualType Type,
+                              StringRef Name) {
   DeclContext *DC = SemaRef.CurContext;
   IdentifierInfo *II = &SemaRef.PP.getIdentifierTable().get(Name);
   TypeSourceInfo *TInfo = SemaRef.Context.getTrivialTypeSourceInfo(Type, Loc);
-  VarDecl *Decl = VarDecl::Create(SemaRef.Context, DC, Loc, Loc, II, Type,
-                                  TInfo, SC_None);
+  VarDecl *Decl =
+      VarDecl::Create(SemaRef.Context, DC, Loc, Loc, II, Type, TInfo, SC_None);
   Decl->setImplicit();
   return Decl;
 }
 
-}
+} // namespace
 
 static bool ObjCEnumerationCollection(Expr *Collection) {
-  return !Collection->isTypeDependent()
-          && Collection->getType()->getAs<ObjCObjectPointerType>() != nullptr;
+  return !Collection->isTypeDependent() &&
+         Collection->getType()->getAs<ObjCObjectPointerType>() != nullptr;
 }
 
 /// ActOnCXXForRangeStmt - Check and build a C++11 for-range statement.
@@ -2475,7 +2461,7 @@ StmtResult Sema::ActOnCXXForRangeStmt(Sc
     // FIXME: Support init-statements in Objective-C++20 ranged for statement.
     if (InitStmt)
       return Diag(InitStmt->getBeginLoc(), diag::err_objc_for_range_init_stmt)
-                 << InitStmt->getSourceRange();
+             << InitStmt->getSourceRange();
     return ActOnObjCForCollectionStmt(ForLoc, First, Range, RParenLoc);
   }
 
@@ -2509,9 +2495,9 @@ StmtResult Sema::ActOnCXXForRangeStmt(Sc
   // Divide by 2, since the variables are in the inner scope (loop body).
   const auto DepthStr = std::to_string(S->getDepth() / 2);
   SourceLocation RangeLoc = Range->getBeginLoc();
-  VarDecl *RangeVar = BuildForRangeVarDecl(*this, RangeLoc,
-                                           Context.getAutoRRefDeductType(),
-                                           std::string("__range") + DepthStr);
+  VarDecl *RangeVar =
+      BuildForRangeVarDecl(*this, RangeLoc, Context.getAutoRRefDeductType(),
+                           std::string("__range") + DepthStr);
   if (FinishForRangeVarDecl(*this, RangeVar, Range, RangeLoc,
                             diag::err_for_range_deduction_failure)) {
     ActOnInitializerError(LoopVar);
@@ -2565,10 +2551,9 @@ BuildNonArrayForRange(Sema &SemaRef, Exp
 
   auto BuildBegin = [&] {
     *BEF = BEF_begin;
-    Sema::ForRangeStatus RangeStatus =
-        SemaRef.BuildForRangeBeginEndCall(ColonLoc, ColonLoc, BeginNameInfo,
-                                          BeginMemberLookup, CandidateSet,
-                                          BeginRange, BeginExpr);
+    Sema::ForRangeStatus RangeStatus = SemaRef.BuildForRangeBeginEndCall(
+        ColonLoc, ColonLoc, BeginNameInfo, BeginMemberLookup, CandidateSet,
+        BeginRange, BeginExpr);
 
     if (RangeStatus != Sema::FRS_Success) {
       if (RangeStatus == Sema::FRS_DiagnosticIssued)
@@ -2595,10 +2580,9 @@ BuildNonArrayForRange(Sema &SemaRef, Exp
 
   auto BuildEnd = [&] {
     *BEF = BEF_end;
-    Sema::ForRangeStatus RangeStatus =
-        SemaRef.BuildForRangeBeginEndCall(ColonLoc, ColonLoc, EndNameInfo,
-                                          EndMemberLookup, CandidateSet,
-                                          EndRange, EndExpr);
+    Sema::ForRangeStatus RangeStatus = SemaRef.BuildForRangeBeginEndCall(
+        ColonLoc, ColonLoc, EndNameInfo, EndMemberLookup, CandidateSet,
+        EndRange, EndExpr);
     if (RangeStatus != Sema::FRS_Success) {
       if (RangeStatus == Sema::FRS_DiagnosticIssued)
         SemaRef.Diag(EndRange->getBeginLoc(), diag::note_in_for_range)
@@ -2632,38 +2616,38 @@ BuildNonArrayForRange(Sema &SemaRef, Exp
       // This way we prefer a "no viable 'end'" diagnostic over a "i found
       // a 'begin' but ignored it because there was no member 'end'"
       // diagnostic.
-      auto BuildNonmember = [&](
-          BeginEndFunction BEFFound, LookupResult &Found,
-          llvm::function_ref<Sema::ForRangeStatus()> BuildFound,
-          llvm::function_ref<Sema::ForRangeStatus()> BuildNotFound) {
-        LookupResult OldFound = std::move(Found);
-        Found.clear();
-
-        if (Sema::ForRangeStatus Result = BuildNotFound())
-          return Result;
-
-        switch (BuildFound()) {
-        case Sema::FRS_Success:
-          return Sema::FRS_Success;
-
-        case Sema::FRS_NoViableFunction:
-          CandidateSet->NoteCandidates(
-              PartialDiagnosticAt(BeginRange->getBeginLoc(),
-                                  SemaRef.PDiag(diag::err_for_range_invalid)
-                                      << BeginRange->getType() << BEFFound),
-              SemaRef, OCD_AllCandidates, BeginRange);
-          LLVM_FALLTHROUGH;
-
-        case Sema::FRS_DiagnosticIssued:
-          for (NamedDecl *D : OldFound) {
-            SemaRef.Diag(D->getLocation(),
-                         diag::note_for_range_member_begin_end_ignored)
-                << BeginRange->getType() << BEFFound;
-          }
-          return Sema::FRS_DiagnosticIssued;
-        }
-        llvm_unreachable("unexpected ForRangeStatus");
-      };
+      auto BuildNonmember =
+          [&](BeginEndFunction BEFFound, LookupResult &Found,
+              llvm::function_ref<Sema::ForRangeStatus()> BuildFound,
+              llvm::function_ref<Sema::ForRangeStatus()> BuildNotFound) {
+            LookupResult OldFound = std::move(Found);
+            Found.clear();
+
+            if (Sema::ForRangeStatus Result = BuildNotFound())
+              return Result;
+
+            switch (BuildFound()) {
+            case Sema::FRS_Success:
+              return Sema::FRS_Success;
+
+            case Sema::FRS_NoViableFunction:
+              CandidateSet->NoteCandidates(
+                  PartialDiagnosticAt(BeginRange->getBeginLoc(),
+                                      SemaRef.PDiag(diag::err_for_range_invalid)
+                                          << BeginRange->getType() << BEFFound),
+                  SemaRef, OCD_AllCandidates, BeginRange);
+              LLVM_FALLTHROUGH;
+
+            case Sema::FRS_DiagnosticIssued:
+              for (NamedDecl *D : OldFound) {
+                SemaRef.Diag(D->getLocation(),
+                             diag::note_for_range_member_begin_end_ignored)
+                    << BeginRange->getType() << BEFFound;
+              }
+              return Sema::FRS_DiagnosticIssued;
+            }
+            llvm_unreachable("unexpected ForRangeStatus");
+          };
       if (BeginMemberLookup.empty())
         return BuildNonmember(BEF_end, EndMemberLookup, BuildEnd, BuildBegin);
       return BuildNonmember(BEF_begin, BeginMemberLookup, BuildBegin, BuildEnd);
@@ -2683,15 +2667,10 @@ BuildNonArrayForRange(Sema &SemaRef, Exp
 /// Speculatively attempt to dereference an invalid range expression.
 /// If the attempt fails, this function will return a valid, null StmtResult
 /// and emit no diagnostics.
-static StmtResult RebuildForRangeWithDereference(Sema &SemaRef, Scope *S,
-                                                 SourceLocation ForLoc,
-                                                 SourceLocation CoawaitLoc,
-                                                 Stmt *InitStmt,
-                                                 Stmt *LoopVarDecl,
-                                                 SourceLocation ColonLoc,
-                                                 Expr *Range,
-                                                 SourceLocation RangeLoc,
-                                                 SourceLocation RParenLoc) {
+static StmtResult RebuildForRangeWithDereference(
+    Sema &SemaRef, Scope *S, SourceLocation ForLoc, SourceLocation CoawaitLoc,
+    Stmt *InitStmt, Stmt *LoopVarDecl, SourceLocation ColonLoc, Expr *Range,
+    SourceLocation RangeLoc, SourceLocation RParenLoc) {
   // Determine whether we can rebuild the for-range statement with a
   // dereferenced range expression.
   ExprResult AdjustedRange;
@@ -2713,7 +2692,7 @@ static StmtResult RebuildForRangeWithDer
   // loop. Produce a fixit, and rebuild the loop with diagnostics enabled, in
   // case there are any other (non-fatal) problems with it.
   SemaRef.Diag(RangeLoc, diag::err_for_range_dereference)
-    << Range->getType() << FixItHint::CreateInsertion(RangeLoc, "*");
+      << Range->getType() << FixItHint::CreateInsertion(RangeLoc, "*");
   return SemaRef.ActOnCXXForRangeStmt(
       S, ForLoc, CoawaitLoc, InitStmt, LoopVarDecl, ColonLoc,
       AdjustedRange.get(), RParenLoc, Sema::BFRK_Rebuild);
@@ -2766,13 +2745,13 @@ StmtResult Sema::BuildCXXForRangeStmt(So
 
     const QualType RangeVarNonRefType = RangeVarType.getNonReferenceType();
 
-    ExprResult BeginRangeRef = BuildDeclRefExpr(RangeVar, RangeVarNonRefType,
-                                                VK_LValue, ColonLoc);
+    ExprResult BeginRangeRef =
+        BuildDeclRefExpr(RangeVar, RangeVarNonRefType, VK_LValue, ColonLoc);
     if (BeginRangeRef.isInvalid())
       return StmtError();
 
-    ExprResult EndRangeRef = BuildDeclRefExpr(RangeVar, RangeVarNonRefType,
-                                              VK_LValue, ColonLoc);
+    ExprResult EndRangeRef =
+        BuildDeclRefExpr(RangeVar, RangeVarNonRefType, VK_LValue, ColonLoc);
     if (EndRangeRef.isInvalid())
       return StmtError();
 
@@ -2821,7 +2800,7 @@ StmtResult Sema::BuildCXXForRangeStmt(So
         BoundExpr = IntegerLiteral::Create(
             Context, CAT->getSize(), Context.getPointerDiffType(), RangeLoc);
       else if (const VariableArrayType *VAT =
-               dyn_cast<VariableArrayType>(UnqAT)) {
+                   dyn_cast<VariableArrayType>(UnqAT)) {
         // For a variably modified type we can't just use the expression within
         // the array bounds, since we don't want that to be re-evaluated here.
         // Rather, we need to determine what it was when the array was first
@@ -2836,13 +2815,13 @@ StmtResult Sema::BuildCXXForRangeStmt(So
         // FIXME: This results in codegen generating IR that recalculates the
         // run-time number of elements (as opposed to just using the IR Value
         // that corresponds to the run-time value of each bound that was
-        // generated when the array was created.) If this proves too embarrassing
-        // even for unoptimized IR, consider passing a magic-value/cookie to
-        // codegen that then knows to simply use that initial llvm::Value (that
-        // corresponds to the bound at time of array creation) within
-        // getelementptr.  But be prepared to pay the price of increasing a
-        // customized form of coupling between the two components - which  could
-        // be hard to maintain as the codebase evolves.
+        // generated when the array was created.) If this proves too
+        // embarrassing even for unoptimized IR, consider passing a
+        // magic-value/cookie to codegen that then knows to simply use that
+        // initial llvm::Value (that corresponds to the bound at time of array
+        // creation) within getelementptr.  But be prepared to pay the price of
+        // increasing a customized form of coupling between the two components -
+        // which  could be hard to maintain as the codebase evolves.
 
         ExprResult SizeOfVLAExprR = ActOnUnaryExprOrTypeTraitExpr(
             EndVar->getLocation(), UETT_SizeOf,
@@ -2915,11 +2894,9 @@ StmtResult Sema::BuildCXXForRangeStmt(So
 
         // If building the range failed, try dereferencing the range expression
         // unless a diagnostic was issued or the end function is problematic.
-        StmtResult SR = RebuildForRangeWithDereference(*this, S, ForLoc,
-                                                       CoawaitLoc, InitStmt,
-                                                       LoopVarDecl, ColonLoc,
-                                                       Range, RangeLoc,
-                                                       RParenLoc);
+        StmtResult SR = RebuildForRangeWithDereference(
+            *this, S, ForLoc, CoawaitLoc, InitStmt, LoopVarDecl, ColonLoc,
+            Range, RangeLoc, RParenLoc);
         if (SR.isInvalid() || SR.isUsable())
           return SR;
       }
@@ -2960,8 +2937,8 @@ StmtResult Sema::BuildCXXForRangeStmt(So
         ActOnDeclStmt(ConvertDeclToDeclGroup(EndVar), ColonLoc, ColonLoc);
 
     const QualType BeginRefNonRefType = BeginType.getNonReferenceType();
-    ExprResult BeginRef = BuildDeclRefExpr(BeginVar, BeginRefNonRefType,
-                                           VK_LValue, ColonLoc);
+    ExprResult BeginRef =
+        BuildDeclRefExpr(BeginVar, BeginRefNonRefType, VK_LValue, ColonLoc);
     if (BeginRef.isInvalid())
       return StmtError();
 
@@ -2971,8 +2948,8 @@ StmtResult Sema::BuildCXXForRangeStmt(So
       return StmtError();
 
     // Build and check __begin != __end expression.
-    NotEqExpr = ActOnBinOp(S, ColonLoc, tok::exclaimequal,
-                           BeginRef.get(), EndRef.get());
+    NotEqExpr = ActOnBinOp(S, ColonLoc, tok::exclaimequal, BeginRef.get(),
+                           EndRef.get());
     if (!NotEqExpr.isInvalid())
       NotEqExpr = CheckBooleanCondition(ColonLoc, NotEqExpr.get());
     if (!NotEqExpr.isInvalid())
@@ -2980,7 +2957,7 @@ StmtResult Sema::BuildCXXForRangeStmt(So
           ActOnFinishFullExpr(NotEqExpr.get(), /*DiscardedValue*/ false);
     if (NotEqExpr.isInvalid()) {
       Diag(RangeLoc, diag::note_for_range_invalid_iterator)
-        << RangeLoc << 0 << BeginRangeRef.get()->getType();
+          << RangeLoc << 0 << BeginRangeRef.get()->getType();
       NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);
       if (!Context.hasSameType(BeginType, EndType))
         NoteForRangeBeginEndFunction(*this, EndExpr.get(), BEF_end);
@@ -2988,8 +2965,8 @@ StmtResult Sema::BuildCXXForRangeStmt(So
     }
 
     // Build and check ++__begin expression.
-    BeginRef = BuildDeclRefExpr(BeginVar, BeginRefNonRefType,
-                                VK_LValue, ColonLoc);
+    BeginRef =
+        BuildDeclRefExpr(BeginVar, BeginRefNonRefType, VK_LValue, ColonLoc);
     if (BeginRef.isInvalid())
       return StmtError();
 
@@ -3003,21 +2980,21 @@ StmtResult Sema::BuildCXXForRangeStmt(So
       IncrExpr = ActOnFinishFullExpr(IncrExpr.get(), /*DiscardedValue*/ false);
     if (IncrExpr.isInvalid()) {
       Diag(RangeLoc, diag::note_for_range_invalid_iterator)
-        << RangeLoc << 2 << BeginRangeRef.get()->getType() ;
+          << RangeLoc << 2 << BeginRangeRef.get()->getType();
       NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);
       return StmtError();
     }
 
     // Build and check *__begin  expression.
-    BeginRef = BuildDeclRefExpr(BeginVar, BeginRefNonRefType,
-                                VK_LValue, ColonLoc);
+    BeginRef =
+        BuildDeclRefExpr(BeginVar, BeginRefNonRefType, VK_LValue, ColonLoc);
     if (BeginRef.isInvalid())
       return StmtError();
 
     ExprResult DerefExpr = ActOnUnaryOp(S, ColonLoc, tok::star, BeginRef.get());
     if (DerefExpr.isInvalid()) {
       Diag(RangeLoc, diag::note_for_range_invalid_iterator)
-        << RangeLoc << 1 << BeginRangeRef.get()->getType();
+          << RangeLoc << 1 << BeginRangeRef.get()->getType();
       NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);
       return StmtError();
     }
@@ -3045,8 +3022,8 @@ StmtResult Sema::BuildCXXForRangeStmt(So
   return new (Context) CXXForRangeStmt(
       InitStmt, RangeDS, cast_or_null<DeclStmt>(BeginDeclStmt.get()),
       cast_or_null<DeclStmt>(EndDeclStmt.get()), NotEqExpr.get(),
-      IncrExpr.get(), LoopVarDS, /*Body=*/nullptr, ForLoc, CoawaitLoc,
-      ColonLoc, RParenLoc);
+      IncrExpr.get(), LoopVarDS, /*Body=*/nullptr, ForLoc, CoawaitLoc, ColonLoc,
+      RParenLoc);
 }
 
 /// FinishObjCForCollectionStmt - Attach the body to a objective-C foreach
@@ -3054,7 +3031,7 @@ StmtResult Sema::BuildCXXForRangeStmt(So
 StmtResult Sema::FinishObjCForCollectionStmt(Stmt *S, Stmt *B) {
   if (!S || !B)
     return StmtError();
-  ObjCForCollectionStmt * ForStmt = cast<ObjCForCollectionStmt>(S);
+  ObjCForCollectionStmt *ForStmt = cast<ObjCForCollectionStmt>(S);
 
   ForStmt->setBody(B);
   return S;
@@ -3262,24 +3239,22 @@ StmtResult Sema::FinishCXXForRangeStmt(S
   return S;
 }
 
-StmtResult Sema::ActOnGotoStmt(SourceLocation GotoLoc,
-                               SourceLocation LabelLoc,
+StmtResult Sema::ActOnGotoStmt(SourceLocation GotoLoc, SourceLocation LabelLoc,
                                LabelDecl *TheDecl) {
   setFunctionHasBranchIntoScope();
   TheDecl->markUsed(Context);
   return new (Context) GotoStmt(TheDecl, GotoLoc, LabelLoc);
 }
 
-StmtResult
-Sema::ActOnIndirectGotoStmt(SourceLocation GotoLoc, SourceLocation StarLoc,
-                            Expr *E) {
+StmtResult Sema::ActOnIndirectGotoStmt(SourceLocation GotoLoc,
+                                       SourceLocation StarLoc, Expr *E) {
   // Convert operand to void*
   if (!E->isTypeDependent()) {
     QualType ETy = E->getType();
     QualType DestTy = Context.getPointerType(Context.VoidTy.withConst());
     ExprResult ExprRes = E;
     AssignConvertType ConvTy =
-      CheckSingleAssignmentConstraints(DestTy, ExprRes);
+        CheckSingleAssignmentConstraints(DestTy, ExprRes);
     if (ExprRes.isInvalid())
       return StmtError();
     E = ExprRes.get();
@@ -3305,8 +3280,8 @@ static void CheckJumpOutOfSEHFinally(Sem
   }
 }
 
-StmtResult
-Sema::ActOnContinueStmt(SourceLocation ContinueLoc, Scope *CurScope) {
+StmtResult Sema::ActOnContinueStmt(SourceLocation ContinueLoc,
+                                   Scope *CurScope) {
   Scope *S = CurScope->getContinueParent();
   if (!S) {
     // C99 6.8.6.2p1: A break shall appear only in or as a loop body.
@@ -3323,8 +3298,7 @@ Sema::ActOnContinueStmt(SourceLocation C
   return new (Context) ContinueStmt(ContinueLoc);
 }
 
-StmtResult
-Sema::ActOnBreakStmt(SourceLocation BreakLoc, Scope *CurScope) {
+StmtResult Sema::ActOnBreakStmt(SourceLocation BreakLoc, Scope *CurScope) {
   Scope *S = CurScope->getBreakParent();
   if (!S) {
     // C99 6.8.6.3p1: A break shall appear only in or as a switch/loop body.
@@ -3621,7 +3595,7 @@ StmtResult Sema::ActOnCapScopeReturnStmt
         // initializer list, because it is not an expression (even
         // though we represent it as one). We still deduce 'void'.
         Diag(ReturnLoc, diag::err_lambda_return_init_list)
-          << RetValExp->getSourceRange();
+            << RetValExp->getSourceRange();
       }
 
       FnRetType = Context.VoidTy;
@@ -3640,7 +3614,8 @@ StmtResult Sema::ActOnCapScopeReturnStmt
       return StmtError();
     }
   } else if (auto *CurRegion = dyn_cast<CapturedRegionScopeInfo>(CurCap)) {
-    Diag(ReturnLoc, diag::err_return_in_captured_stmt) << CurRegion->getRegionName();
+    Diag(ReturnLoc, diag::err_return_in_captured_stmt)
+        << CurRegion->getRegionName();
     return StmtError();
   } else {
     assert(CurLambda && "unknown kind of captured scope");
@@ -3660,11 +3635,9 @@ StmtResult Sema::ActOnCapScopeReturnStmt
     // types we can conclusively prove aren't void.
   } else if (FnRetType->isVoidType()) {
     if (RetValExp && !isa<InitListExpr>(RetValExp) &&
-        !(getLangOpts().CPlusPlus &&
-          (RetValExp->isTypeDependent() ||
-           RetValExp->getType()->isVoidType()))) {
-      if (!getLangOpts().CPlusPlus &&
-          RetValExp->getType()->isVoidType())
+        !(getLangOpts().CPlusPlus && (RetValExp->isTypeDependent() ||
+                                      RetValExp->getType()->isVoidType()))) {
+      if (!getLangOpts().CPlusPlus && RetValExp->getType()->isVoidType())
         Diag(ReturnLoc, diag::ext_return_has_void_expr) << "literal" << 2;
       else {
         Diag(ReturnLoc, diag::err_return_block_has_expr);
@@ -3734,6 +3707,7 @@ class LocalTypedefNameReferencer
 public:
   LocalTypedefNameReferencer(Sema &S) : S(S) {}
   bool VisitRecordType(const RecordType *RT);
+
 private:
   Sema &S;
 };
@@ -3748,7 +3722,7 @@ bool LocalTypedefNameReferencer::VisitRe
         S.MarkAnyDeclReferenced(T->getLocation(), T, /*OdrUse=*/false);
   return true;
 }
-}
+} // namespace
 
 TypeLoc Sema::getReturnTypeLoc(FunctionDecl *FD) const {
   return FD->getTypeSourceInfo()
@@ -3761,8 +3735,7 @@ TypeLoc Sema::getReturnTypeLoc(FunctionD
 /// C++1y [dcl.spec.auto]p6.
 bool Sema::DeduceFunctionTypeFromReturnExpr(FunctionDecl *FD,
                                             SourceLocation ReturnLoc,
-                                            Expr *&RetExpr,
-                                            AutoType *AT) {
+                                            Expr *&RetExpr, AutoType *AT) {
   // If this is the conversion function for a lambda, we choose to deduce it
   // type from the corresponding call operator, not from the synthesized return
   // statement within it. See Sema::DeduceReturnType.
@@ -3775,9 +3748,9 @@ bool Sema::DeduceFunctionTypeFromReturnE
   if (RetExpr && isa<InitListExpr>(RetExpr)) {
     //  If the deduction is for a return statement and the initializer is
     //  a braced-init-list, the program is ill-formed.
-    Diag(RetExpr->getExprLoc(),
-         getCurLambda() ? diag::err_lambda_return_init_list
-                        : diag::err_auto_fn_return_init_list)
+    Diag(RetExpr->getExprLoc(), getCurLambda()
+                                    ? diag::err_lambda_return_init_list
+                                    : diag::err_auto_fn_return_init_list)
         << RetExpr->getSourceRange();
     return true;
   }
@@ -3798,7 +3771,7 @@ bool Sema::DeduceFunctionTypeFromReturnE
 
     if (DAR == DAR_Failed && !FD->isInvalidDecl())
       Diag(RetExpr->getExprLoc(), diag::err_auto_fn_deduction_failure)
-        << OrigResultType.getType() << RetExpr->getType();
+          << OrigResultType.getType() << RetExpr->getType();
 
     if (DAR != DAR_Succeeded)
       return true;
@@ -3815,7 +3788,7 @@ bool Sema::DeduceFunctionTypeFromReturnE
     // or 'decltype(auto)', so just check for that case directly.
     if (!OrigResultType.getType()->getAs<AutoType>()) {
       Diag(ReturnLoc, diag::err_auto_fn_return_void_but_not_auto)
-        << OrigResultType.getType();
+          << OrigResultType.getType();
       return true;
     }
     // We always deduce U = void in this case.
@@ -3844,20 +3817,19 @@ bool Sema::DeduceFunctionTypeFromReturnE
     if (NewAT->getDeducedType().isNull())
       return false;
 
-    CanQualType OldDeducedType = Context.getCanonicalFunctionResultType(
-                                   DeducedT);
-    CanQualType NewDeducedType = Context.getCanonicalFunctionResultType(
-                                   NewAT->getDeducedType());
+    CanQualType OldDeducedType =
+        Context.getCanonicalFunctionResultType(DeducedT);
+    CanQualType NewDeducedType =
+        Context.getCanonicalFunctionResultType(NewAT->getDeducedType());
     if (!FD->isDependentContext() && OldDeducedType != NewDeducedType) {
       const LambdaScopeInfo *LambdaSI = getCurLambda();
       if (LambdaSI && LambdaSI->HasImplicitReturnType) {
         Diag(ReturnLoc, diag::err_typecheck_missing_return_type_incompatible)
-          << NewAT->getDeducedType() << DeducedT
-          << true /*IsLambda*/;
+            << NewAT->getDeducedType() << DeducedT << true /*IsLambda*/;
       } else {
         Diag(ReturnLoc, diag::err_auto_fn_different_deductions)
-          << (AT->isDecltypeAuto() ? 1 : 0)
-          << NewAT->getDeducedType() << DeducedT;
+            << (AT->isDecltypeAuto() ? 1 : 0) << NewAT->getDeducedType()
+            << DeducedT;
       }
       return true;
     }
@@ -3869,9 +3841,8 @@ bool Sema::DeduceFunctionTypeFromReturnE
   return false;
 }
 
-StmtResult
-Sema::ActOnReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp,
-                      Scope *CurScope) {
+StmtResult Sema::ActOnReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp,
+                                 Scope *CurScope) {
   // Correct typos, in case the containing function returns 'auto' and
   // RetValExp should determine the deduced type.
   ExprResult RetVal = CorrectDelayedTyposInExpr(
@@ -3883,8 +3854,8 @@ Sema::ActOnReturnStmt(SourceLocation Ret
   if (R.isInvalid() || ExprEvalContexts.back().isDiscardedStatementContext())
     return R;
 
-  if (VarDecl *VD =
-      const_cast<VarDecl*>(cast<ReturnStmt>(R.get())->getNRVOCandidate())) {
+  if (VarDecl *VD = const_cast<VarDecl *>(
+          cast<ReturnStmt>(R.get())->getNRVOCandidate())) {
     CurScope->addNRVOCandidate(VD);
   } else {
     CurScope->setNoNRVO();
@@ -4050,15 +4021,14 @@ StmtResult Sema::BuildReturnStmt(SourceL
             D = diag::err_ctor_dtor_returns_void;
           else
             D = diag::ext_return_has_void_expr;
-        }
-        else {
+        } else {
           ExprResult Result = RetValExp;
           Result = IgnoredValueConversions(Result.get());
           if (Result.isInvalid())
             return StmtError();
           RetValExp = Result.get();
-          RetValExp = ImpCastExprToType(RetValExp,
-                                        Context.VoidTy, CK_ToVoid).get();
+          RetValExp =
+              ImpCastExprToType(RetValExp, Context.VoidTy, CK_ToVoid).get();
         }
         // return of void in constructor/destructor is illegal in C++.
         if (D == diag::err_ctor_dtor_returns_void) {
@@ -4185,10 +4155,9 @@ StmtResult Sema::BuildReturnStmt(SourceL
   return Result;
 }
 
-StmtResult
-Sema::ActOnObjCAtCatchStmt(SourceLocation AtLoc,
-                           SourceLocation RParen, Decl *Parm,
-                           Stmt *Body) {
+StmtResult Sema::ActOnObjCAtCatchStmt(SourceLocation AtLoc,
+                                      SourceLocation RParen, Decl *Parm,
+                                      Stmt *Body) {
   VarDecl *Var = cast_or_null<VarDecl>(Parm);
   if (Var && Var->isInvalidDecl())
     return StmtError();
@@ -4196,14 +4165,12 @@ Sema::ActOnObjCAtCatchStmt(SourceLocatio
   return new (Context) ObjCAtCatchStmt(AtLoc, RParen, Var, Body);
 }
 
-StmtResult
-Sema::ActOnObjCAtFinallyStmt(SourceLocation AtLoc, Stmt *Body) {
+StmtResult Sema::ActOnObjCAtFinallyStmt(SourceLocation AtLoc, Stmt *Body) {
   return new (Context) ObjCAtFinallyStmt(AtLoc, Body);
 }
 
-StmtResult
-Sema::ActOnObjCAtTryStmt(SourceLocation AtLoc, Stmt *Try,
-                         MultiStmtArg CatchStmts, Stmt *Finally) {
+StmtResult Sema::ActOnObjCAtTryStmt(SourceLocation AtLoc, Stmt *Try,
+                                    MultiStmtArg CatchStmts, Stmt *Finally) {
   if (!getLangOpts().ObjCExceptions)
     Diag(AtLoc, diag::err_objc_exceptions_disabled) << "@try";
 
@@ -4245,9 +4212,8 @@ StmtResult Sema::BuildObjCAtThrowStmt(So
   return new (Context) ObjCAtThrowStmt(AtLoc, Throw);
 }
 
-StmtResult
-Sema::ActOnObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw,
-                           Scope *CurScope) {
+StmtResult Sema::ActOnObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw,
+                                      Scope *CurScope) {
   if (!getLangOpts().ObjCExceptions)
     Diag(AtLoc, diag::err_objc_exceptions_disabled) << "@throw";
 
@@ -4263,8 +4229,8 @@ Sema::ActOnObjCAtThrowStmt(SourceLocatio
   return BuildObjCAtThrowStmt(AtLoc, Throw);
 }
 
-ExprResult
-Sema::ActOnObjCAtSynchronizedOperand(SourceLocation atLoc, Expr *operand) {
+ExprResult Sema::ActOnObjCAtSynchronizedOperand(SourceLocation atLoc,
+                                                Expr *operand) {
   ExprResult result = DefaultLvalueConversion(operand);
   if (result.isInvalid())
     return ExprError();
@@ -4272,27 +4238,26 @@ Sema::ActOnObjCAtSynchronizedOperand(Sou
 
   // Make sure the expression type is an ObjC pointer or "void *".
   QualType type = operand->getType();
-  if (!type->isDependentType() &&
-      !type->isObjCObjectPointerType()) {
+  if (!type->isDependentType() && !type->isObjCObjectPointerType()) {
     const PointerType *pointerType = type->getAs<PointerType>();
     if (!pointerType || !pointerType->getPointeeType()->isVoidType()) {
       if (getLangOpts().CPlusPlus) {
         if (RequireCompleteType(atLoc, type,
                                 diag::err_incomplete_receiver_type))
           return Diag(atLoc, diag::err_objc_synchronized_expects_object)
-                   << type << operand->getSourceRange();
+                 << type << operand->getSourceRange();
 
         ExprResult result = PerformContextuallyConvertToObjCPointer(operand);
         if (result.isInvalid())
           return ExprError();
         if (!result.isUsable())
           return Diag(atLoc, diag::err_objc_synchronized_expects_object)
-                   << type << operand->getSourceRange();
+                 << type << operand->getSourceRange();
 
         operand = result.get();
       } else {
-          return Diag(atLoc, diag::err_objc_synchronized_expects_object)
-                   << type << operand->getSourceRange();
+        return Diag(atLoc, diag::err_objc_synchronized_expects_object)
+               << type << operand->getSourceRange();
       }
     }
   }
@@ -4301,9 +4266,8 @@ Sema::ActOnObjCAtSynchronizedOperand(Sou
   return ActOnFinishFullExpr(operand, /*DiscardedValue*/ false);
 }
 
-StmtResult
-Sema::ActOnObjCAtSynchronizedStmt(SourceLocation AtLoc, Expr *SyncExpr,
-                                  Stmt *SyncBody) {
+StmtResult Sema::ActOnObjCAtSynchronizedStmt(SourceLocation AtLoc,
+                                             Expr *SyncExpr, Stmt *SyncBody) {
   // We can't jump into or indirect-jump out of a @synchronized block.
   setFunctionHasBranchProtectedScope();
   return new (Context) ObjCAtSynchronizedStmt(AtLoc, SyncExpr, SyncBody);
@@ -4311,16 +4275,15 @@ Sema::ActOnObjCAtSynchronizedStmt(Source
 
 /// ActOnCXXCatchBlock - Takes an exception declaration and a handler block
 /// and creates a proper catch handler from them.
-StmtResult
-Sema::ActOnCXXCatchBlock(SourceLocation CatchLoc, Decl *ExDecl,
-                         Stmt *HandlerBlock) {
+StmtResult Sema::ActOnCXXCatchBlock(SourceLocation CatchLoc, Decl *ExDecl,
+                                    Stmt *HandlerBlock) {
   // There's nothing to test that ActOnExceptionDecl didn't already test.
   return new (Context)
       CXXCatchStmt(CatchLoc, cast_or_null<VarDecl>(ExDecl), HandlerBlock);
 }
 
-StmtResult
-Sema::ActOnObjCAutoreleasePoolStmt(SourceLocation AtLoc, Stmt *Body) {
+StmtResult Sema::ActOnObjCAutoreleasePoolStmt(SourceLocation AtLoc,
+                                              Stmt *Body) {
   setFunctionHasBranchProtectedScope();
   return new (Context) ObjCAutoreleasePoolStmt(AtLoc, Body);
 }
@@ -4373,12 +4336,12 @@ namespace llvm {
 template <> struct DenseMapInfo<CatchHandlerType> {
   static CatchHandlerType getEmptyKey() {
     return CatchHandlerType(DenseMapInfo<QualType>::getEmptyKey(),
-                       CatchHandlerType::ForDenseMap);
+                            CatchHandlerType::ForDenseMap);
   }
 
   static CatchHandlerType getTombstoneKey() {
     return CatchHandlerType(DenseMapInfo<QualType>::getTombstoneKey(),
-                       CatchHandlerType::ForDenseMap);
+                            CatchHandlerType::ForDenseMap);
   }
 
   static unsigned getHashValue(const CatchHandlerType &Base) {
@@ -4390,7 +4353,7 @@ template <> struct DenseMapInfo<CatchHan
     return LHS == RHS;
   }
 };
-}
+} // namespace llvm
 
 namespace {
 class CatchTypePublicBases {
@@ -4425,7 +4388,7 @@ public:
     return false;
   }
 };
-}
+} // namespace
 
 /// ActOnCXXTryBlock - Takes a try compound-statement and a number of
 /// handlers and creates a try statement from them.
@@ -4500,7 +4463,7 @@ StmtResult Sema::ActOnCXXTryBlock(Source
                diag::warn_exception_caught_by_earlier_handler)
               << H->getCaughtType();
           Diag(Problem->getExceptionDecl()->getTypeSpecStartLoc(),
-                diag::note_previous_exception_handler)
+               diag::note_previous_exception_handler)
               << Problem->getCaughtType();
         }
       }
@@ -4579,9 +4542,7 @@ void Sema::ActOnStartSEHFinallyBlock() {
   CurrentSEHFinally.push_back(CurScope);
 }
 
-void Sema::ActOnAbortSEHFinallyBlock() {
-  CurrentSEHFinally.pop_back();
-}
+void Sema::ActOnAbortSEHFinallyBlock() { CurrentSEHFinally.pop_back(); }
 
 StmtResult Sema::ActOnFinishSEHFinallyBlock(SourceLocation Loc, Stmt *Block) {
   assert(Block);
@@ -4589,8 +4550,7 @@ StmtResult Sema::ActOnFinishSEHFinallyBl
   return SEHFinallyStmt::Create(Context, Loc, Block);
 }
 
-StmtResult
-Sema::ActOnSEHLeaveStmt(SourceLocation Loc, Scope *CurScope) {
+StmtResult Sema::ActOnSEHLeaveStmt(SourceLocation Loc, Scope *CurScope) {
   Scope *SEHTryParent = CurScope;
   while (SEHTryParent && !SEHTryParent->isSEHTryScope())
     SEHTryParent = SEHTryParent->getParent();
@@ -4605,28 +4565,23 @@ StmtResult Sema::BuildMSDependentExistsS
                                             bool IsIfExists,
                                             NestedNameSpecifierLoc QualifierLoc,
                                             DeclarationNameInfo NameInfo,
-                                            Stmt *Nested)
-{
-  return new (Context) MSDependentExistsStmt(KeywordLoc, IsIfExists,
-                                             QualifierLoc, NameInfo,
-                                             cast<CompoundStmt>(Nested));
+                                            Stmt *Nested) {
+  return new (Context)
+      MSDependentExistsStmt(KeywordLoc, IsIfExists, QualifierLoc, NameInfo,
+                            cast<CompoundStmt>(Nested));
 }
 
-
 StmtResult Sema::ActOnMSDependentExistsStmt(SourceLocation KeywordLoc,
-                                            bool IsIfExists,
-                                            CXXScopeSpec &SS,
-                                            UnqualifiedId &Name,
-                                            Stmt *Nested) {
+                                            bool IsIfExists, CXXScopeSpec &SS,
+                                            UnqualifiedId &Name, Stmt *Nested) {
   return BuildMSDependentExistsStmt(KeywordLoc, IsIfExists,
                                     SS.getWithLocInContext(Context),
-                                    GetNameFromUnqualifiedId(Name),
-                                    Nested);
+                                    GetNameFromUnqualifiedId(Name), Nested);
 }
 
-RecordDecl*
-Sema::CreateCapturedStmtRecordDecl(CapturedDecl *&CD, SourceLocation Loc,
-                                   unsigned NumParams) {
+RecordDecl *Sema::CreateCapturedStmtRecordDecl(CapturedDecl *&CD,
+                                               SourceLocation Loc,
+                                               unsigned NumParams) {
   DeclContext *DC = CurContext;
   while (!(DC->isFunctionOrMethod() || DC->isRecord() || DC->isFileContext()))
     DC = DC->getParent();
@@ -4669,8 +4624,8 @@ buildCapturedStmtCaptureList(Sema &S, Ca
 
     // Add the capture to our list of captures.
     if (Cap.isThisCapture()) {
-      Captures.push_back(CapturedStmt::Capture(Cap.getLocation(),
-                                               CapturedStmt::VCK_This));
+      Captures.push_back(
+          CapturedStmt::Capture(Cap.getLocation(), CapturedStmt::VCK_This));
     } else if (Cap.isVLATypeCapture()) {
       Captures.push_back(
           CapturedStmt::Capture(Cap.getLocation(), CapturedStmt::VCK_VLAType));
@@ -4789,7 +4744,7 @@ void Sema::ActOnCapturedRegionError() {
   RecordDecl *Record = RSI->TheRecordDecl;
   Record->setInvalidDecl();
 
-  SmallVector<Decl*, 4> Fields(Record->fields());
+  SmallVector<Decl *, 4> Fields(Record->fields());
   ActOnFields(/*Scope=*/nullptr, Record->getLocation(), Record, Fields,
               SourceLocation(), SourceLocation(), ParsedAttributesView());
 }
diff --color -uprN clang-14.0.6.src/lib/Serialization/ASTWriterStmt.cpp clang-14.0.6.src.patched/lib/Serialization/ASTWriterStmt.cpp
--- clang-14.0.6.src/lib/Serialization/ASTWriterStmt.cpp	2022-06-23 00:46:24.000000000 +0800
+++ clang-14.0.6.src.patched/lib/Serialization/ASTWriterStmt.cpp	2024-11-12 13:24:23.357485188 +0800
@@ -11,15 +11,15 @@
 ///
 //===----------------------------------------------------------------------===//
 
-#include "clang/AST/ExprOpenMP.h"
-#include "clang/Serialization/ASTRecordWriter.h"
-#include "clang/Sema/DeclSpec.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclCXX.h"
 #include "clang/AST/DeclObjC.h"
 #include "clang/AST/DeclTemplate.h"
+#include "clang/AST/ExprOpenMP.h"
 #include "clang/AST/StmtVisitor.h"
 #include "clang/Lex/Token.h"
+#include "clang/Sema/DeclSpec.h"
+#include "clang/Serialization/ASTRecordWriter.h"
 #include "llvm/Bitstream/BitstreamWriter.h"
 using namespace clang;
 
@@ -29,35 +29,34 @@ using namespace clang;
 
 namespace clang {
 
-  class ASTStmtWriter : public StmtVisitor<ASTStmtWriter, void> {
-    ASTWriter &Writer;
-    ASTRecordWriter Record;
-
-    serialization::StmtCode Code;
-    unsigned AbbrevToUse;
-
-  public:
-    ASTStmtWriter(ASTWriter &Writer, ASTWriter::RecordData &Record)
-        : Writer(Writer), Record(Writer, Record),
-          Code(serialization::STMT_NULL_PTR), AbbrevToUse(0) {}
-
-    ASTStmtWriter(const ASTStmtWriter&) = delete;
-
-    uint64_t Emit() {
-      assert(Code != serialization::STMT_NULL_PTR &&
-             "unhandled sub-statement writing AST file");
-      return Record.EmitStmt(Code, AbbrevToUse);
-    }
+class ASTStmtWriter : public StmtVisitor<ASTStmtWriter, void> {
+  ASTWriter &Writer;
+  ASTRecordWriter Record;
+
+  serialization::StmtCode Code;
+  unsigned AbbrevToUse;
+
+public:
+  ASTStmtWriter(ASTWriter &Writer, ASTWriter::RecordData &Record)
+      : Writer(Writer), Record(Writer, Record),
+        Code(serialization::STMT_NULL_PTR), AbbrevToUse(0) {}
+
+  ASTStmtWriter(const ASTStmtWriter &) = delete;
 
-    void AddTemplateKWAndArgsInfo(const ASTTemplateKWAndArgsInfo &ArgInfo,
-                                  const TemplateArgumentLoc *Args);
+  uint64_t Emit() {
+    assert(Code != serialization::STMT_NULL_PTR &&
+           "unhandled sub-statement writing AST file");
+    return Record.EmitStmt(Code, AbbrevToUse);
+  }
+
+  void AddTemplateKWAndArgsInfo(const ASTTemplateKWAndArgsInfo &ArgInfo,
+                                const TemplateArgumentLoc *Args);
 
-    void VisitStmt(Stmt *S);
-#define STMT(Type, Base) \
-    void Visit##Type(Type *);
+  void VisitStmt(Stmt *S);
+#define STMT(Type, Base) void Visit##Type(Type *);
 #include "clang/AST/StmtNodes.inc"
-  };
-}
+};
+} // namespace clang
 
 void ASTStmtWriter::AddTemplateKWAndArgsInfo(
     const ASTTemplateKWAndArgsInfo &ArgInfo, const TemplateArgumentLoc *Args) {
@@ -68,8 +67,7 @@ void ASTStmtWriter::AddTemplateKWAndArgs
     Record.AddTemplateArgumentLoc(Args[i]);
 }
 
-void ASTStmtWriter::VisitStmt(Stmt *S) {
-}
+void ASTStmtWriter::VisitStmt(Stmt *S) {}
 
 void ASTStmtWriter::VisitNullStmt(NullStmt *S) {
   VisitStmt(S);
@@ -313,7 +311,8 @@ void ASTStmtWriter::VisitGCCAsmStmt(GCCA
     Record.AddStmt(S->getClobberStringLiteral(I));
 
   // Labels
-  for (auto *E : S->labels()) Record.AddStmt(E);
+  for (auto *E : S->labels())
+    Record.AddStmt(E);
 
   Code = serialization::STMT_GCCASM;
 }
@@ -408,8 +407,8 @@ addConstraintSatisfaction(ASTRecordWrite
       if (E)
         Record.AddStmt(E);
       else {
-        auto *Diag = DetailRecord.second.get<std::pair<SourceLocation,
-                                                       StringRef> *>();
+        auto *Diag =
+            DetailRecord.second.get<std::pair<SourceLocation, StringRef> *>();
         Record.AddSourceLocation(Diag->first);
         Record.AddString(Diag->second);
       }
@@ -417,8 +416,7 @@ addConstraintSatisfaction(ASTRecordWrite
   }
 }
 
-static void
-addSubstitutionDiagnostic(
+static void addSubstitutionDiagnostic(
     ASTRecordWriter &Record,
     const concepts::Requirement::SubstitutionDiagnostic *D) {
   Record.AddString(D->SubstitutedEntity);
@@ -427,7 +425,7 @@ addSubstitutionDiagnostic(
 }
 
 void ASTStmtWriter::VisitConceptSpecializationExpr(
-        ConceptSpecializationExpr *E) {
+    ConceptSpecializationExpr *E) {
   VisitExpr(E);
   ArrayRef<TemplateArgument> TemplateArgs = E->getTemplateArguments();
   Record.push_back(TemplateArgs.size());
@@ -466,8 +464,10 @@ void ASTStmtWriter::VisitRequiresExpr(Re
       Record.push_back(ExprReq->getKind());
       Record.push_back(ExprReq->Status);
       if (ExprReq->isExprSubstitutionFailure()) {
-        addSubstitutionDiagnostic(Record,
-         ExprReq->Value.get<concepts::Requirement::SubstitutionDiagnostic *>());
+        addSubstitutionDiagnostic(
+            Record,
+            ExprReq->Value
+                .get<concepts::Requirement::SubstitutionDiagnostic *>());
       } else
         Record.AddStmt(ExprReq->Value.get<Expr *>());
       if (ExprReq->getKind() == concepts::Requirement::RK_Compound) {
@@ -493,7 +493,7 @@ void ASTStmtWriter::VisitRequiresExpr(Re
       auto *NestedReq = cast<concepts::NestedRequirement>(R);
       Record.push_back(concepts::Requirement::RK_Nested);
       Record.push_back(NestedReq->isSubstitutionFailure());
-      if (NestedReq->isSubstitutionFailure()){
+      if (NestedReq->isSubstitutionFailure()) {
         addSubstitutionDiagnostic(Record,
                                   NestedReq->getSubstitutionDiagnostic());
       } else {
@@ -508,7 +508,6 @@ void ASTStmtWriter::VisitRequiresExpr(Re
   Code = serialization::EXPR_REQUIRES;
 }
 
-
 void ASTStmtWriter::VisitCapturedStmt(CapturedStmt *S) {
   VisitStmt(S);
   // NumCaptures
@@ -938,8 +937,8 @@ void ASTStmtWriter::VisitObjCIsaExpr(Obj
   Code = serialization::EXPR_OBJC_ISA;
 }
 
-void ASTStmtWriter::
-VisitObjCIndirectCopyRestoreExpr(ObjCIndirectCopyRestoreExpr *E) {
+void ASTStmtWriter::VisitObjCIndirectCopyRestoreExpr(
+    ObjCIndirectCopyRestoreExpr *E) {
   VisitExpr(E);
   Record.AddStmt(E->getSubExpr());
   Record.push_back(E->shouldCopy());
@@ -961,8 +960,8 @@ void ASTStmtWriter::VisitCastExpr(CastEx
   Record.AddStmt(E->getSubExpr());
   Record.push_back(E->getCastKind()); // FIXME: stable encoding
 
-  for (CastExpr::path_iterator
-         PI = E->path_begin(), PE = E->path_end(); PI != PE; ++PI)
+  for (CastExpr::path_iterator PI = E->path_begin(), PE = E->path_end();
+       PI != PE; ++PI)
     Record.AddCXXBaseSpecifier(**PI);
 
   if (E->hasStoredFPFeatures())
@@ -1001,8 +1000,8 @@ void ASTStmtWriter::VisitConditionalOper
   Code = serialization::EXPR_CONDITIONAL_OPERATOR;
 }
 
-void
-ASTStmtWriter::VisitBinaryConditionalOperator(BinaryConditionalOperator *E) {
+void ASTStmtWriter::VisitBinaryConditionalOperator(
+    BinaryConditionalOperator *E) {
   VisitExpr(E);
   Record.AddStmt(E->getOpaqueValue());
   Record.AddStmt(E->getCommon());
@@ -1060,7 +1059,7 @@ void ASTStmtWriter::VisitInitListExpr(In
   Record.AddStmt(E->getSyntacticForm());
   Record.AddSourceLocation(E->getLBraceLoc());
   Record.AddSourceLocation(E->getRBraceLoc());
-  bool isArrayFiller = E->ArrayFillerOrUnionFieldInit.is<Expr*>();
+  bool isArrayFiller = E->ArrayFillerOrUnionFieldInit.is<Expr *>();
   Record.push_back(isArrayFiller);
   if (isArrayFiller)
     Record.AddStmt(E->getArrayFiller());
@@ -1257,8 +1256,9 @@ void ASTStmtWriter::VisitPseudoObjectExp
   Record.push_back(result);
 
   Record.AddStmt(E->getSyntacticForm());
-  for (PseudoObjectExpr::semantics_iterator
-         i = E->semantics_begin(), e = E->semantics_end(); i != e; ++i) {
+  for (PseudoObjectExpr::semantics_iterator i = E->semantics_begin(),
+                                            e = E->semantics_end();
+       i != e; ++i) {
     Record.AddStmt(*i);
   }
   Code = serialization::EXPR_PSEUDO_OBJECT;
@@ -1512,7 +1512,8 @@ void ASTStmtWriter::VisitObjCBoolLiteral
   Code = serialization::EXPR_OBJC_BOOL_LITERAL;
 }
 
-void ASTStmtWriter::VisitObjCAvailabilityCheckExpr(ObjCAvailabilityCheckExpr *E) {
+void ASTStmtWriter::VisitObjCAvailabilityCheckExpr(
+    ObjCAvailabilityCheckExpr *E) {
   VisitExpr(E);
   Record.AddSourceRange(E->getSourceRange());
   Record.AddVersionTuple(E->getVersion());
@@ -1635,7 +1636,7 @@ void ASTStmtWriter::VisitLambdaExpr(Lamb
 
   // Add capture initializers.
   for (LambdaExpr::capture_init_iterator C = E->capture_init_begin(),
-                                      CEnd = E->capture_init_end();
+                                         CEnd = E->capture_init_end();
        C != CEnd; ++C) {
     Record.AddStmt(*C);
   }
@@ -1646,7 +1647,8 @@ void ASTStmtWriter::VisitLambdaExpr(Lamb
   Code = serialization::EXPR_LAMBDA;
 }
 
-void ASTStmtWriter::VisitCXXStdInitializerListExpr(CXXStdInitializerListExpr *E) {
+void ASTStmtWriter::VisitCXXStdInitializerListExpr(
+    CXXStdInitializerListExpr *E) {
   VisitExpr(E);
   Record.AddStmt(E->getSubExpr());
   Code = serialization::EXPR_CXX_STD_INITIALIZER_LIST;
@@ -1887,8 +1889,8 @@ void ASTStmtWriter::VisitCXXDependentSco
   Code = serialization::EXPR_CXX_DEPENDENT_SCOPE_MEMBER;
 }
 
-void
-ASTStmtWriter::VisitDependentScopeDeclRefExpr(DependentScopeDeclRefExpr *E) {
+void ASTStmtWriter::VisitDependentScopeDeclRefExpr(
+    DependentScopeDeclRefExpr *E) {
   VisitExpr(E);
 
   // Don't emit anything here, HasTemplateKWAndArgsInfo must be
@@ -1908,12 +1910,13 @@ ASTStmtWriter::VisitDependentScopeDeclRe
   Code = serialization::EXPR_CXX_DEPENDENT_SCOPE_DECL_REF;
 }
 
-void
-ASTStmtWriter::VisitCXXUnresolvedConstructExpr(CXXUnresolvedConstructExpr *E) {
+void ASTStmtWriter::VisitCXXUnresolvedConstructExpr(
+    CXXUnresolvedConstructExpr *E) {
   VisitExpr(E);
   Record.push_back(E->getNumArgs());
-  for (CXXUnresolvedConstructExpr::arg_iterator
-         ArgI = E->arg_begin(), ArgE = E->arg_end(); ArgI != ArgE; ++ArgI)
+  for (CXXUnresolvedConstructExpr::arg_iterator ArgI = E->arg_begin(),
+                                                ArgE = E->arg_end();
+       ArgI != ArgE; ++ArgI)
     Record.AddStmt(*ArgI);
   Record.AddTypeSourceInfo(E->getTypeSourceInfo());
   Record.AddSourceLocation(E->getLParenLoc());
@@ -2026,7 +2029,7 @@ void ASTStmtWriter::VisitSizeOfPackExpr(
 }
 
 void ASTStmtWriter::VisitSubstNonTypeTemplateParmExpr(
-                                              SubstNonTypeTemplateParmExpr *E) {
+    SubstNonTypeTemplateParmExpr *E) {
   VisitExpr(E);
   Record.AddDeclRef(E->getParameter());
   Record.push_back(E->isReferenceParameter());
@@ -2036,7 +2039,7 @@ void ASTStmtWriter::VisitSubstNonTypeTem
 }
 
 void ASTStmtWriter::VisitSubstNonTypeTemplateParmPackExpr(
-                                          SubstNonTypeTemplateParmPackExpr *E) {
+    SubstNonTypeTemplateParmPackExpr *E) {
   VisitExpr(E);
   Record.AddDeclRef(E->getParameterPack());
   Record.AddTemplateArgument(E->getArgumentPack());
@@ -2049,8 +2052,8 @@ void ASTStmtWriter::VisitFunctionParmPac
   Record.push_back(E->getNumExpansions());
   Record.AddDeclRef(E->getParameterPack());
   Record.AddSourceLocation(E->getParameterPackLocation());
-  for (FunctionParmPackExpr::iterator I = E->begin(), End = E->end();
-       I != End; ++I)
+  for (FunctionParmPackExpr::iterator I = E->begin(), End = E->end(); I != End;
+       ++I)
     Record.AddDeclRef(*I);
   Code = serialization::EXPR_FUNCTION_PARM_PACK;
 }
@@ -2613,9 +2616,7 @@ unsigned ASTWriter::getSwitchCaseID(Swit
   return SwitchCaseIDs[S];
 }
 
-void ASTWriter::ClearSwitchCaseIDs() {
-  SwitchCaseIDs.clear();
-}
+void ASTWriter::ClearSwitchCaseIDs() { SwitchCaseIDs.clear(); }
 
 /// Write the given substatement or subexpression to the
 /// bitstream.
@@ -2644,12 +2645,10 @@ void ASTWriter::WriteSubStmt(Stmt *S) {
     llvm::DenseSet<Stmt *> &ParentStmts;
 
     ParentStmtInserterRAII(Stmt *S, llvm::DenseSet<Stmt *> &ParentStmts)
-      : S(S), ParentStmts(ParentStmts) {
+        : S(S), ParentStmts(ParentStmts) {
       ParentStmts.insert(S);
     }
-    ~ParentStmtInserterRAII() {
-      ParentStmts.erase(S);
-    }
+    ~ParentStmtInserterRAII() { ParentStmts.erase(S); }
   };
 
   ParentStmtInserterRAII ParentStmtInserter(S, ParentStmts);
@@ -2666,8 +2665,10 @@ void ASTWriter::WriteSubStmt(Stmt *S) {
 void ASTRecordWriter::FlushStmts() {
   // We expect to be the only consumer of the two temporary statement maps,
   // assert that they are empty.
-  assert(Writer->SubStmtEntries.empty() && "unexpected entries in sub-stmt map");
-  assert(Writer->ParentStmts.empty() && "unexpected entries in parent stmt map");
+  assert(Writer->SubStmtEntries.empty() &&
+         "unexpected entries in sub-stmt map");
+  assert(Writer->ParentStmts.empty() &&
+         "unexpected entries in parent stmt map");
 
   for (unsigned I = 0, N = StmtsToEmit.size(); I != N; ++I) {
     Writer->WriteSubStmt(StmtsToEmit[I]);
